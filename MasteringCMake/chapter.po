# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Ken Martin, Bill Hoffman
# This file is distributed under the same license as the Mastering CMake
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr "Project-Id-Version: Mastering CMake \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-12-15 15:41+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: it\n"
"Language-Team: it <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../../source/chapter/CDash.rst:2
msgid "CDash"
msgstr "CDash"

#: ../../source/chapter/CDash.rst:4
msgid ""
"As your project's testing needs grow, keeping track of the test results "
"can become overwhelming. This is especially true for projects that are "
"tested nightly on a number of different platforms. In these cases, we "
"recommend using a test dashboard to summarize the test results."
msgstr "Man mano che le esigenze dei test del progetto crescono, la gestione dei risultati può diventare travolgente. Ciò è particolarmente vero per i progetti che vengono testati ogni notte su diverse piattaforme. In questi casi, si consiglia di utilizzare una dashboard di test per riepilogare i risultati del test."

#: ../../source/chapter/CDash.rst:10
msgid ""
"A test dashboard summarizes the results for many tests on many platforms,"
" and its hyperlinks allow people to drill down into additional levels of "
"detail quickly. The CTest executable includes support for producing test "
"dashboards. When run with the correct options, CTest will produce XML-"
"based output recording the build and test results, and post them to a "
"dashboard server. The dashboard server runs an open source software "
"package called CDash. CDash collects the XML results and produces HTML "
"web pages from them."
msgstr "Un dashboard di test riassume i risultati di molti test su molte piattaforme e i suoi collegamenti ipertestuali consentono di approfondire rapidamente ulteriori livelli di dettaglio. L'eseguibile CTest include il supporto per la produzione di dashboard di test. Se eseguito con le opzioni corrette, CTest produrrà un output basato su XML registrando i risultati della build e del test e inviandoli a un server dashboard. Il server dashboard esegue un pacchetto software open source chiamato CDash. CDash raccoglie i risultati XML e da essi produce pagine Web HTML."

#: ../../source/chapter/CDash.rst:19
msgid ""
"Before discussing how to use CTest to produce a dashboard, let us "
"consider the main parts of a testing dashboard. Each night at a specified"
" time, the dashboard server will open up a new dashboard so each day "
"there is a new web page showing the results of tests for that twenty-four"
" hour period. There are links on the main page that allow you to quickly "
"navigate through different days. Looking at the main page for a project "
"(such as CMake's dashboard off of www.cmake.org), you will see that it is"
" divided into a few main components. Near the top you will find a set of "
"links that allow you to step to previous dashboards, as well as links to "
"project pages such as the bug tracker, documentation, etc."
msgstr "Prima di discutere su come utilizzare CTest per produrre una dashboard, consideriamo le parti principali di una dashboard di test. Ogni notte a un'ora specificata, il server della dashboard aprirà una nuova dashboard, quindi ogni giorno c'è una nuova pagina web che mostra i risultati dei test per quel periodo di ventiquattro ore. Ci sono link nella pagina principale che consentono di navigare rapidamente in giorni diversi. Guardando la pagina principale di un progetto (come la dashboard di CMake su www.cmake.org), si vedrà che è divisa in alcuni componenti principali. Nella parte superiore ci sono una serie di collegamenti che consentono di passare a dashboard precedenti, nonché link a pagine di progetto come bug tracker, documentazione, ecc."

#: ../../source/chapter/CDash.rst:31
msgid ""
"Below that, you will find groups of results. Typically groups that you "
"will find include Nightly, Experimental, Continuous, Coverage, and "
"Dynamic Analysis. The category into which a dashboard entry will be "
"placed depends on how it was generated. The simplest are Experimental "
"entries which represent dashboard results for someone's current copy of "
"the project's source code. With an experimental dashboard, the source "
"code is not guaranteed to be up to date. In contrast a Nightly dashboard "
"entry is one where CTest tries to update the source code to a specific "
"date and time. The expectation is that all nightly dashboard entries for "
"a given day should be based on the same source code."
msgstr "Sotto, si trovano gruppi di risultati. In genere i gruppi includono Nightly, Experimental, Continuous, Coverage e Dynamic Analysis. La categoria in cui verrà inserita una voce della dashboard dipende da come è stata generata. Le più semplici sono voci Experimental che rappresentano i risultati della dashboard per la copia corrente di qualcuno del codice sorgente del progetto. Con una dashboard sperimentale, non è garantito che il codice sorgente sia aggiornato. Al contrario, una voce della dashboard Nightly è quella in cui CTest tenta di aggiornare il codice sorgente a una data e un'ora specifiche. L'aspettativa è che tutte le voci del dashboard nightly per un determinato giorno siano basate sullo stesso codice sorgente."

#: ../../source/chapter/CDash.rst:42
msgid ""
"A continuous dashboard entry is one that is designed to run every time "
"new files are checked in. Depending on how frequently new files are "
"checked in a single day's dashboard could have many continuous entries. "
"Continuous dashboards are particularly helpful for cross platform "
"projects where a problem may only show up on some platforms. In those "
"cases a developer can commit a change that works for them on their "
"platform and then another platform running a continuous build could catch"
" the error, allowing the developer to correct the problem promptly."
msgstr "Una voce nelle dashboard Continuous viene eseguita ogni volta che vengono archiviati nuovi file. A seconda della frequenza con cui i nuovi file vengono controllati, la dashboard di un singolo giorno potrebbe avere molte voci. Le dashboard Continuous sono particolarmente utili per i progetti multipiattaforma in cui un problema può presentarsi solo su alcune piattaforme. In questi casi uno sviluppatore può eseguire il commit di una modifica che funziona per loro sulla propria piattaforma e poi un'altra piattaforma che esegue una build continua potrebbe rilevare l'errore, consentendo allo sviluppatore di correggere il problema prontamente."

#: ../../source/chapter/CDash.rst:56
msgid ""
"Dynamic Analysis and Coverage dashboards are designed to test the memory "
"safety and code coverage of a project. A Dynamic Analysis dashboard entry"
" is one where all the tests are run with a memory access/leak checking "
"program enabled. Any resulting errors or warnings are parsed, summarized "
"and displayed. This is important to verify that your software is not "
"leaking memory, or reading from uninitialized memory. Coverage dashboard "
"entries are similar in that all the tests are run, but as they are the "
"lines of code being executed are tracked. When all the tests have been "
"run, a listing of how many times each line of code was executed is "
"produced and displayed on the dashboard."
msgstr "Le dashboard Dynamic Analysis e Coverage sono progettate per testare la sicurezza della memoria e la copertura del codice di un progetto. Una voce nella dashboard Dynamic Analysis è quella in cui tutti i test vengono eseguiti con un programma per la memoria riguardo l'accesso e il controllo dei leak abilitato. Eventuali errori o warning risultanti vengono analizzati, riepilogati e visualizzati. Questo è importante per verificare che il software non stia perdendo memoria [leak] o leggendo dalla memoria non inizializzata. Le voci della dashboard Coverage sono simili in quanto vengono eseguiti tutti i test, ma poiché sono le righe di codice in esecuzione, vengono monitorate. Quando tutti i test sono stati eseguiti, viene prodotto e visualizzato sulla dashboard un elenco di quante volte ciascuna riga di codice è stata eseguita."

#: ../../source/chapter/CDash.rst:73
msgid "Adding CDash Dashboard Support to a Project"
msgstr "Aggiungere il Supporto CDash Dashboard a un Progetto"

#: ../../source/chapter/CDash.rst:75
msgid ""
"The easiest way to start using CDash is to register an account and create"
" a new project at https://my.cdash.org."
msgstr "Il modo più semplice per iniziare a utilizzare CDash è registrare un account e creare un nuovo progetto su https://my.cdash.org."

#: ../../source/chapter/CDash.rst:77
msgid ""
"If you'd prefer to install your own CDash server, please follow one of "
"these guides:"
msgstr "Se si preferisce installare il proprio server CDash, seguire una di queste guide:"

#: ../../source/chapter/CDash.rst:79
msgid ""
"`Installation guide "
"<https://github.com/Kitware/CDash/blob/master/docs/install.md>`_"
msgstr "`Installation guide <https://github.com/Kitware/CDash/blob/master/docs/install.md>`_"

#: ../../source/chapter/CDash.rst:80
msgid ""
"`Docker instructions "
"<https://github.com/Kitware/CDash/blob/master/docs/docker.md>`_"
msgstr "`Docker instructions <https://github.com/Kitware/CDash/blob/master/docs/docker.md>`_"

#: ../../source/chapter/CDash.rst:87
msgid "Client Setup"
msgstr "Configurazione del Client"

#: ../../source/chapter/CDash.rst:92
msgid ""
"To support dashboards in your project you need to include the "
":module:`CTest` module as follows."
msgstr "Per supportare le dashboard nel progetto si deve includere il modulo :module:`CTest` come segue."

#: ../../source/chapter/CDash.rst:100
msgid ""
"The CTest module will then read settings from the ``CTestConfig.cmake`` "
"file you created or downloaded from CDash. If you have added "
":command:`add_test` command calls to your project creating a dashboard "
"entry is as simple as running::"
msgstr "Il modulo CTest leggerà quindi le impostazioni dal file ``CTestConfig.cmake`` creato o scaricato da CDash. Se sono state aggiunte chiamate al comando :command:`add_test` al progetto, creare una voce della dashboard è semplice come eseguire::"

#: ../../source/chapter/CDash.rst:107
msgid ""
"The ``-D`` option tells CTest to create a dashboard entry. The next "
"argument indicates what type of dashboard entry to create. Creating a "
"dashboard entry involves quite a few steps that can be run independently,"
" or as one command. In this example, the Experimental argument will cause"
" CTest to perform a number of different steps as one command. The "
"different steps of creating a dashboard entry are summarized below."
msgstr "L'opzione ``-D`` indica a CTest di creare una voce della dashboard. L'argomento successivo indica il tipo di voce della dashboard da creare. La creazione di una voce della dashboard comporta alcuni passaggi che possono essere eseguiti in modo indipendente o come un unico comando. In questo esempio, l'argomento Experimental farà in modo che CTest esegua una serie di passaggi diversi come un unico comando. Di seguito sono riepilogate le diverse fasi della creazione di una voce della dashboard."

#: ../../source/chapter/CDash.rst:121
msgid "**Start**"
msgstr "**Start**"

#: ../../source/chapter/CDash.rst:116
msgid ""
"Prepare a new dashboard entry. This creates a ``Testing`` subdirectory in"
" the build directory. The ``Testing`` subdirectory will contain a "
"subdirectory for the dashboard results with a name that corresponds to "
"the dashboard time. The ``Testing`` subdirectory will also contain a "
"subdirectory for the temporary testing results called ``Temporary``."
msgstr "Prepara una nuova voce della dashboard. Questo crea una sottodirectory ``Testing`` nella directory di build. La sottodirectory ``Testing`` conterrà una sottodirectory per i risultati della dashboard con un nome che corrisponde all'ora della dashboard. La sottodirectory ``Testing`` conterrà anche una sottodirectory per i risultati temporanei dei test chiamata ``Temporary``."

#: ../../source/chapter/CDash.rst:126
msgid "**Update**"
msgstr "**Update**"

#: ../../source/chapter/CDash.rst:124
msgid ""
"Perform a source control update of the source code (typically used for "
"nightly or continuous runs). Currently CTest supports Concurrent Versions"
" System (CVS), Subversion, Git, Mercurial, and Bazaar."
msgstr "Esegue un aggiornamento del controllo del codice sorgente (in genere utilizzato per esecuzioni notturne o 'continuous'). Attualmente CTest supporta Concurrent Versions System (CVS), Subversion, Git, Mercurial e Bazaar."

#: ../../source/chapter/CDash.rst:130
msgid "**Configure**"
msgstr "**Configure**"

#: ../../source/chapter/CDash.rst:129
msgid ""
"Run CMake on the project to make sure the Makefiles or project files are "
"up to date."
msgstr "Esegue CMake sul progetto per assicurare che i Makefile o i file di progetto siano aggiornati."

#: ../../source/chapter/CDash.rst:133
msgid "**Build**"
msgstr "**Build**"

#: ../../source/chapter/CDash.rst:133
msgid "Build the software using the specified generator."
msgstr "Build del software utilizzando il generatore specificato."

#: ../../source/chapter/CDash.rst:136
msgid "**Test**"
msgstr "**Test**"

#: ../../source/chapter/CDash.rst:136
msgid "Run all the tests and record the results."
msgstr "Esegue tutti i test e registra i risultati."

#: ../../source/chapter/CDash.rst:143
msgid "**MemoryCheck**"
msgstr "**MemoryCheck**"

#: ../../source/chapter/CDash.rst:143
msgid "Perform memory checks using Purify or valgrind."
msgstr "Esegue i controlli della memoria usando Purify o valgrind."

#: ../../source/chapter/CDash.rst:146
msgid "**Coverage**"
msgstr "**Coverage**"

#: ../../source/chapter/CDash.rst:146
msgid "Collect source code coverage information using gcov or Bullseye."
msgstr "Raccoglie informazioni sulla copertura del codice sorgente utilizzando gcov o Bullseye."

#: ../../source/chapter/CDash.rst:149
msgid "**Submit**"
msgstr "**Submit**"

#: ../../source/chapter/CDash.rst:149
msgid "Submit the testing results as a dashboard entry to the server."
msgstr "Invia i risultati del test come voce della dashboard al server."

#: ../../source/chapter/CDash.rst:151
msgid ""
"Each of these steps can be run independently for a Nightly or "
"Experimental entry using the following syntax::"
msgstr "Ciascuno di questi passaggi può essere eseguito indipendentemente per una voce Nightly o Experimental utilizzando la seguente sintassi::"

#: ../../source/chapter/CDash.rst:158
msgid "or"
msgstr "oppure"

#: ../../source/chapter/CDash.rst:166
msgid ""
"Alternatively, you can use shortcuts that perform the most common "
"combinations all at once. The shortcuts that CTest has defined include:"
msgstr "In alternativa, si possono utilizzare le scorciatoie che eseguono le combinazioni più comuni tutte in una volta. Le [shortcut] che CTest ha definito includono:"

#: ../../source/chapter/CDash.rst:172
msgid "**ctest -D Experimental**"
msgstr "**ctest -D Experimental**"

#: ../../source/chapter/CDash.rst:171
msgid "performs the start, configure, build, test, coverage, and submit commands."
msgstr "esegue i comandi start, configure, build, test, coverage e submit."

#: ../../source/chapter/CDash.rst:176
msgid "**ctest -D Nightly**"
msgstr "**ctest -D Nightly**"

#: ../../source/chapter/CDash.rst:175 ../../source/chapter/CDash.rst:179
msgid ""
"performs the start, update, configure, build, test, coverage, and submit "
"commands."
msgstr "esegue i comandi start, update, configure, build, test, coverage e submit."

#: ../../source/chapter/CDash.rst:180
msgid "**ctest -D Continuous**"
msgstr "**ctest -D Continuous**"

#: ../../source/chapter/CDash.rst:184
msgid "**ctest -D MemoryCheck**"
msgstr "**ctest -D MemoryCheck**"

#: ../../source/chapter/CDash.rst:183
msgid ""
"performs the start, configure, build, memorycheck, coverage, and submit "
"commands."
msgstr "esegue i comandi start, configure, build, memorycheck, coverage e submit."

#: ../../source/chapter/CDash.rst:186
msgid ""
"When first setting up a dashboard it is often useful to combine the "
"``-D`` option with the ``-V`` option. This will allow you to see the "
"output of all the different stages of the dashboard process. Likewise, "
"CTest maintains log files in the ``Testing/Temporary`` directory it "
"creates in your binary tree. There you will find log files for the most "
"recent dashboard run. The dashboard results (XML files) are stored in the"
" ``Testing`` directory as well."
msgstr "Quando si configura per la prima volta una dashboard è spesso utile combinare l'opzione ``-D`` con la ``-V``. Ciò consentirà di vedere l'output di tutte le diverse fasi del processo della dashboard. Allo stesso modo, CTest mantiene i file di log nella directory ``Testing/Temporary`` che crea nell'albero binario. Lì ci sono i file di log per l'esecuzione più recente della dashboard. Anche i risultati della dashboard (file XML) vengono archiviati nella directory ``Testing``."

#: ../../source/chapter/CDash.rst:195
msgid "Customizing Dashboards for a Project"
msgstr "Personalizzazione di una Dashboard per un Progetto"

#: ../../source/chapter/CDash.rst:197
msgid ""
"CTest has a few options that can be used to control how it processes a "
"project. If, when CTest runs a dashboard, it finds ``CTestCustom.ctest`` "
"files in the binary tree, it will load these files and use the settings "
"from them to control its behavior. The syntax of a CTestCustom file is "
"the same as regular CMake syntax. That said, only set commands are "
"normally used in this file. These commands specify properties that CTest "
"will consider when performing the testing."
msgstr "CTest ha alcune opzioni che possono essere utilizzate per controllare come elabora un progetto. Se, quando CTest esegue una dashboard, trova i file ``CTestCustom.ctest`` nell'albero binario, caricherà questi file e utilizzerà le relative impostazioni per controllarne il comportamento. La sintassi di un file CTestCustom è la stessa della normale sintassi di CMake. Detto questo, in questo file vengono normalmente utilizzati solo i comandi set. Questi comandi specificano le proprietà che CTest prenderà in considerazione durante l'esecuzione del test."

#: ../../source/chapter/CDash.rst:210
msgid "Dashboard Submissions Settings"
msgstr "Impostazioni degli Invii della Dashboard"

#: ../../source/chapter/CDash.rst:212
msgid ""
"A number of the basic dashboard settings are provided in the file that "
"you download from CDash. You can edit these initial values and provide "
"additional values if you wish. The first value that is set is the nightly"
" start time. This is the time that dashboards all around the world will "
"use for checking out their copy of the nightly source code. This time "
"also controls how dashboard submissions will be grouped together. All "
"submissions from the nightly start time until the next nightly start time"
" will be included on the same \"day\"."
msgstr "Alcune delle impostazioni di base della dashboard sono fornite nel file scaricato da CDash. È possibile modificare questi valori iniziali e fornire valori aggiuntivi, se lo si desidera. Il primo valore impostato è l'ora di inizio della nightly. Questo è il tempo che le dashboard di tutto il mondo utilizzeranno per controllare la loro copia del codice sorgente notturno. Questo tempo controlla anche il modo in cui gli invii della dashboard verranno raggruppati. Tutti gli invii dall'ora di inizio del nightly fino all'ora di inizio del nightly successivo saranno inclusi nello stesso \"giorno\"."

#: ../../source/chapter/CDash.rst:228
msgid ""
"The next group of settings control where to submit the testing results. "
"This is the location of the CDash server."
msgstr "Il prossimo gruppo di impostazioni controlla dove inviare i risultati del test. Questa è la posizione del server CDash."

#: ../../source/chapter/CDash.rst:239
msgid ""
"The :variable:`CTEST_DROP_SITE` specifies the location of the CDash "
"server. Build and test results generated by CDash clients are sent to "
"this location. The :variable:`CTEST_DROP_LOCATION` is the directory or "
"the HTTP URL on the server where CDash clients leave their build and test"
" reports. The :variable:`CTEST_DROP_SITE_CDASH` specifies that the "
"current server is CDash, which prevents CTest from trying to \"trigger\" "
"the submission (this is still done if this variable is not set to allow "
"for backwards compatibility with Dart and Dart 2)."
msgstr ":variable:`CTEST_DROP_SITE` specifica la posizione del server CDash. I risultati di build e test generati dai client CDash vengono inviati a questa posizione. :variable:`CTEST_DROP_LOCATION` è la directory o l'URL HTTP sul server in cui i client CDash lasciano i report di build e test. :variable:`CTEST_DROP_SITE_CDASH` specifica che il server corrente è CDash, il che impedisce a CTest di tentare di \"trigger\"-are l'invio (ciò viene comunque fatto se questa variabile non è impostata per consentire la retrocompatibilità con Dart e Dart 2)."

#: ../../source/chapter/CDash.rst:248
msgid ""
"Currently CDash supports only the HTTP drop submission method; however "
"CTest supports other submission types. The :variable:`CTEST_DROP_METHOD` "
"specifies the method used to submit testing results. The most common "
"setting for this will be HTTP which uses the Hyper Text Transfer Protocol"
" (HTTP) to transfer the test data to the server. Other drop methods are "
"supported for special cases such as FTP and SCP. In the example below, "
"clients that are submitting their results using the HTTP protocol use a "
"web address as their drop site. If the submission is via FTP, this "
"location is relative to where the :variable:`CTEST_DROP_SITE_USER` will "
"log in by default. The :variable:`CTEST_DROP_SITE_USER` specifies the FTP"
" username the client will use on the server. For FTP submissions this "
"user will typically be \"anonymous\". However, any username that can "
"communicate with the server can be used. For FTP servers that require a "
"password, it can be stored in the :variable:`CTEST_DROP_SITE_PASSWORD` "
"variable. The ``CTEST_DROP_SITE_MODE`` (not used in this example) is an "
"optional variable that you can use to specify the FTP mode. Most FTP "
"servers will handle the default passive mode, but you can set the mode "
"explicitly to active if your server does not."
msgstr "Attualmente CDash supporta solo il metodo di invio drop HTTP; tuttavia CTest supporta altri tipi di invio. :variable:`CTEST_DROP_METHOD` specifica il metodo utilizzato per inviare i risultati dei test. L'impostazione più comune per questo sarà HTTP che utilizza il protocollo HTTP (Hyper Text Transfer Protocol) per trasferire i dati del test al server. Altri metodi di rilascio sono supportati per casi speciali come FTP e SCP. Nell'esempio seguente, i client che inviano i propri risultati utilizzando il protocollo HTTP utilizzano un indirizzo Web come sito di destinazione. Se l'invio avviene tramite FTP, questa posizione è relativa a dove :variable:`CTEST_DROP_SITE_USER` effettuerà l'accesso per default. :variable:`CTEST_DROP_SITE_USER` specifica il nome utente FTP che il client utilizzerà sul server. Per gli invii FTP questo utente sarà tipicamente \"anonymous\". Tuttavia, è possibile utilizzare qualsiasi nome utente in grado di comunicare con il server. Per i server FTP che richiedono una password, può essere memorizzata nella variabile :variable:`CTEST_DROP_SITE_PASSWORD`. ``CTEST_DROP_SITE_MODE`` (non utilizzata in questo esempio) è una variabile facoltativa utilizzabile per specificare la modalità FTP. La maggior parte dei server FTP gestirà la modalità passiva di default, ma si può impostare esplicitamente la modalità su attiva se il server non lo fa."

#: ../../source/chapter/CDash.rst:271
msgid ""
"CTest can also be run from behind a firewall. If the firewall allows FTP "
"or HTTP traffic, then no additional settings are required. If the "
"firewall requires an FTP/HTTP proxy or uses a SOCKS4 or SOCKS5 type "
"proxy, some environment variables need to be set. HTTP_PROXY and "
"FTP_PROXY specify the servers that service HTTP and FTP proxy requests. "
"HTTP_PROXY_PORT and FTP_PROXY_PORT specify the port on which the HTTP and"
" FTP proxies reside. HTTP_PROXY_TYPE specifies the type of the HTTP proxy"
" used. The three different types of proxies supported are the default, "
"which includes a generic HTTP/FTP proxy, \"SOCKS4\", and \"SOCKS5\", "
"which specify SOCKS4 and SOCKS5 compatible proxies."
msgstr "CTest può anche essere eseguito da dietro un firewall. Se il firewall consente il traffico FTP o HTTP, non sono necessarie impostazioni aggiuntive. Se il firewall richiede un proxy FTP/HTTP o utilizza un proxy di tipo SOCKS4 o SOCKS5, è necessario impostare alcune variabili di ambiente. HTTP_PROXY e FTP_PROXY specificano i server che gestiscono le richieste di proxy HTTP e FTP. HTTP_PROXY_PORT e FTP_PROXY_PORT specificano la porta su cui risiedono i proxy HTTP e FTP. HTTP_PROXY_TYPE specifica il tipo di proxy HTTP utilizzato. I tre diversi tipi di proxy supportati sono quelli di default, che includono un proxy HTTP/FTP generico, \"SOCKS4\" e \"SOCKS5\", che specificano i proxy compatibili con SOCKS4 e SOCKS5."

#: ../../source/chapter/CDash.rst:287
msgid "Filtering Errors and Warnings"
msgstr "Filtraggio di Errori e Warning"

#: ../../source/chapter/CDash.rst:289
msgid ""
"By default, CTest has a list of regular expressions that it matches for "
"finding the errors and warnings from the output of the build process. You"
" can override these settings in your ``CTestCustom.ctest`` files using "
"several variables as shown below."
msgstr "Per default, CTest dispone di un elenco di espressioni regolari a cui corrisponde per trovare gli errori e gli avvisi dall'output del processo di build. Queste impostazioni si possono sovrascrivere nei file ``CTestCustom.ctest`` utilizzando diverse variabili come mostrato di seguito."

#: ../../source/chapter/CDash.rst:318
msgid ""
"Another useful feature of the CTestCustom files is that you can use it to"
" limit the tests that are run for memory checking dashboards. Memory "
"checking using purify or valgrind is a CPU intensive process that can "
"take twenty hours for a dashboard that normally takes one hour. To help "
"alleviate this problem, CTest allows you to exclude some of the tests "
"from the memory checking process as follows:"
msgstr "Un'altra caratteristica utile dei file CTestCustom è che è possibile utilizzarlo per limitare i test eseguiti per le dashboard di controllo della memoria. Il controllo della memoria con purify o valgrind è un processo ad alta intensità di CPU che può richiedere venti ore per una dashboard che normalmente richiede un'ora. Per alleviare questo problema, CTest consente di escludere alcuni dei test dal processo di controllo della memoria come segue:"

#: ../../source/chapter/CDash.rst:338
msgid ""
"The format for excluding tests is simply a list of test names as "
"specified when the tests were added in your CMakeLists file with "
":command:`add_test`."
msgstr "Il formato per escludere i test è semplicemente un elenco di nomi di test come specificato quando i test sono stati aggiunti nel file CMakeLists con :command:`add_test`."

#: ../../source/chapter/CDash.rst:342
msgid ""
"In addition to the demonstrated settings, such as "
"``CTEST_CUSTOM_WARNING_MATCH``, ``CTEST_CUSTOM_WARNING_EXCEPTION``, and "
"``CTEST_CUSTOM_MEMCHECK_IGNORE``, CTest also checks several other "
"variables."
msgstr "Oltre alle impostazioni mostrate, come ``CTEST_CUSTOM_WARNING_MATCH``, ``CTEST_CUSTOM_WARNING_EXCEPTION`` e ``CTEST_CUSTOM_MEMCHECK_IGNORE``, CTest controlla anche diverse altre variabili."

#: ../../source/chapter/CDash.rst:349
msgid "**CTEST_CUSTOM_ERROR_MATCH**"
msgstr "**CTEST_CUSTOM_ERROR_MATCH**"

#: ../../source/chapter/CDash.rst:348
msgid "Additional regular expressions to consider a build line as an error line"
msgstr "Espressioni regolari aggiuntive per considerare una riga di build come una riga di errore"

#: ../../source/chapter/CDash.rst:353
msgid "**CTEST_CUSTOM_ERROR_EXCEPTION**"
msgstr "**CTEST_CUSTOM_ERROR_EXCEPTION**"

#: ../../source/chapter/CDash.rst:352
msgid ""
"Additional regular expressions to consider a build line not as an error "
"line"
msgstr "Espressioni regolari aggiuntive per considerare una riga di build come una riga di errore"

#: ../../source/chapter/CDash.rst:357
msgid "**CTEST_CUSTOM_WARNING_MATCH**"
msgstr "**CTEST_CUSTOM_WARNING_MATCH**"

#: ../../source/chapter/CDash.rst:356
msgid "Additional regular expressions to consider a build line as a warning line"
msgstr "Espressioni regolari aggiuntive per considerare una riga di build come una riga di warning"

#: ../../source/chapter/CDash.rst:361
msgid "**CTEST_CUSTOM_WARNING_EXCEPTION**"
msgstr "**CTEST_CUSTOM_WARNING_EXCEPTION**"

#: ../../source/chapter/CDash.rst:360
msgid ""
"Additional regular expressions to consider a build line not as a warning "
"line"
msgstr "Espressioni regolari aggiuntive per considerare una riga di build come una riga di warning"

#: ../../source/chapter/CDash.rst:365
msgid "**CTEST_CUSTOM_MAXIMUM_NUMBER_OF_ERRORS**"
msgstr "**CTEST_CUSTOM_MAXIMUM_NUMBER_OF_ERRORS**"

#: ../../source/chapter/CDash.rst:364
msgid "Maximum number of errors before CTest stops reporting errors (default 50)"
msgstr "Numero massimo di errori prima che CTest smetta di segnalare gli errori (default 50)"

#: ../../source/chapter/CDash.rst:369
msgid "**CTEST_CUSTOM_MAXIMUM_NUMBER_OF_WARNINGS**"
msgstr "**CTEST_CUSTOM_MAXIMUM_NUMBER_OF_WARNINGS**"

#: ../../source/chapter/CDash.rst:368
msgid ""
"Maximum number of warnings before CTest stops reporting warnings (default"
" 50)"
msgstr "Numero massimo di warning prima che CTest smetta di segnalarli (default 50)"

#: ../../source/chapter/CDash.rst:373
msgid "**CTEST_CUSTOM_COVERAGE_EXCLUDE**"
msgstr "**CTEST_CUSTOM_COVERAGE_EXCLUDE**"

#: ../../source/chapter/CDash.rst:372
msgid "Regular expressions for files to be excluded from the coverage analysis"
msgstr "Espressioni regolari per i file da escludere dall'analisi della \"coverage\""

#: ../../source/chapter/CDash.rst:376
msgid "**CTEST_CUSTOM_PRE_MEMCHECK**"
msgstr "**CTEST_CUSTOM_PRE_MEMCHECK**"

#: ../../source/chapter/CDash.rst:376
msgid "List of commands to execute before performing memory checking"
msgstr "Elenco dei comandi da eseguire prima di eseguire il controllo della memoria"

#: ../../source/chapter/CDash.rst:379
msgid "**CTEST_CUSTOM_POST_MEMCHECK**"
msgstr "**CTEST_CUSTOM_POST_MEMCHECK**"

#: ../../source/chapter/CDash.rst:379
msgid "List of commands to execute after performing memory checking"
msgstr "Elenco dei comandi da eseguire dopo aver eseguito il controllo della memoria"

#: ../../source/chapter/CDash.rst:382
msgid "**CTEST_CUSTOM_MEMCHECK_IGNORE**"
msgstr "**CTEST_CUSTOM_MEMCHECK_IGNORE**"

#: ../../source/chapter/CDash.rst:382
msgid "List of tests to exclude from the memory checking step"
msgstr "Elenco dei test da escludere dalla fase di verifica della memoria"

#: ../../source/chapter/CDash.rst:385
msgid "**CTEST_CUSTOM_PRE_TEST**"
msgstr "**CTEST_CUSTOM_PRE_TEST**"

#: ../../source/chapter/CDash.rst:385
msgid "List of commands to execute before performing testing"
msgstr "Elenco dei comandi da eseguire prima di eseguire il test"

#: ../../source/chapter/CDash.rst:388
msgid "**CTEST_CUSTOM_POST_TEST**"
msgstr "**CTEST_CUSTOM_POST_TEST**"

#: ../../source/chapter/CDash.rst:388
msgid "List of commands to execute after performing testing"
msgstr "Elenco dei comandi da eseguire dopo aver eseguito il test"

#: ../../source/chapter/CDash.rst:391
msgid "**CTEST_CUSTOM_TESTS_IGNORE**"
msgstr "**CTEST_CUSTOM_TESTS_IGNORE**"

#: ../../source/chapter/CDash.rst:391
msgid "List of tests to exclude from the testing step"
msgstr "Elenco dei test da escludere dalla fase di test"

#: ../../source/chapter/CDash.rst:394
msgid "**CTEST_CUSTOM_MAXIMUM_PASSED_TEST_OUTPUT_SIZE**"
msgstr "**CTEST_CUSTOM_MAXIMUM_PASSED_TEST_OUTPUT_SIZE**"

#: ../../source/chapter/CDash.rst:394
msgid "Maximum size of test output for the passed test (default 1k)"
msgstr "Dimensione massima dell'output del test per il test superato (default 1k)"

#: ../../source/chapter/CDash.rst:397
msgid "**CTEST_CUSTOM_MAXIMUM_FAILED_TEST_OUTPUT_SIZE**"
msgstr "**CTEST_CUSTOM_MAXIMUM_FAILED_TEST_OUTPUT_SIZE**"

#: ../../source/chapter/CDash.rst:397
msgid "Maximum size of test output for the failed test (default 300k)"
msgstr "Dimensione massima dell'output del test per il test fallito (default 300k)"

#: ../../source/chapter/CDash.rst:399
msgid ""
"Commands specified in ``CTEST_CUSTOM_PRE_TEST`` and "
"``CTEST_CUSTOM_POST_TEST``, as well as the equivalent memory checking "
"ones, are executed once per CTest run. These commands can be used, for "
"example, if all tests require some initial setup and some final cleanup "
"to be performed."
msgstr "I comandi specificati in ``CTEST_CUSTOM_PRE_TEST`` e ``CTEST_CUSTOM_POST_TEST``, oltre a quelli equivalenti per il controllo della memoria, vengono eseguiti una volta per esecuzione di CTest. Questi comandi possono essere utilizzati, ad esempio, se tutti i test richiedono l'esecuzione di una configurazione iniziale e di una pulizia finale."

#: ../../source/chapter/CDash.rst:409
msgid "Adding Notes to a Dashboard"
msgstr "Aggiungere Note a una Dashboard"

#: ../../source/chapter/CDash.rst:411
msgid ""
"CTest and CDash support adding note files to a dashboard submission. "
"These will appear on the dashboard as a clickable icon that links to the "
"text of all the files. To add notes, call CTest with the -A option "
"followed by a semicolon-separated list of filenames. The contents of "
"these files will be submitted as notes for the dashboard. For example::"
msgstr "CTest e CDash supportano l'aggiunta di file di note a un invio di dashboard. Questi appariranno sulla dashboard come un'icona cliccabile che si collega al testo di tutti i file. Per aggiungere le note, si chiama CTest con l'opzione -A seguita da un elenco di nomi di file separati da punto e virgola. Il contenuto di questi file verrà inviato come note per la dashboard. Per esempio::"

#: ../../source/chapter/CDash.rst:420
msgid ""
"Another way to submit notes with a dashboard is to copy or write the "
"notes as files into a Notes directory under the ``Testing`` directory of "
"your binary tree. Any files found there when CTest submits a dashboard "
"will also be uploaded as notes."
msgstr "Un altro modo per inviare note con una dashboard è copiare o scrivere le note come file in una directory Notes nella directory ``Testing`` dell'albero binario. Anche tutti i file trovati lì quando CTest invia una dashboard verranno caricati come note."

#: ../../source/chapter/CDash.rst:429
msgid "CTest Scripting"
msgstr "Script di CTest"

#: ../../source/chapter/CDash.rst:431
msgid ""
"This section describes how to write command-based CTest scripts that "
"allow the maintainer to have fine-grained control over the individual "
"steps of a dashboard."
msgstr "Questa sezione descrive come scrivere script CTest basati su comandi che consentono al manutentore di avere un controllo granulare sui singoli passaggi di una dashboard."

#: ../../source/chapter/CDash.rst:435
msgid ""
"The dashboard maintainer has access to individual CTest command "
"functions, such as :command:`ctest_configure` and :command:`ctest_build`."
" By running these functions individually, the user can flexibly develop "
"custom testing schemes. Here's an example of a CTest script"
msgstr "Il manutentore della dashboard ha accesso alle singole funzioni di comando CTest, come :command:`ctest_configure` e :command:`ctest_build`. Eseguendo queste funzioni individualmente, l'utente può sviluppare in modo flessibile schemi di test personalizzati. Ecco un esempio di uno script CTest"

#: ../../source/chapter/CDash.rst:477
msgid "The first block contains the variables about the submission."
msgstr "Il primo blocco contiene le variabili relative all'invio."

#: ../../source/chapter/CDash.rst:491
msgid ""
"These variables are used to identify the system once it submits the "
"results to the dashboard. ``CTEST_NOTES_FILES`` is a list of files that "
"should be submitted as the notes of the dashboard submission. This "
"variable corresponds to the -A flag of :manual:`ctest <ctest(1)>`."
msgstr "Queste variabili vengono utilizzate per identificare il sistema una volta che invia i risultati alla dashboard. ``CTEST_NOTES_FILES`` è un elenco di file che devono essere inviati come le note dell'invio della dashboard. Questa variabile corrisponde al flag -A di :manual:`ctest <ctest(1)>`."

#: ../../source/chapter/CDash.rst:497
msgid ""
"The second block describes the information that CTest functions will use "
"to perform the tasks:"
msgstr "Il secondo blocco descrive le informazioni che le funzioni CTest utilizzeranno per eseguire le attività:"

#: ../../source/chapter/CDash.rst:517
msgid ""
"The ``CTEST_UPDATE_COMMAND`` is the path to the command used to update "
"the source directory from the repository. Currently CTest supports "
"Concurrent Versions System (CVS), Subversion, Git, Mercurial, and Bazaar."
msgstr "``CTEST_UPDATE_COMMAND`` è il path del comando utilizzato per aggiornare la directory dei sorgenti dal repository. Attualmente CTest supporta Concurrent Versions System (CVS), Subversion, Git, Mercurial e Bazaar."

#: ../../source/chapter/CDash.rst:522
msgid ""
"Both the configure and build handlers support two modes. One mode is to "
"provide the full command that will be invoked during that stage. This is "
"designed to support projects that do not use CMake as their configuration"
" or build tool. In this case, you specify the full command lines to "
"configure and build your project by setting the "
":variable:`CTEST_CONFIGURE_COMMAND` and :variable:`CTEST_BUILD_COMMAND` "
"variables respectively."
msgstr "Entrambi i gestori configure e build supportano due modalità Una modalità consiste nel fornire il comando completo che verrà richiamato durante quella fase. Questo è progettato per supportare progetti che non utilizzano CMake come strumento di configurazione o build. In questo caso, si devono specificare le righe di comando complete per configurare e creare il progetto impostando rispettivamente le variabili :variable:`CTEST_CONFIGURE_COMMAND` e :variable:`CTEST_BUILD_COMMAND`."

#: ../../source/chapter/CDash.rst:530
msgid ""
"For the build step you should also set the variables "
"``CTEST_PROJECT_NAME`` and ``CTEST_BUILD_CONFIGURATION``, to specify how "
"to build the project. In this case ``CTEST_PROJECT_NAME`` will match the "
"top level CMakeLists file's :command:`project` command. The "
"``CTEST_BUILD_CONFIGURATION`` should be one of Release, Debug, "
"MinSizeRel, or RelWithDebInfo. Additionally, ``CTEST_BUILD_FLAGS`` can be"
" provided as a hint to the build command. An example of testing for a "
"CMake based project would be:"
msgstr "Per la fase di build si devono anche impostare le variabili ``CTEST_PROJECT_NAME`` e ``CTEST_BUILD_CONFIGURATION``, per specificare come eseguire la build del progetto. In questo caso ``CTEST_PROJECT_NAME`` corrisponderà al comando :command:`project` del file CMakeLists di primo livello. ``CTEST_BUILD_CONFIGURATION`` deve essere uno tra Release, Debug, MinSizeRel o RelWithDebInfo. Inoltre, ``CTEST_BUILD_FLAGS`` può essere fornito come suggerimento per il comando build. Un esempio di test per un progetto basato su CMake potrebbe essere:"

#: ../../source/chapter/CDash.rst:543
msgid "The final block performs the actual testing and submission:"
msgstr "Il blocco finale esegue il test e l'invio effettivi:"

#: ../../source/chapter/CDash.rst:559
msgid ""
"The :command:`ctest_empty_binary_directory` command empties the directory"
" and all subdirectories. Please note that this command has a safety "
"measure built in, which is that it will only remove the directory if "
"there is a CMakeCache.txt file in the top level directory. This was "
"intended to prevent CTest from mistakenly removing a non-build directory."
msgstr "Il comando :command:`ctest_empty_binary_directory` svuota la directory e tutte le sottodirectory. Si noti che questo comando ha una misura di sicurezza incorporata, ovvero rimuoverà la directory solo se è presente un file CMakeCache.txt nella directory di livello superiore. Questo aveva lo scopo di impedire a CTest di rimuovere erroneamente una directory non di build."

#: ../../source/chapter/CDash.rst:565
msgid ""
"The rest of the block contains the calls to the actual CTest functions. "
"Each of them corresponds to a CTest -D option. For example, instead of::"
msgstr "Il resto del blocco contiene le chiamate alle effettive funzioni CTest. Ciascuno di essi corrisponde a un'opzione CTest -D. Ad esempio, invece di::"

#: ../../source/chapter/CDash.rst:571
msgid "the script would contain::"
msgstr "lo script conterrebbe::"

#: ../../source/chapter/CDash.rst:576
msgid ""
"Each step yields a return value, which indicates if the step was "
"successful. For example, the return value of the Update stage can be used"
" in a continuous dashboard to determine if the rest of the dashboard "
"should be run."
msgstr "Ogni passaggio restituisce un valore di ritorno, che indica se il passaggio ha avuto esito positivo. Ad esempio, il valore restituito della fase di aggiornamento può essere utilizzato in una dashboard continua per determinare se il resto della dashboard deve essere eseguito."

#: ../../source/chapter/CDash.rst:581
msgid ""
"Let us examine a more advanced CTest script. This script drives testing "
"of an application called Slicer. Slicer uses CMake internally, but it "
"drives the build process through a series of Tcl scripts. One of the "
"problems of this approach is that it does not support out-of-source "
"builds. Also, on Windows certain modules come pre-built, so they have to "
"be copied to the build directory. To test a project like that, we would "
"use a script like this:"
msgstr "Esaminiamo uno script CTest più avanzato. Questo script guida il test di un'applicazione chiamata Slicer. Slicer utilizza CMake internamente, ma guida il processo di build attraverso una serie di script Tcl. Uno dei problemi di questo approccio è che non supporta build \"out-of-source\". Inoltre, su Windows alcuni moduli sono precompilati, quindi devono essere copiati nella directory di build. Per testare un progetto del genere, useremmo uno script come questo:"

#: ../../source/chapter/CDash.rst:660
msgid ""
"With extended CTest scripting we have full control over the flow, so we "
"can perform arbitrary commands at any point. For example, after "
"performing an update of the project, the script copies the source tree "
"into the build directory. This allows it to do an \"out-of-source\" "
"build."
msgstr "Con lo scripting CTest esteso abbiamo il pieno controllo del flusso, quindi possiamo eseguire comandi arbitrari in qualsiasi momento. Ad esempio, dopo aver eseguito un aggiornamento del progetto, lo script copia l'albero dei sorgenti nella directory di build. Ciò gli consente di eseguire una build \"out-of-source\"."

#: ../../source/chapter/CDash.rst:668
msgid "Project Roles: CDash supports three role levels for users"
msgstr "Ruoli del progetto: CDash supporta tre livelli di ruolo per gli utenti"

#: ../../source/chapter/CDash.rst:670
msgid ""
"Normal users are regular users with read and/or write access to the "
"project's code repository."
msgstr "Gli utenti normali sono utenti regolari con accesso in lettura e/o scrittura al repository del codice del progetto."

#: ../../source/chapter/CDash.rst:672
msgid "Site maintainers are responsible for periodic submissions to CDash."
msgstr "I manutentori del sito sono responsabili degli invii periodici a CDash."

#: ../../source/chapter/CDash.rst:673
msgid ""
"Project administrators have reserved privileges to administer the project"
" in CDash."
msgstr "Gli amministratori del progetto hanno privilegi riservati per amministrare il progetto in CDash."

#: ../../source/chapter/CDash.rst:676
msgid ""
"The first two levels can be defined by the users themselves. Project "
"administrator access must be granted by another administrator of the "
"project, or a CDash server administrator."
msgstr "I primi due livelli possono essere definiti dagli utenti stessi. L'accesso come amministratore del progetto deve essere concesso da un altro amministratore del progetto o da un amministratore del server CDash."

#: ../../source/chapter/CDash.rst:681
msgid "Submission backup"
msgstr "Backup degli Invii"

#: ../../source/chapter/CDash.rst:683
msgid ""
"CDash backups all the incoming XML submissions and places them in the "
"``backup`` directory by default. The default timeframe is 48 hours. The "
"timeframe can be changed in the ``config.local.php`` as follows::"
msgstr "CDash esegue il backup di tutti gli invii XML in arrivo e li inserisce nella directory ``backup`` per default. L'intervallo di tempo di default è di 48 ore. L'intervallo di tempo può essere modificato in ``config.local.php`` come segue::"

#: ../../source/chapter/CDash.rst:690
msgid ""
"If projects are private it is recommended to set the backup directory "
"outside of the apache root directory to make sure that nobody can access "
"the XML files, or to add the following lines to the .htaccess in the "
"backup directory::"
msgstr "Se i progetti sono privati, si consiglia di impostare la directory di backup al di fuori di quella principale di apache per assicurarsi che nessuno possa accedere ai file XML o di aggiungere le seguenti righe al file .htaccess nella directory di backup::"

#: ../../source/chapter/CDash.rst:700
msgid ""
"Note that the backup directory is emptied only when a new submission "
"arrives. If necessary, CDash can also import builds from the backup "
"directory."
msgstr "Si noti che la directory di backup viene svuotata solo quando arriva un nuovo invio. Se necessario, CDash può anche importare build dalla directory di backup."

#: ../../source/chapter/CDash.rst:705
msgid "Build Groups"
msgstr "Gruppi di Build"

#: ../../source/chapter/CDash.rst:707
msgid ""
"Builds can be organized by groups. In CDash, three groups are defined "
"automatically and cannot be removed: ``Nightly``, ``Continuous`` and "
"``Experimental``. These groups are the same as the ones imposed by CTest."
" Each group has an associated description that is displayed when clicking"
" on the name of the group on the main dashboard."
msgstr "Le build possono essere organizzate per gruppi. In CDash, tre gruppi vengono definiti automaticamente e non possono essere rimossi: ``Nightly``, ``Continuous`` e ``Experimental``. Questi gruppi sono gli stessi imposti da CTest. Ogni gruppo ha una descrizione associata che viene visualizzata quando si fa clic sul nome del gruppo nella dashboard principale."

#: ../../source/chapter/CDash.rst:713
msgid ""
"By default, a build belongs to the group associated with the build type "
"defined by CTest, i.e. a nightly build will go in the Nightly section. "
"CDash matches a build by its name, site, and build type. For instance, a "
"nightly build named \"Linux-gcc-4.3\" from the site \"midworld.kitware "
"will be moved to the Nightly section unless a rule on \"Linux-"
"gcc-4.3\"-\"midworld.kitware\"-\"Nightly\" is defined. There are two ways"
" to move a build into a given group by defining a rule: Global Move and "
"Single Move."
msgstr "Per default, una build appartiene al gruppo associato al tipo di build definito da CTest, ovvero una build notturna andrà nella sezione Nightly. CDash abbina una build in base al nome, al sito e al tipo di build. Ad esempio, una build notturna denominata \"Linux-gcc-4.3\" dal sito \"midworld.kitware\" verrà spostata nella sezione Nightly a meno che non sia presente una regola su \"Linux-gcc-4.3\"-\"midworld.kitware\"-\"Nightly\". Esistono due modi per spostare una build in un determinato gruppo definendo una regola: Global Move e Single Move."

#: ../../source/chapter/CDash.rst:723
msgid "Single move allows modifying only a particular build"
msgstr "La single move consente di modificare solo una particolare build"

#: ../../source/chapter/CDash.rst:725
msgid ""
"If logged in as an administrator of the project, a small folder icon is "
"displayed next to each build on the main dashboard page. Clicking on the "
"icon shows some options for each build. In particular, project "
"administrators can mark a build as expected, move a build to a specific "
"group, or delete a bogus build."
msgstr "Se si è effettuato l'accesso come amministratore del progetto, viene visualizzata una piccola icona di cartella accanto a ciascuna build nella pagina principale della dashboard. Facendo clic sull'icona vengono visualizzate alcune opzioni per ciascuna build. In particolare, gli amministratori del progetto possono contrassegnare una build come prevista, spostare una build in un gruppo specifico o eliminare una build bacata."

#: ../../source/chapter/CDash.rst:734
msgid ""
"Expected builds: Project administrators can mark certain builds as "
"expected. That means builds are expected to submit daily. This allows you"
" to quickly check if a build has not been submitting on today's "
"dashboard, or to quickly assess how long the build has been missing by "
"clicking on the info icon on the main dashboard."
msgstr "Build previste [expected]: Gli amministratori del progetto possono contrassegnare determinate build come previste. Ciò significa che le build devono essere inviate quotidianamente. Questo consente di verificare rapidamente se una build non è stata inviata nella dashboard odierna o di valutare rapidamente da quanto tempo manca la build facendo clic sull'icona delle informazioni sulla dashboard principale."

#: ../../source/chapter/CDash.rst:740
msgid ""
"If an expected build was not submitted the previous day and the option "
"\"Email Build Missing\" is checked for the project, an email will be sent"
" to the site maintainer and project administrator to alert them (see the "
"Sites section for more information)."
msgstr "Se una build \"expected\" non è stata inviata il giorno precedente e l'opzione \"Email Build Missing\" è selezionata per il progetto, verrà inviata un'e-mail al manutentore del sito e all'amministratore del progetto per avvisarli (vedere la sezione Siti per maggiori informazioni)."

#: ../../source/chapter/CDash.rst:749
msgid "Email"
msgstr "Email"

#: ../../source/chapter/CDash.rst:751
msgid ""
"CDash sends email to developers and project administrators when a failure"
" occurs for a given build. The configuration of the email feature is "
"located in three places: the ``config.local.php`` file, the project "
"administration section, and the project's groups section."
msgstr "CDash invia e-mail agli sviluppatori e agli amministratori di progetto quando si verifica un errore per una determinata build. La configurazione della funzione email si trova in tre posizioni: il file ``config.local.php``, la sezione di amministrazione del progetto e la sezione dei gruppi del progetto."

#: ../../source/chapter/CDash.rst:756
msgid ""
"In the ``config.local.php``, two variables are defined to specify the "
"email address from which email is sent and the reply address. Note that "
"the SMTP server cannot be defined in the current version of CDash, it is "
"assumed that a local email server is running on the machine."
msgstr "In ``config.local.php``, sono definite due variabili per specificare l'indirizzo e-mail da cui viene inviata l'e-mail e l'indirizzo di risposta. Si noti che il server SMTP non può essere definito nella versione corrente di CDash, si presume che sulla macchina sia in esecuzione un server di posta locale."

#: ../../source/chapter/CDash.rst:767
msgid ""
"In the email configuration section of the project, several parameters can"
" be tuned to control the email feature."
msgstr "Nella sezione di configurazione della posta elettronica del progetto, è possibile regolare diversi parametri per controllare la funzione di posta elettronica."

#: ../../source/chapter/CDash.rst:770
msgid ""
"In the \"build groups\" administration section of a project, an "
"administrator can decide if emails are sent to a specific group, or if "
"only a summary email should be sent. The summary email is sent for a "
"given group when at least one build is failing on the current day."
msgstr "Nella sezione di amministrazione \"build groups\" di un progetto, un amministratore può decidere se inviare le email a un gruppo specifico o se inviare solo un'email di riepilogo. L'e-mail di riepilogo viene inviata per un determinato gruppo quando almeno una build non riesce nel giorno corrente."

#: ../../source/chapter/CDash.rst:779
msgid "Sites"
msgstr "Siti"

#: ../../source/chapter/CDash.rst:781
msgid ""
"CDash refers to a site as an individual machine submitting at least one "
"build to a given project. A site might submit multiple builds (e.g. "
"nightly and continuous) to multiple projects stored in CDash."
msgstr "CDash si riferisce a un sito come a una singola macchina che invia almeno una build a un determinato progetto. Un sito potrebbe inviare più build (ad esempio notturne e continue) a più progetti archiviati in CDash."

#: ../../source/chapter/CDash.rst:785
msgid ""
"In order to see the site description, click on the name of the site from "
"the main dashboard page for a project. The description of a site includes"
" information regarding the processor type and speed, as well as the "
"amount of memory available on the given machine. The description of a "
"site is automatically sent by CTest, however in some cases it might be "
"required to manually edit it. Moreover, if the machine is upgraded, i.e. "
"the memory is upgraded; CDash keeps track of the history of the "
"description, allowing users to compare performance before and after the "
"upgrade."
msgstr "Per visualizzare la descrizione del sito, fare clic sul nome del sito dalla pagina principale della dashboard per un progetto. La descrizione di un sito include informazioni riguardanti il tipo e la velocità del processore, nonché la quantità di memoria disponibile sulla macchina in questione. La descrizione di un sito viene inviata automaticamente da CTest, tuttavia in alcuni casi potrebbe essere necessario modificarla manualmente. Inoltre, se la macchina viene aggiornata, cioè la memoria viene aggiornata; CDash tiene traccia della cronologia della descrizione, consentendo agli utenti di confrontare le prestazioni prima e dopo l'aggiornamento."

#: ../../source/chapter/CDash.rst:795
msgid ""
"Sites usually belong to one maintainer, responsible for the submissions "
"to CDash. It is important for site maintainers to be warned when a site "
"is not submitting as it could be related to a configuration issue."
msgstr "I siti di solito appartengono a un manutentore, responsabile degli invii a CDash. È importante che i manutentori del sito vengano avvisati quando un sito non viene inviato poiché potrebbe essere correlato a un problema di configurazione."

#: ../../source/chapter/CDash.rst:800
msgid ""
"Once a site is claimed, its maintainer will receive emails if the client "
"machine does not submit for an unknown reason, assuming that the site is "
"expected to submit nightly. Furthermore, the site will appear in the \"My"
" Sites\" section of the maintainer's profile, facilitating a quick check "
"of the site's status."
msgstr "Una volta rivendicato un sito, il suo manutentore riceverà una e-mail se il computer client non invia per un motivo sconosciuto, supponendo che il sito debba essere inviato ogni notte. Inoltre, il sito comparirà nella sezione \"My Sites\" del profilo del manutentore, facilitando una rapida verifica dello stato del sito."

#: ../../source/chapter/CDash.rst:806
msgid ""
"Another feature of the site page is the pie chart showing the load of the"
" machine. Assuming that a site submits to multiple projects, it is "
"usually useful to know if the machine has room for other submissions to "
"CDash. The pie chart gives an overview of the machine submission time for"
" each project."
msgstr "Un'altra caratteristica della pagina del sito è il grafico a torta che mostra il carico della macchina. Supponendo che un sito invii a più progetti, di solito è utile sapere se la macchina ha spazio per altri invii a CDash. Il grafico a torta fornisce una panoramica del tempo di invio della macchina per ciascun progetto."

#: ../../source/chapter/CDash.rst:813
msgid "Graphs"
msgstr "Grafici"

#: ../../source/chapter/CDash.rst:815
msgid ""
"CDash currently plots three types of graphs. The graphs are generated "
"dynamically from the database records, and are interactive."
msgstr "CDash disegna attualmente tre tipi di grafici. I grafici sono generati dinamicamente dai record del database e sono interattivi."

#: ../../source/chapter/CDash.rst:818
msgid ""
"The build time graph displays the time required to build a project over "
"time."
msgstr "Il grafico del tempo di build mostra il tempo necessario per buildare un progetto nel tempo."

#: ../../source/chapter/CDash.rst:821
msgid ""
"The test time graphs display the time to run a specific test as well as "
"its status (passed/failed) over time."
msgstr "I grafici del tempo del test mostrano il tempo necessario per eseguire un test specifico e il suo stato (superato/fallito) nel tempo."

#: ../../source/chapter/CDash.rst:825
msgid "Adding Notes to a Build"
msgstr "Aggiunta di note a una build"

#: ../../source/chapter/CDash.rst:827
msgid ""
"In some cases, it is useful to inform other developers that someone is "
"currently looking at the errors for a build."
msgstr "In alcuni casi, è utile informare altri sviluppatori che qualcuno sta esaminando gli errori di una build."

#: ../../source/chapter/CDash.rst:834
msgid "Logging"
msgstr "Logging"

#: ../../source/chapter/CDash.rst:836
msgid ""
"CDash supports an internal logging mechanism using the error_log() PHP "
"function. Any critical SQL errors are logged. By default, the CDash log "
"file is located in the backup directory under the name ``cdash.log``. The"
" location of the log file can be modified by changing the variable in the"
" ``config.local.php`` configuration file."
msgstr "CDash supporta un meccanismo di log interno che usa la funzione PHP error_log(). Tutti gli errori SQL critici vengono loggati. Per default, il file di log di CDash si trova nella directory di backup con il nome ``cdash.log``. La posizione del file di log può essere modificata cambiando la variabile nel file di configurazione ``config.local.php``."

#: ../../source/chapter/CDash.rst:846
msgid ""
"The log file can be accessed directly from CDash if the log file is in "
"the standard location."
msgstr "È possibile accedere al file di log direttamente da CDash se il file si trova nella posizione standard."

#: ../../source/chapter/CDash.rst:849
msgid ""
"A log rotation mechanism which allows users to cap the current log file "
"to a certain size is available."
msgstr "È disponibile un meccanismo di rotazione del log che consente agli utenti di limitare il file di log corrente a una determinata dimensione."

#: ../../source/chapter/CDash.rst:855
msgid "Test Timing"
msgstr "Test dei Tempi"

#: ../../source/chapter/CDash.rst:857
msgid ""
"CDash supports checks on the duration of tests. CDash keeps the current "
"weighted average of the mean and standard deviation for the time each "
"test takes to run in the database. In order to keep the computation as "
"efficient as possible the following formula is used, which only involves "
"the previous build."
msgstr "CDash supporta i controlli sulla durata dei test. CDash mantiene, nel database, la media ponderata corrente della media e della deviazione standard per il tempo impiegato da ciascun test per essere eseguito. Per mantenere il calcolo il più efficiente possibile viene utilizzata la seguente formula, che coinvolge solo la build precedente."

#: ../../source/chapter/CDash.rst:872
msgid "A test is defined as having failed timing based on the following logic::"
msgstr "Un test è definito come temporizzazione fallita in base alla seguente logica::"

#: ../../source/chapter/CDash.rst:882
msgid "Mobile Support"
msgstr "Supporto Mobile"

#: ../../source/chapter/CDash.rst:884
msgid ""
"Since CDash is written using template layers via XSLT, developing new "
"layouts is as simple as adding new rendering templates. As a "
"demonstration, an iPhone web template is provided with the current "
"version of CDash."
msgstr "Dal momento che CDash è scritto utilizzando layer di template tramite XSLT, sviluppare nuovi layout è semplice come aggiungere nuovi template di rendering. A titolo dimostrativo, viene fornito un template Web per iPhone con la versione corrente di CDash."

#: ../../source/chapter/CDash.rst:893
msgid ""
"The main page shows a list of the public projects hosted on the server. "
"Clicking on the name of a project loads its current dashboard. In the "
"same manner, clicking on a given build displays more detailed information"
" about that build. As of this writing, the ability to login and to access"
" private sections of CDash are not supported with this layout."
msgstr "La pagina principale mostra un elenco dei progetti pubblici ospitati sul server. Facendo clic sul nome di un progetto viene caricata la sua dashboard corrente. Allo stesso modo, clickando su una determinata build vengono visualizzate informazioni più dettagliate su di essa. Al momento della stesura di questo documento, la possibilità di effettuare il login e di accedere alle sezioni private di CDash non è supportata con questo layout."

#: ../../source/chapter/CDash.rst:904
msgid "Backing up CDash"
msgstr "Backup di CDash"

#: ../../source/chapter/CDash.rst:906
msgid ""
"All of the data (except the logs) used by CDash is stored in its "
"database. It is important to backup the database regularly, especially so"
" before performing a CDash upgrade. There are a couple of ways to backup "
"a MySQL database. The easiest is to use the `mysqldump "
"<http://dev.mysql.com/doc/refman/5.1/en/mysqldump.html>`__ command::"
msgstr "Tutti i dati (tranne i log) utilizzati da CDash sono archiviati nel suo database. È importante eseguire regolarmente il backup del database, soprattutto prima di eseguire un aggiornamento di CDash. Ci sono un paio di modi per eseguire il backup di un database MySQL. Il più semplice è utilizzare il comando `mysqldump <http://dev.mysql.com/doc/refman/5.1/en/mysqldump.html>`__::"

#: ../../source/chapter/CDash.rst:914
msgid ""
"If you are using MyISAM tables exclusively, you can copy the CDash "
"directory in your MySQL data directory. Note that you need to shutdown "
"MySQL before doing the copy so that no file could be changed during the "
"copy. Similarly to MySQL, PostGreSQL has a pg_dump utility::"
msgstr "Se si usano esclusivamente tabelle MyISAM, si può copiare la directory CDash nella directory dei dati MySQL. Si noti che è necessario effettuare lo shutdown di MySQL prima di eseguire la copia in modo che nessun file possa essere modificato durante la copia. Analogamente a MySQL, PostGreSQL ha un'utilità pg_dump::"

#: ../../source/chapter/CDash.rst:925
msgid "Upgrading CDash"
msgstr "Aggiornamento di CDash"

#: ../../source/chapter/CDash.rst:927
msgid ""
"When a new version of CDash is released or if you decide to update from "
"the repository, CDash will warn you on the front page if the current "
"database needs to be upgraded. When upgrading to a new release version "
"the following steps should be taken:"
msgstr "Quando viene rilasciata una nuova versione di CDash o si decide di aggiornare dal repository, CDash avviserà in prima pagina se il database corrente deve essere aggiornato. Quando si esegue l'aggiornamento a una nuova versione di rilascio, è necessario eseguire i seguenti passaggi:"

#: ../../source/chapter/CDash.rst:932
msgid "Backup your SQL database (see previous section)."
msgstr "Eseguire il backup del database SQL (vedere la sezione precedente)."

#: ../../source/chapter/CDash.rst:934
msgid "Backup your ``config.local.php`` (or ``config.php``) configuration files."
msgstr "Eseguire il backup dei file di configurazione ``config.local.php`` (o ``config.php``)."

#: ../../source/chapter/CDash.rst:937
msgid ""
"Replace your current cdash directory with the latest version and copy the"
" ``config.local.php`` in the cdash directory."
msgstr "Sostituisci l'attuale directory cdash con l'ultima versione e copiare ``config.local.php`` nella directory di cdash."

#: ../../source/chapter/CDash.rst:940
msgid "Navigate your browser to your CDash page. (e.g. http://localhost/CDash)."
msgstr "Naviga nel browser fino alla pagina CDash. (ad esempio http://localhost/CDash)."

#: ../../source/chapter/CDash.rst:943
msgid ""
"Note the version number on the main page, it should match the version "
"that you are upgrading to."
msgstr "Annotare il numero di versione sulla pagina principale, dovrebbe corrispondere a quella a cui si sta effettuando l'aggiornamento."

#: ../../source/chapter/CDash.rst:946
msgid ""
"The following message may appear: \"The current database schema doesn't "
"match the version of CDash you are running, upgrade your database "
"structure in the Administration panel of CDash.\" This is a helpful "
"reminder to perform the following steps."
msgstr "Potrebbe apparire il seguente messaggio: \"The current database schema doesn't match the version of CDash you are running, upgrade your database structure in the Administration panel of CDash\". Questo è un utile promemoria per eseguire i seguenti passaggi."

#: ../../source/chapter/CDash.rst:951 ../../source/chapter/CDash.rst:989
#: ../../source/chapter/CDash.rst:1010
msgid "Login to CDash as administrator."
msgstr "Accedere a CDash come amministratore."

#: ../../source/chapter/CDash.rst:953
msgid "In the 'Administration' section, click on '[CDash Maintenance]'."
msgstr "Nella sezione 'Administration', clickare su '[CDash Maintenance]'."

#: ../../source/chapter/CDash.rst:955
msgid ""
"Click on 'Upgrade CDash': this process might take some time depending on "
"the size of your database (do not close your browser)."
msgstr "Clickare su 'Upgrade CDash': questo processo potrebbe richiedere del tempo a seconda delle dimensioni del database (non chiudere il browser)."

#: ../../source/chapter/CDash.rst:958
msgid "Progress messages may appear while CDash performs the upgrade."
msgstr "I messaggi di avanzamento possono essere visualizzati mentre CDash esegue l'aggiornamento."

#: ../../source/chapter/CDash.rst:959
msgid ""
"If the upgrade process takes too long you can check in the "
"``backup/cdash.log`` file to see where the process is taking a long time "
"and/or failing."
msgstr "Se il processo di aggiornamento richiede troppo tempo, si può controllare nel file ``backup/cdash.log`` per vedere dove il processo impiega molto tempo e/o fallisce."

#: ../../source/chapter/CDash.rst:962
msgid ""
"It has been reported that on some systems the spinning icon never turns "
"into a check mark. Please check the ``cdash.log`` for the \"Upgrade "
"done.\" string if you feel that the upgrade is taking too long."
msgstr "È stato segnalato che su alcuni sistemi l'icona rotante non si trasforma mai in un segno di spunta. Controllare ``cdash.log`` per la stringa \"Upgrade done.\" se si ritiene che l'aggiornamento richieda troppo tempo."

#: ../../source/chapter/CDash.rst:966
msgid "On a 50GB database the upgrade might take up to 2 hours."
msgstr "Su un database da 50 GB l'aggiornamento potrebbe richiedere fino a 2 ore."

#: ../../source/chapter/CDash.rst:968
msgid ""
"Some web browsers might have issues when upgrading (with some javascript "
"variables not being passed correctly), in that case you can perform "
"individual updates. For example, upgrading from CDash 1-2 to 1-4::"
msgstr "Alcuni browser Web potrebbero avere problemi durante l'aggiornamento (con alcune variabili javascript non passate correttamente), in tal caso è possibile eseguire singoli aggiornamenti. Ad esempio, l'aggiornamento da CDash 1-2 a 1-4::"

#: ../../source/chapter/CDash.rst:976
msgid "CDash Maintenance"
msgstr "Manutenzione di CDash"

#: ../../source/chapter/CDash.rst:978
msgid ""
"Database maintenance: we recommend that you perform database optimization"
" (reindexing, purging, etc.) regularly to maintain a stable database. "
"MySQL has a utility called ``mysqlcheck``, and PostgreSQL has several "
"utilities such as ``vacuumdb``."
msgstr "Manutenzione del database: si consiglia di eseguire regolarmente l'ottimizzazione del database (re-indicizzazione, purging, ecc.) per mantenere un database stabile. MySQL ha un'utilità chiamata ``mysqlcheck`` e PostgreSQL ha diverse utilità come ``vacuumdb``."

#: ../../source/chapter/CDash.rst:983
msgid ""
"Deleting builds with incorrect dates: some builds might be submitted to "
"CDash with the wrong date, either because the date in the XML file is "
"incorrect or the timezone was not recognized by CDash (mainly by PHP). "
"These builds will not show up in any dashboard because the start time is "
"bogus. In order to remove these builds:"
msgstr "Eliminazione di build con date errate: alcune build potrebbero essere inviate a CDash con la data errata, o perché la data nel file XML non è corretta o perché il fuso orario non è stato riconosciuto da CDash (principalmente da PHP). Queste build non verranno visualizzate in nessuna dashboard perché l'ora di inizio è bacata. Per rimuovere queste build:"

#: ../../source/chapter/CDash.rst:991 ../../source/chapter/CDash.rst:1012
msgid "Click on [CDash maintenance] in the administration section."
msgstr "Clickare su [CDash maintenance] nella sezione administration."

#: ../../source/chapter/CDash.rst:993
msgid "Click on 'Delete builds with wrong start date'."
msgstr "Clickare su 'Delete builds with wrong start date'."

#: ../../source/chapter/CDash.rst:995
msgid ""
"Recompute test timing: if you just upgraded CDash you might notice that "
"the current submissions are showing a high number of failing test due to "
"time defects. This is because CDash does not have enough sample points to"
" compute the mean and standard deviation for each test, in particular the"
" standard deviation might be very small (probably zero for the first few "
"samples). You should turn the \"enable test timing\" off for about a "
"week, or until you get enough build submissions and CDash has calculated "
"an approximate mean and standard deviation for each test time."
msgstr "Ricalcolare i tempi del test: se è stato appena aggiornato CDash si potrebbero notare che gli invii correnti mostrano un numero elevato di test falliti a causa di un tempo errato. Questo perché CDash non ha abbastanza punti campione per calcolare la media e la deviazione standard per ogni test, in particolare la deviazione standard potrebbe essere molto piccola (probabilmente zero per i primi campioni). Si deve disattivare \"enable test timing\" per circa una settimana, o fino a quando non si ricevono un numero sufficiente di invii di build e CDash ha calcolato una media approssimativa e una deviazione standard per ogni tempo di test."

#: ../../source/chapter/CDash.rst:1005
msgid ""
"The other option is to force CDash to compute the mean and standard "
"deviation for each test for the past few days. Be warned that this "
"process may take a long time, depending on the number of test and "
"projects involved. In order to recompute the test timing:"
msgstr "L'altra opzione è quella di forzare CDash a calcolare la media e la deviazione standard per ogni test degli ultimi giorni. Si tenga presente che questo processo potrebbe richiedere molto tempo, a seconda del numero di test e progetti coinvolti. Per ricalcolare i tempi del test:"

#: ../../source/chapter/CDash.rst:1014
msgid ""
"Specify the number of days (default is 4) to recompute the test timings "
"for."
msgstr "Specificare il numero di giorni (il default è 4) per ricalcolare i tempi del test."

#: ../../source/chapter/CDash.rst:1017
msgid ""
"Click on \"Compute test timing\". When the process is done the new mean, "
"standard deviation, and status should be updated for the tests submitted "
"during this period."
msgstr "Clickare su \"Compute test timing\". Al termine del processo, la nuova media, la deviazione standard e lo stato devono essere aggiornati per i test inviati durante questo periodo."

#: ../../source/chapter/CDash.rst:1022
msgid "Automatic build removal"
msgstr "Rimozione automatica della build"

#: ../../source/chapter/CDash.rst:1024
msgid ""
"In order to keep the database at a reasonable size, CDash can "
"automatically purge old builds. There are currently two ways to setup "
"automatic removal of builds: without a cronjob, edit the "
"``config.local.php`` and add/edit the following line"
msgstr "Per mantenere il database a dimensioni ragionevoli, CDash può eliminare automaticamente le vecchie build. Attualmente ci sono due modi per impostare la rimozione automatica delle build: senza un cronjob, si modifica ``config.local.php`` e si aggiunge/modifica la riga seguente"

#: ../../source/chapter/CDash.rst:1033
msgid ""
"CDash will automatically remove builds on the first submission of the "
"day. Note that removing builds might add an extra load on the database, "
"or slow down the current submission process if your database is large and"
" the number of submissions is high. If you can use a cronjob the PHP "
"command line tool can be used to trigger build removals at a convenient "
"time. For example, removing the builds for all the projects at 6am every "
"Sunday::"
msgstr "CDash rimuoverà automaticamente le build al primo invio della giornata. Si noti che la rimozione delle build potrebbe aggiungere un carico aggiuntivo al database o rallentare l'attuale processo di invio se il database è grande e il numero di invii è elevato. Se possibile utilizzare un cronjob, lo strumento della riga di comando PHP può essere utilizzato per attivare le rimozioni di build in un momento opportuno. Ad esempio, rimuovendo le build per tutti i progetti ogni domenica alle 6:00::"

#: ../../source/chapter/CDash.rst:1043
msgid ""
"Note that the 'all' parameter can be changed to a specific project name "
"in order to purge builds from a single project."
msgstr "Si noti che il parametro 'all' può essere modificato in un nome di progetto specifico per eliminare le build da un singolo progetto."

#: ../../source/chapter/CDash.rst:1047
msgid "CDash XML Schema"
msgstr "Schema XML di CDash"

#: ../../source/chapter/CDash.rst:1049
msgid ""
"The XML parsers in CDash can be easily extended to support new features. "
"The current XML schemas generated by CTest, and their features as "
"described in the book, are located at::"
msgstr "I parser XML in CDash possono essere facilmente estesi per supportare nuove funzionalità. Gli attuali schemi XML generati da CTest e le loro funzionalità descritte nel libro si trovano in::"

#: ../../source/chapter/CDash.rst:1060
msgid "Subprojects"
msgstr "Sottoprogetti"

#: ../../source/chapter/CDash.rst:1062
msgid ""
"CDash supports splitting projects into subprojects. Some of the "
"subprojects may in turn depend on other subprojects. A typical real life "
"project consists of libraries, executables, test suites, documentation, "
"web pages, and installers. Organizing your project into well-defined "
"subprojects and presenting the results of nightly builds on a CDash "
"dashboard can help identify where the problems are at different levels of"
" granularity."
msgstr "CDash supporta la suddivisione dei progetti in sottoprogetti. Alcuni dei sottoprogetti possono a loro volta dipendere da altri sottoprogetti. Un tipico progetto reale è costituito da librerie, eseguibili, test suite, documentazione, pagine Web e programmi di installazione. Organizzare il progetto in sottoprogetti ben definiti e presentare i risultati delle build notturne su un dashboard CDash può aiutare a identificare dove si trovano i problemi a diversi livelli di granularità."

#: ../../source/chapter/CDash.rst:1069
msgid ""
"A project with subprojects has a different view for its top level CDash "
"page than a project without any. It contains a summary row for the "
"project as a whole, and then one summary row for each subproject."
msgstr "Un progetto con sottoprogetti ha una vista diversa per la sua pagina CDash di primo livello rispetto a un progetto senza. Contiene una riga di riepilogo per il progetto nel suo insieme, quindi una riga di riepilogo per ogni sottoprogetto."

#: ../../source/chapter/CDash.rst:1074
msgid "Organizing and defining subprojects"
msgstr "Organizzazione e definizione di sottoprogetti"

#: ../../source/chapter/CDash.rst:1076
msgid ""
"To add subproject organization to your project, you must: (1) define the "
"subprojects for CDash, so that it knows how to display them properly and "
"(2) use build scripts with CTest to submit subproject builds of your "
"project. Some (re-)organization of your project's CMakeLists.txt files "
"may also be necessary to allow building of your project by subprojects."
msgstr "Per aggiungere l'organizzazione del sottoprogetto al progetto, si deve: (1) definire i sottoprogetti per CDash, in modo che sappia come visualizzarli correttamente e (2) utilizzare gli script di build con CTest per inviare le build del sottoprogetto. Potrebbe anche essere necessaria una (ri)organizzazione dei file CMakeLists.txt del progetto per consentire la creazione del progetto per sottoprogetti."

#: ../../source/chapter/CDash.rst:1083
msgid ""
"There are two ways to define subprojects and their dependencies: "
"interactively in the CDash GUI when logged in as a project administrator,"
" or by submitting a ``Project.xml`` file describing the subprojects and "
"dependencies."
msgstr "Esistono due modi per definire i sottoprogetti e le loro dipendenze: in modo interattivo nella GUI di CDash quando si accede come amministratore del progetto o inviando un file ``Project.xml`` che descrive i sottoprogetti e le dipendenze."

#: ../../source/chapter/CDash.rst:1089
msgid "Adding Subprojects Interactively"
msgstr "Aggiunta Interattiva di Sottoprogetti"

#: ../../source/chapter/CDash.rst:1091
msgid ""
"As a project administrator, a \"Manage subprojects\" button will appear "
"for each of your projects on the My CDash page. Clicking the Manage "
"Subprojects button opens the manage subproject page, where you may add "
"new subprojects or establish dependencies between existing subprojects "
"for any project that you are an administrator of."
msgstr "In qualità di amministratore del progetto, apparirà un pulsante \"Manage subprojects\" per ciascuno dei progetti nella pagina My CDash. Clickando sul pulsante Manage Subprojects si apre la pagina di gestione dei sottoprogetti, dove si possono aggiungere nuovi sottoprogetti o stabilire dipendenze tra sottoprogetti esistenti per qualsiasi progetto di cui si è amministratore."

#: ../../source/chapter/CDash.rst:1098
msgid "Adding Subprojects Automatically"
msgstr "Aggiunta automatica di sottoprogetti"

#: ../../source/chapter/CDash.rst:1100
msgid ""
"Another way to define CDash subprojects and their dependencies is to "
"submit a \"Project.xml\" file along with the usual submission files that "
"CTest sends when it submits a build to CDash. To define the same two "
"subprojects as in the interactive example above (Exes and Libs) with the "
"same dependency (Exes depend on Libs), the ``Project.xml`` file would "
"look like the following example::"
msgstr "Un altro modo per definire i sottoprogetti CDash e le loro dipendenze è quello di inviare un file \"Project.xml\" insieme ai normali spediti da CTest quando invia una build a CDash. Per definire gli stessi due sottoprogetti dell'esempio interattivo sopra (Exes e Libs) con la stessa dipendenza (gli Exes dipendono da Libs), il file ``Project.xml`` dovrebbe avere il seguente esempio::"

#: ../../source/chapter/CDash.rst:1114
msgid ""
"Once the ``Project.xml`` file is written or generated, it can be "
"submitted to CDash from a ctest -S script using the FILES argument to the"
" :command:`ctest_submit` command, or directly from the :manual:`ctest "
"<ctest(1)>` command line in a build tree configured for dashboard "
"submission."
msgstr "Una volta che il file ``Project.xml`` è stato scritto o generato, può essere inviato a CDash da uno script ctest -S usando l'argomento FILES al comando :command:`ctest_submit`, oppure direttamente dalla riga di comando :manual:`ctest <ctest(1)>` in un albero di build configurato per l'invio della dashboard."

#: ../../source/chapter/CDash.rst:1120
msgid "From inside a ctest -S script:"
msgstr "Dall'interno di uno script ctest -S:"

#: ../../source/chapter/CDash.rst:1126
msgid "From the command line::"
msgstr "Dalla riga di comando::"

#: ../../source/chapter/CDash.rst:1131
msgid ""
"CDash will automatically add subprojects and dependencies according to "
"the ``Project.xml`` file. CDash will also remove any subprojects or "
"dependencies not defined in the ``Project.xml`` file. Additionally, if "
"the same ``Project.xml`` is submitted multiple times, the second and "
"subsequent submissions will have no observable effect: the first "
"submission adds/modifies the data, the second and later submissions send "
"the same data, so no changes are necessary. CDash tracks changes to the "
"subproject definitions over time to allow for projects to evolve. If you "
"view dashboards from a past date, CDash will present the "
"project/subproject views according to the subproject definitions in "
"effect on that date."
msgstr "CDash aggiungerà automaticamente sottoprogetti e dipendenze in base al file ``Project.xml``. CDash rimuoverà anche eventuali sottoprogetti o dipendenze non definiti nel file ``Project.xml``. Inoltre, se lo stesso ``Project.xml`` viene inviato più volte, il secondo e i successivi invii non avranno alcun effetto osservabile: il primo invio aggiunge/modifica i dati, il secondo e i successivi invii inviano gli stessi dati, quindi non sono necessarie modifiche. CDash tiene traccia delle modifiche alle definizioni dei sottoprogetti nel tempo per consentire l'evoluzione dei progetti. Se si visualizzano le dashboard da una data passata, CDash presenterà le viste del progetto/sottoprogetto in base alle definizioni del sottoprogetto in vigore in quella data."

#: ../../source/chapter/CDash.rst:1144
msgid "Using ctest_submit with PARTS and FILES"
msgstr "Uso di ctest_submit con PARTS e FILES"

#: ../../source/chapter/CDash.rst:1146
msgid ""
"The :command:`ctest_submit` command supports ``PARTS`` and ``FILES`` "
"arguments. With ``PARTS``, you can send any subset of the xml files with "
"each :command:`ctest_submit` call. By default, all available parts are "
"sent with any call to :command:`ctest_submit`. A script can wait until "
"all dashboard stages are complete and then call :command:`ctest_submit` "
"once to send the results of all stages at the end of the run. "
"Alternatively, a script may call :command:`ctest_submit` with ``PARTS`` "
"to do partial submissions of subsets of the results. For example, you can"
" submit configure results after :command:`ctest_configure`, build results"
" after :command:`ctest_build`, and test results after "
":command:`ctest_test`. This allows for information to be posted as the "
"builds progress."
msgstr "Il comando :command:`ctest_submit` supporta gli argomenti ``PARTS`` e ``FILES``. Con ``PARTS``, si può inviare qualsiasi sottoinsieme dei file xml con ogni chiamata :command:`ctest_submit`. Per default, tutte le parti disponibili vengono inviate con qualsiasi chiamata a :command:`ctest_submit`. Uno script può attendere il completamento di tutte le fasi della dashboard e poi chiamare :command:`ctest_submit` una volta per inviare i risultati di tutte le fasi alla fine dell'esecuzione. In alternativa, uno script può chiamare :command:`ctest_submit` con ``PARTS`` per eseguire invii parziali di sottoinsiemi dei risultati. Ad esempio, si possono inviare i risultati di configurazione dopo :command:`ctest_configure`, i risultati di build dopo :command:`ctest_build` e i risultati di test dopo :command:`ctest_test`. Ciò consente di pubblicare informazioni man mano che le build progrediscono."

#: ../../source/chapter/CDash.rst:1158
msgid ""
"With ``FILES``, you can send arbitrary XML files to CDash. In addition to"
" the standard build result XML files that CTest sends, CDash also handles"
" a ``Project.xml`` file that describes subprojects and dependencies. "
"Below is an example of a dashboard script that contains a single "
":command:`ctest_submit` call on its last line"
msgstr "Con ``FILES``, si possono inviare file XML arbitrari a CDash. Oltre ai file XML dei risultati di build standard inviati da CTest, CDash gestisce anche un file ``Project.xml`` che descrive sottoprogetti e dipendenze. Di seguito è riportato un esempio di uno script di dashboard che contiene una singola chiamata :command:`ctest_submit` nell'ultima riga"

#: ../../source/chapter/CDash.rst:1177
msgid ""
"Submissions can occur incrementally, with each part of the submission "
"sent piecemeal as it becomes available:"
msgstr "Gli invii possono avvenire in modo incrementale, con ciascuna parte dell'invio inviata in modo frammentario non appena diventa disponibile:"

#: ../../source/chapter/CDash.rst:1193
msgid ""
"Submitting incrementally by parts means that you can inspect the results "
"of the configure stage live on the CDash dashboard while the build is "
"still in progress. Likewise, you can inspect the results of the build "
"stage live while the tests are still running. When submitting by parts, "
"it's important to use the ``APPEND`` keyword in the "
":command:`ctest_build` command. If you don't use ``APPEND``, then CDash "
"will erase any existing build with the same build name, site name, and "
"build stamp when it receives the Build.xml file."
msgstr "L'invio incrementale per parti significa che si possono ispezionare i risultati della fase di configurazione in tempo reale sulla dashboard di CDash mentre la build è ancora in corso. Allo stesso modo, si possono controllare i risultati della fase di build dal vivo mentre i test sono ancora in esecuzione. Quando si invia per parti, è importante utilizzare la parola chiave ``APPEND`` nel comando :command:`ctest_build`. Se non si usa ``APPEND``, CDash cancellerà qualsiasi build esistente con lo stesso nome della build, nome del sito e [stamp] della build quando riceve il file Build.xml."

#: ../../source/chapter/CDash.rst:1203
msgid "Splitting Your Project into Multiple Subprojects"
msgstr "Suddivisione del Progetto in Più Sottoprogetti"

#: ../../source/chapter/CDash.rst:1205
msgid ""
"One :command:`ctest_build` invocation that builds everything, followed by"
" one :command:`ctest_test` invocation that tests everything is sufficient"
" for a project that has no subprojects, but if you want to submit results"
" on a per-subproject basis to CDash, you will have to make some changes "
"to your project and test scripts. For your project you need to identify "
"what targets are part of what subprojects. If you organize your "
"CMakeLists files such that you have a target to build for each "
"subproject, and you can derive (or look up) the name of that target based"
" on the subproject name, then revising your script to separate it into "
"multiple smaller configure/build/test chunks should be relatively "
"painless. To do this, you can modify your CMakeLists files in various "
"ways depending on your needs. The most common changes are listed below."
msgstr "Un'invocazione di :command:`ctest_build` che compila tutto, seguita da un'invocazione di :command:`ctest_test` che verifica tutto è sufficiente per un progetto che non ha sottoprogetti, ma per inviare i risultati in base al sottoprogetto a CDash, sarà necessario apportare alcune modifiche al progetto e agli script di test. Per il progetto si deve identificare quali target fanno parte di quali sottoprogetti. Se si organizzano i file CMakeLists in modo tale da avere un target da creare per ogni sottoprogetto e si può derivare (o cercare) il nome di tale target in base al nome del sottoprogetto, rivedere lo script per separarlo in più configurazioni/build/test più piccoli dovrebbero essere relativamente semplice. Per fare ciò, si possono modificare i file CMakeLists in vari modi a seconda delle esigenze. Le modifiche più comuni sono elencate di seguito."

#: ../../source/chapter/CDash.rst:1220
msgid "CMakeLists.txt modifications"
msgstr "Modifiche a CMakeLists.txt"

#: ../../source/chapter/CDash.rst:1222
msgid ""
"Name targets the same as subprojects, base target names on subproject "
"names, or provide a look up mechanism to map from subproject name to "
"target name."
msgstr "Chiamare i target con lo stesso nome dei sottoprogetti, basare i nomi dei target sui nomi dei sottoprogetti o fornire un meccanismo di ricerca per mappare dal nome del sottoprogetto al nome del target."

#: ../../source/chapter/CDash.rst:1225
msgid ""
"Possibly add custom targets to aggregate existing targets into "
"subprojects, using :command:`add_dependencies` to say which existing "
"targets the custom target depends on."
msgstr "Possibilmente aggiungere target custom per aggregare target esistenti in sottoprogetti, usando :command:`add_dependencies` per dire da quali target esistenti dipende il target custom."

#: ../../source/chapter/CDash.rst:1228
msgid ""
"Add the ``LABELS`` target property to targets with a value of the "
"subproject name."
msgstr "Aggiungere la proprietà ``LABELS`` col nome del sottoprogetto come valore ai target."

#: ../../source/chapter/CDash.rst:1230
msgid ""
"Add the ``LABELS`` test property to tests with a value of the subproject "
"name."
msgstr "Aggiungere la proprietà ``LABELS`` col nome del sottoprogetto come valore ai test."

#: ../../source/chapter/CDash.rst:1233
msgid ""
"Next, you need to modify your CTest scripts that run your dashboards. To "
"split your one large monolithic build into smaller subproject builds, you"
" can use a :command:`foreach` loop in your CTest driver script. To help "
"you iterate over your subprojects, CDash provides a variable named "
"``CTEST_PROJECT_SUBPROJECTS`` in ``CTestConfig.cmake``. Given the above "
"example, CDash produces a variable like this:"
msgstr "Successivamente, è necessario modificare gli script CTest che eseguono le dashboard. Per suddividere la build monolitica di grandi dimensioni in build di sottoprogetti più piccole, si può utilizzare un ciclo :command:`foreach` nello script del driver CTest. Per scorrere i sottoprogetti, CDash fornisce una variabile denominata ``CTEST_PROJECT_SUBPROJECTS`` in ``CTestConfig.cmake``. Dato l'esempio sopra, CDash produce una variabile come questa:"

#: ../../source/chapter/CDash.rst:1245
msgid ""
"CDash orders the elements in this list such that the independent "
"subprojects (that do not depend on any other subprojects) are first, "
"followed by subprojects that depend only on the independent subprojects, "
"and after that subprojects that depend on those. The same logic continues"
" until all subprojects are listed exactly once in this list in an order "
"that makes sense for building them sequentially, one after the other."
msgstr "CDash ordina gli elementi in questo elenco in modo tale che i sottoprogetti indipendenti (che non dipendono da altri sottoprogetti) siano i primi, seguiti dai sottoprogetti che dipendono solo dai sottoprogetti indipendenti e quindi dai sottoprogetti che dipendono da questi. La stessa logica continua finché tutti i sottoprogetti non vengono elencati esattamente una volta in questo elenco in un ordine che abbia senso per la loro creazione in sequenza, uno dopo l'altro."

#: ../../source/chapter/CDash.rst:1253
msgid ""
"To facilitate building just the targets associated with a subproject, use"
" the variable named ``CTEST_BUILD_TARGET`` to tell :command:`ctest_build`"
" what to build. To facilitate running just the tests associated with a "
"subproject, assign the ``LABELS`` test property to your tests and use the"
" ``INCLUDE_LABEL`` argument to :command:`ctest_test`."
msgstr "Per facilitare la build solo dei target associati a un sottoprogetto, si usa la variabile chiamata ``CTEST_BUILD_TARGET`` per dire a :command:`ctest_build` cosa buildare. Per facilitare l'esecuzione dei soli test associati a un sottoprogetto, si assegna la proprietà test ``LABELS`` ai test e si usa l'argomento ``INCLUDE_LABEL`` per :command:`ctest_test`."

#: ../../source/chapter/CDash.rst:1260
msgid "ctest driver script modifications"
msgstr "Modifiche allo script del driver ctest"

#: ../../source/chapter/CDash.rst:1262
msgid ""
"Iterate over the subprojects in dependency order (from independent to "
"most dependent...)."
msgstr "Scorrere i sottoprogetti in ordine di dipendenza (dall'indipendente al più dipendente...)."

#: ../../source/chapter/CDash.rst:1264
msgid ""
"Set the SubProject and Label global properties -- CTest uses these "
"properties to submit the results to the correct subproject on the CDash "
"server."
msgstr "Impostare le proprietà globali SubProject e Label: CTest utilizza queste proprietà per inviare i risultati al sottoprogetto corretto sul server CDash."

#: ../../source/chapter/CDash.rst:1267
msgid ""
"Build the target(s) for this subproject: compute the name of the target "
"to build from the subproject name, set ``CTEST_BUILD_TARGET``, call "
":command:`ctest_build`."
msgstr "Creare il/i target per questo sottoprogetto: calcolare il nome del target da compilare dal nome del sottoprogetto, impostare ``CTEST_BUILD_TARGET``, chiamare :command:`ctest_build`."

#: ../../source/chapter/CDash.rst:1270
msgid ""
"Run the tests for this subproject using the ``INCLUDE`` or "
"``INCLUDE_LABEL`` arguments to :command:`ctest_test`."
msgstr "Eseguire i test per questo sottoprogetto utilizzando gli argomenti ``INCLUDE`` o ``INCLUDE_LABEL`` in :command:`ctest_test`."

#: ../../source/chapter/CDash.rst:1272
msgid ""
"Use :command:`ctest_submit` with the ``PARTS`` argument to submit partial"
" results as they complete."
msgstr "Usare :command:`ctest_submit` con l'argomento ``PARTS`` per inviare risultati parziali man mano che vengono completati."

#: ../../source/chapter/CDash.rst:1275
msgid ""
"To illustrate this, the following example shows the changes required to "
"split a build into smaller pieces. Assume that the subproject name is the"
" same as the target name required to build the subproject's components. "
"For example, here is a snippet from CMakeLists.txt, in the hypothetical "
"Tutorial project. The only additions necessary (since the target names "
"are the same as the subproject names) are the calls to "
":command:`set_property` for each target and each test."
msgstr "Per illustrare ciò, l'esempio seguente mostra le modifiche necessarie per suddividere una build in parti più piccole. Si supponga che il nome del sottoprogetto sia lo stesso del nome del target richiesto per creare i componenti del sottoprogetto. Ad esempio, ecco uno snippet da CMakeLists.txt, nell'ipotetico progetto Tutorial. Le uniche aggiunte necessarie (poiché i nomi dei target sono gli stessi dei nomi dei sottoprogetti) sono le chiamate a :command:`set_property` per ogni target e ogni test."

#: ../../source/chapter/CDash.rst:1309
msgid ""
"Here is an example of what the CTest driver script might look like before"
" and after organizing this project into subprojects. Before the changes"
msgstr "Ecco un esempio di come potrebbe apparire lo script del driver CTest prima e dopo l'organizzazione di questo progetto in sottoprogetti. Prima delle modifiche"

#: ../../source/chapter/CDash.rst:1333
msgid "After the changes:"
msgstr "Dopo le modifiche:"

#: ../../source/chapter/CDash.rst:1364
msgid ""
"In some projects, more than one :command:`ctest_build` step may be "
"required to build all the pieces of the subproject. For example, in "
"Trilinos, each subproject builds the ``${subproject}_libs target``, and "
"then builds the all target to build all the configured executables in the"
" test suite. They also configure dependencies such that only the "
"executables that need to be built for the currently configured packages "
"build when the all target is built."
msgstr "In alcuni progetti, potrebbe essere necessario più di un passo :command:`ctest_build` per buildare tutti i pezzi del sottoprogetto. Ad esempio, in Trilinos, ogni sottoprogetto compila il ``${subproject}_libs target``, poi compila il target all per compilare tutti gli eseguibili configurati nella suite di test. Inoltre configurano le dipendenze in modo tale che solo gli eseguibili che devono essere compilati per i pacchetti attualmente configurati vengano compilati quando viene compilato il target all."

#: ../../source/chapter/CDash.rst:1372
msgid ""
"Normally, if you submit multiple ``Build.xml`` files to CDash with the "
"same exact build stamp, it will delete the existing entry and add the new"
" entry in its place. In the case where multiple :command:`ctest_build` "
"steps are required, each with their own :command:`ctest_submit(PARTS "
"Build)` call, use the ``APPEND`` keyword argument in all of the "
":command:`ctest_build` calls that belong together. The ``APPEND`` flag "
"tells CDash to accumulate the results from multiple submissions and "
"display the aggregation of all of them in one row on the dashboard. From "
"CDash's perspective, multiple :command:`ctest_build` calls (with the same"
" build stamp and subproject and ``APPEND`` turned on) result in a single "
"CDash build."
msgstr "Normalmente, se si inviano più file ``Build.xml`` a CDash con lo stesso [stamp] della build, eliminerà la voce esistente e aggiungerà la nuova voce al suo posto. Nel caso in cui siano richiesti più passaggi :command:`ctest_build`, ciascuno con la propria chiamata :command:`ctest_submit(PARTS Build)`, utilizzare l'argomento chiave ``APPEND`` in tutte le chiamate :command:`ctest_build` che risultano raggruppate. Il flag ``APPEND`` indica a CDash di accumulare i risultati di più invii e di visualizzare l'aggregazione di tutti in una riga sulla dashboard. Dal punto di vista di CDash, più chiamate a :command:`ctest_build` (con lo [stamp] di build e sottoprogetto e ``APPEND`` attivato) risultano in una singola build di CDash."

#: ../../source/chapter/CDash.rst:1384
msgid ""
"Adopt some of these tips and techniques in your favorite CMake-based "
"project:"
msgstr "Adottare alcuni di questi suggerimenti e tecniche nel progetto basato su CMake:"

#: ../../source/chapter/CDash.rst:1387
msgid ""
"``LABELS`` is a CMake/CTest property that applies to source files, "
"targets and tests. Labels are sent to CDash inside the resulting xml "
"files."
msgstr "``LABELS`` è una proprietà CMake/CTest che si applica a file sorgenti, target e test. Le etichette vengono inviate a CDash all'interno dei file xml risultanti."

#: ../../source/chapter/CDash.rst:1390
msgid ""
"Use :command:`ctest_submit(PARTS ...)` to do incremental submissions. "
"Results are available for viewing on the dashboards sooner. Don't forget "
"to use ``APPEND`` in your :command:`ctest_build` calls when submitting by"
" parts."
msgstr "Usare :command:`ctest_submit(PARTS ...)` per effettuare invii incrementali. I risultati sono disponibili per la visualizzazione prima sulle dashboard. Non dimenticare di usare ``APPEND`` nelle chiamate a :command:`ctest_build` quando si invia per parti."

#: ../../source/chapter/CDash.rst:1394
msgid ""
"Use ``INCLUDE_LABEL`` with :command:`ctest_test` to run only the tests "
"with labels that match the regular expression."
msgstr "Usare ``INCLUDE_LABEL`` con :command:`ctest_test` per eseguire solo i test con etichette che corrispondono all'espressione regolare."

#: ../../source/chapter/CDash.rst:1396
msgid ""
"Use ``CTEST_BUILD_TARGET`` to build your subprojects one at a time, "
"submitting subproject dashboards along the way."
msgstr "Usare ``CTEST_BUILD_TARGET`` per la build dei sottoprogetti uno alla volta, inviando le dashboard dei sottoprogetti man mano."

#: ../../source/chapter/CMake Cache.rst:2
msgid "CMake Cache"
msgstr "La Cache di CMake"

#: ../../source/chapter/CMake Cache.rst:4
msgid ""
"The CMake cache may be thought of as a configuration file. The first time"
" CMake is run on a project, it produces a ``CMakeCache.txt`` file in the "
"top directory of the build tree. CMake uses this file to store a set of "
"global cache variables, whose values persist across multiple runs within "
"a project build tree."
msgstr "La cache di CMake può essere considerata come un file di configurazione. La prima volta che CMake viene eseguito su un progetto, produce un file ``CMakeCache.txt`` nella directory superiore dell'albero di build. CMake usa questo file per archiviare un set di variabili globali della cache, i cui valori persistono su più esecuzioni all'interno di un albero di build del progetto."

#: ../../source/chapter/CMake Cache.rst:10
msgid ""
"There are a few purposes of this cache. The first is to store the user's "
"selections and choices, so that if they should run CMake again they will "
"not need to reenter that information. For example, the :command:`option` "
"command creates a Boolean variable and stores it in the cache."
msgstr "Ci sono alcuni scopi di tale cache. Il primo è memorizzare le selezioni e le scelte dell'utente, in modo che se dovesse eseguire nuovamente CMake non dovrà reinserire tali informazioni. Ad esempio, il comando :command:`option` crea una variabile booleana e la memorizza nella cache."

#: ../../source/chapter/CMake Cache.rst:19
msgid ""
"The above line would create a variable called ``USE_JPEG`` and put it "
"into the cache. That way the user can set that variable from the user "
"interface and its value will remain in case the user should run CMake "
"again in the future. To create a variable in the cache, use commands like"
" :command:`option`, :command:`find_file`, or the standard :command:`set` "
"command with the ``CACHE`` option."
msgstr "La riga precedente crea una variabile chiamata ``USE_JPEG`` e la inserisce nella cache. In questo modo l'utente può impostare tale variabile dall'interfaccia utente e il suo valore rimarrà nel caso in cui l'utente debba eseguire nuovamente CMake in futuro. Per creare una variabile nella cache, si usano comandi come :command:`option`, :command:`find_file`, o il comando standard :command:`set` con l'opzione ``CACHE``."

#: ../../source/chapter/CMake Cache.rst:30
msgid ""
"When you use the ``CACHE`` option, you may also provide the type of the "
"variable and a documentation string. The type of the variable is used by "
"the :manual:`cmake-gui <cmake-gui(1)>` to control how that variable is "
"set and displayed, but the value is always stored in the cache file as a "
"string."
msgstr "Quando si usa l'opzione ``CACHE``, si può anche fornire il tipo di variabile e una stringa di documentazione. Il tipo della variabile è usato da :manual:`cmake-gui <cmake-gui(1)>` per controllare come la variabile è impostata e visualizzata, ma il valore è sempre memorizzato nel file di cache come una stringa."

#: ../../source/chapter/CMake Cache.rst:35
msgid ""
"Another purpose of the cache is to allow CMake itself to persistently "
"store values between CMake runs. These entries may not be visible or "
"adjustable by the user. Typically, these values are system-dependent "
"variables that require CMake to compile and run a program to determine "
"their value. Once these values have been determined, they are stored in "
"the cache to avoid having to recompute them every time CMake is run. "
"CMake generally tries to limit these variables to properties that should "
"never change (such as the byte order of the machine you are on). If you "
"significantly change your computer, either by changing the operating "
"system or switching to a different compiler, you will need to delete the "
"cache file (and probably all of your binary tree's object files, "
"libraries, and executables)."
msgstr "Un altro scopo della cache è consentire a CMake stesso di archiviare in modo persistente i valori tra le sue esecuzioni. Queste voci potrebbero non essere visibili o modificabili dall'utente. In genere, questi valori sono variabili dipendenti dal sistema che richiedono a CMake di compilare ed eseguire un programma per determinarne il valore. Una volta che questi valori sono stati determinati, vengono archiviati nella cache per evitare di doverli ricalcolare ogni volta che viene eseguito CMake. CMake generalmente cerca di limitare queste variabili a proprietà che non dovrebbero mai cambiare (come l'ordine dei byte della macchina su cui ci si trova). Se si modifichi in modo significativo il computer, modificando il sistema operativo o passando a un compilatore diverso, si dovrà eliminare il file cache (e probabilmente tutti i file oggetto, le librerie e gli eseguibili dell'albero binario)."

#: ../../source/chapter/CMake Cache.rst:48
msgid ""
"Some projects are very complex and setting one value in the cache may "
"cause new options to appear the next time the cache is built. For "
"example, VTK supports the use of MPI for performing distributed "
"computing. This requires the build process to determine where the MPI "
"libraries and header files are and to let the user adjust their values. "
"But MPI is only available if another option ``VTK_USE_PARALLEL`` is first"
" turned on in VTK. So, to avoid confusion for people who don't know what "
"MPI is, those options are hidden until ``VTK_USE_PARALLEL`` is turned on."
" So CMake shows the ``VTK_USE_PARALLEL`` option in the cache area, if the"
" user turns that on and re-configures with CMake, new options will appear"
" for MPI that they can then set. The rule is to keep building the cache "
"until it doesn't change. For most projects this will be just once. For "
"some complicated ones it may be twice or more."
msgstr "Alcuni progetti sono molto complessi e l'impostazione di un valore nella cache potrebbe far apparire nuove opzioni la prossima volta che la cache viene creata. Ad esempio, VTK supporta l'uso di MPI per eseguire il calcolo distribuito. Ciò richiede che il processo di compilazione determini dove si trovano le librerie MPI e i file header e permetta all'utente di aggiustarne i valori. Ma MPI è disponibile solo se un'altra opzione ``VTK_USE_PARALLEL`` viene attivata prima in VTK. Quindi, per evitare confusione per le persone che non sanno cosa sia MPI, queste opzioni sono nascoste finché ``VTK_USE_PARALLEL`` non viene attivato. Quindi CMake mostra l'opzione ``VTK_USE_PARALLEL`` nell'area della cache, se l'utente la attiva e si riconfigura con CMake, appariranno nuove opzioni per MPI che si possono poi impostare. La regola è continuare il build della cache finché non cambia. Per la maggior parte dei progetti questo avverrà solo una volta. Per alcuni più complicati potrebbe essere due o più."

#: ../../source/chapter/CMake Cache.rst:61
msgid ""
"You might be tempted to edit the cache file directly, or to "
"\"initialize\" a project by giving it a pre-populated ``CMakeCache.txt`` "
"file. This may not work and could cause additional problems in the "
"future. First, the syntax of the CMake cache is subject to change. "
"Second, cache files contain full paths which make them unsuitable for "
"moving between binary trees."
msgstr "Si potrebbe essere tentati di modificare direttamente il file della cache o di \"inizializzare\" un progetto fornendogli un file ``CMakeCache.txt`` pre-popolato. Questo potrebbe non funzionare e potrebbe causare ulteriori problemi in futuro. Innanzitutto, la sintassi della cache CMake è soggetta a cambiamenti. In secondo luogo, i file di cache contengono path completi che li rendono inadatti allo spostamento tra alberi binari."

#: ../../source/chapter/CMake Cache.rst:68
msgid ""
"Once a variable is in the cache, its \"cache\" value cannot normally be "
"modified from a CMakeLists file. The reasoning behind this is that once "
"CMake has put the variable into the cache with its initial value, the "
"user may then modify that value from the GUI. If the next invocation of "
"CMake overwrote their change back to the :command:`set` value, the user "
"would never be able to make a change that CMake wouldn't overwrite. A "
"``set(FOO ON CACHE BOOL \"doc\")`` command will typically only do "
"something when the cache doesn't have the variable in it. Once the "
"variable is in the cache, that command will have no effect."
msgstr "Una volta che una variabile è nella cache, il suo valore \"cache\" normalmente non può essere modificato da un file CMakeLists. Il ragionamento alla base di ciò è che una volta che CMake ha inserito la variabile nella cache con il suo valore iniziale, l'utente può poi modificare quel valore dalla GUI. Se la successiva chiamata di CMake sovrascrivesse la loro modifica al valore :command:`set`, l'utente non sarebbe mai in grado di apportare una modifica che CMake non sovrascriverebbe. Un comando ``set(FOO ON CACHE BOOL \"doc\")`` tipicamente farà qualcosa solo quando la cache non contiene la variabile. Una volta che la variabile è nella cache, quel comando non avrà alcun effetto."

#: ../../source/chapter/CMake Cache.rst:78
msgid ""
"In the rare event that you really want to change a cached variable's "
"value, use the ``FORCE`` option in combination with the ``CACHE`` option "
"to the :command:`set` command. The ``FORCE`` option will cause the "
":command:`set` command to override and change the cache value of a "
"variable."
msgstr "Nel raro caso in cui si voglia davvero modificare il valore di una variabile memorizzata nella cache, si usa l'opzione ``FORCE`` in combinazione con l'opzione ``CACHE`` nel comando :command:`set`. L'opzione ``FORCE`` farà sì che il comando :command:`set` sovrascriva e modifichi il valore della cache di una variabile."

#: ../../source/chapter/CMake Cache.rst:83
msgid ""
"A few final points should be made concerning variables and their "
"interaction with the cache. If a variable is in the cache, it can still "
"be overridden in a CMakeLists file using the :command:`set` command "
"without the ``CACHE`` option. Cache values are checked when a referenced "
"variable is not defined in the current scope. The :command:`set` command "
"will define a variable for the current scope without changing the value "
"in the cache."
msgstr "Alcuni punti finali dovrebbero essere fatti riguardo alle variabili e alla loro interazione con la cache. Se una variabile è nella cache, può comunque essere sovrascritta in un file CMakeLists usando il comando :command:`set` senza l'opzione ``CACHE``. I valori della cache vengono controllati quando una variabile di riferimento non è definita nello scope corrente. Il comando :command:`set` definirà una variabile per lo scope corrente senza modificare il valore nella cache."

#: ../../source/chapter/CMake Cache.rst:99
msgid ""
"Variables that are in the cache also have a property indicating if they "
"are advanced or not. By default, when :manual:`ccmake <ccmake(1)>` or the"
" :manual:`cmake-gui <cmake-gui(1)>` are run, the advanced cache entries "
"are not displayed. This is so the user can focus on the cache entries "
"that they should consider changing. The advanced cache entries are other "
"options that the user can modify, but typically will not. It is not "
"unusual for a large software project to have fifty or more options, and "
"the advanced property lets a software project divide them into key "
"options for most users and advanced options for advanced users. Depending"
" on the project, there may not be any non-advanced cache entries. To make"
" a cache entry advanced, the :command:`mark_as_advanced` command is used "
"with the name of the variable (a.k.a. cache entry)."
msgstr "Le variabili che si trovano nella cache hanno anche una proprietà che indica se sono avanzate o meno. Per default, quando vengono eseguiti :manual:`ccmake <ccmake(1)>` o :manual:`cmake-gui <cmake-gui(1)>`, le voci della cache avanzata non vengono visualizzate. In questo modo l'utente può concentrarsi sulle voci della cache che dovrebbe considerare di modificare. Le voci avanzate della cache sono altre opzioni che l'utente può modificare, ma in genere non lo farà. Non è insolito che un progetto software di grandi dimensioni abbia cinquanta o più opzioni e la proprietà \"advanced\" consente a un progetto software di suddividerle in opzioni chiave per la maggior parte degli utenti e in opzioni avanzate per utenti esperti. A seconda del progetto, potrebbero non esserci voci di cache non avanzate. Per rendere avanzata una voce della cache, viene utilizzato il comando :command:`mark_as_advanced` con il nome della variabile (ovvero la voce della cache)."

#: ../../source/chapter/CMake Cache.rst:112
msgid ""
"In some cases, you might want to restrict a cache entry to a limited set "
"of predefined options. You can do this by setting the "
":prop_cache:`STRINGS` property on the cache entry. The following "
"CMakeLists code illustrates this by creating a property named "
"``CRYPTOBACKEND`` as usual, and then setting the ``STRINGS`` property on "
"it to a set of three options."
msgstr "In alcuni casi, si potrebbe voler limitare una voce della cache a un insieme limitato di opzioni predefinite. Lo si può fare impostando la proprietà :prop_cache:`STRINGS` sulla voce della cache. Il seguente codice CMakeLists lo illustra creando una proprietà denominata ``CRYPTOBACKEND`` come al solito e quindi impostando la proprietà ``STRINGS`` su di essa su un insieme di tre opzioni."

#: ../../source/chapter/CMake Cache.rst:125
msgid ""
"When :manual:`cmake-gui <cmake-gui(1)>` is run and the user selects the "
"``CRYPTOBACKEND`` cache entry, they will be presented with a pulldown to "
"select which option they want."
msgstr "Quando viene eseguito :manual:`cmake-gui <cmake-gui(1)>` e l'utente seleziona la voce della cache ``CRYPTOBACKEND``, verrà visualizzato un menù a tendina per selezionare l'opzione voluta."

#: ../../source/chapter/CMake Cache.rst:133
msgid "Setting Initial Values for CMake"
msgstr "Impostazione dei Valori Iniziali per CMake"

#: ../../source/chapter/CMake Cache.rst:135
msgid ""
"Sometimes you may need to set up cache entries without running a GUI. "
"This is common when setting up nightly dashboards, or if you will be "
"creating many build trees with the same cache values. In these cases, the"
" CMake cache can be initialized in two different ways. The first way is "
"to pass the cache values on the CMake command line using "
"``-DCACHE_VAR:TYPE=VALUE`` arguments. For example, consider the following"
" nightly dashboard script for a UNIX machine:"
msgstr "A volte potrebbe essere necessario impostare le voci della cache senza eseguire una GUI. Questo è comune quando si impostano dashboard notturne o se si creeranno molti alberi di build con gli stessi valori della cache. In questi casi, la cache di CMake può essere inizializzata in due modi diversi. Il primo modo consiste nel passare i valori della cache sulla riga di comando di CMake utilizzando gli argomenti ``-DCACHE_VAR:TYPE=VALUE``. Ad esempio, si consideri il seguente script della dashboard notturna per una macchina UNIX:"

#: ../../source/chapter/CMake Cache.rst:160
msgid "The same idea can be used with a batch file on Windows."
msgstr "La stessa idea può essere utilizzata con un file batch su Windows."

#: ../../source/chapter/CMake Cache.rst:162
msgid ""
"The second way is to create a file to be loaded using :manual:`cmake "
"<cmake(1)>`'s ``-C`` option. In this case, instead of setting up the "
"cache with ``-D`` options, it is done through a file that is parsed by "
"CMake. The syntax for this file is the standard CMakeLists syntax, which "
"is typically a series of :command:`set` commands such as:"
msgstr "Il secondo modo consiste nel creare un file da caricare  :manual:`cmake <cmake(1)>` con la sua opzione ``-C``. In questo caso, invece di configurare la cache con le opzioni ``-D``, viene eseguita tramite un file che viene analizzato da CMake. La sintassi per questo file è quella standard di CMakeLists, che in genere è una serie di comandi :command:`set` come:"

#: ../../source/chapter/CMake Cache.rst:173
msgid ""
"In some cases there might be an existing cache, and you want to force the"
" cache values to be set a certain way. For example, say you want to turn "
"Hybrid on even if the user has previously run CMake and turned it off. "
"Then you can do"
msgstr "In alcuni casi potrebbe esserci una cache esistente e si desidera forzare l'impostazione dei valori della cache in un certo modo. Ad esempio, si supponga di voler attivare Hybrid anche se l'utente abbia precedentemente eseguito CMake e lo abbia disattivato. Allora si può fare"

#: ../../source/chapter/CMake Cache.rst:186
msgid ""
"Another option is that you want to set and then hide options so the user "
"will not be tempted to adjust them later on. This can be done using type "
"``INTERNAL``.  ``INTERNAL`` cache variables imply ``FORCE`` and are never"
" shown in cache editors."
msgstr "Un'altra possibilità è che si desidera impostare e quindi nascondere le opzioni in modo che l'utente non sia tentato di modificarle in seguito. Questo può essere fatto usando il tipo ``INTERNAL``.  Le variabili di cache ``INTERNAL`` implicano ``FORCE`` e non vengono mai mostrate negli editor della cache."

#: ../../source/chapter/Converting CMake.rst:2 Existing Systems To
msgid "Converting Existing Systems To CMake"
msgstr "Conversione di Sistemi Esistenti in CMake"

#: ../../source/chapter/Converting CMake.rst:4 Existing Systems To
msgid ""
"For many people, the first thing they will do with CMake is convert an "
"existing project from using an older build system to use CMake. This can "
"be a fairly easy process, but there are a few issues to consider. This "
"section will address those issues and provide some suggestions for "
"effectively converting a project over to CMake. The first issue to "
"consider when converting to CMake is the project's directory structure."
msgstr "Molte persone, la prima cosa che faranno con CMake è convertire un progetto esistente dall'utilizzo di un vecchio sistema di build per utilizzare CMake. Questo può essere un processo abbastanza semplice, ma ci sono alcuni problemi da considerare. Questa sezione affronterà tali problemi e fornirà alcuni suggerimenti per convertire efficacemente un progetto in CMake. Il primo problema da considerare durante la conversione in CMake è la struttura della directory del progetto."

#: ../../source/chapter/Converting CMake.rst:16 Existing Systems To
msgid "Source Code Directory Structures"
msgstr "Struttura della Directory Del Codice Sorgente"

#: ../../source/chapter/Converting CMake.rst:18 Existing Systems To
msgid ""
"Most small projects will have their source code in either the top level "
"directory or in a directory named ``src`` or ``source``. Even if all of "
"the source code is in a subdirectory, we highly recommend creating a "
"CMakeLists file for the top level directory. There are two reasons for "
"this. First, it can be confusing to some people that they must run CMake "
"on the subdirectory of the project, instead of the main directory. "
"Second, you may want to install documentation or other support files from"
" the other directories. By having a CMakeLists file at the top of the "
"project, you can use the :command:`add_subdirectory` command to step down"
" into the documentation directory where its CMakeLists file can install "
"the documentation (you can have a CMakeLists file for a documentation "
"directory with no targets or source code)."
msgstr "La maggior parte dei piccoli progetti avrà il proprio codice sorgente nella directory di livello superiore o in una directory chiamata ``src`` o ``source``. Anche se tutto il codice sorgente si trova in una sottodirectory, consigliamo vivamente di creare un file CMakeLists per la directory di primo livello. Ci sono due ragioni per questo. Innanzitutto, può creare confusione per alcuni dover eseguire CMake nella sottodirectory del progetto, anziché in quella principale. In secondo luogo, si potrebbe voler installare la documentazione o altri file di supporto da altre directory. Avendo un file CMakeLists al top del progetto, si può usare il comando :command:`add_subdirectory` per scendere nella directory della documentazione dove il suo file CMakeLists può installare la documentazione (si può avere un file CMakeLists per una directory di documentazione senza target o codice sorgente)."

#: ../../source/chapter/Converting CMake.rst:32 Existing Systems To
msgid ""
"For projects that have source code in multiple directories, there are a "
"few options. One option that many Makefile-based projects use is to have "
"a single Makefile at the top-level directory that lists all the source "
"files to compile in their subdirectories. For example::"
msgstr "Per i progetti che hanno il codice sorgente in più directory, ci sono alcune scelte. Un'opzione utilizzata da molti progetti basati su Makefile consiste nell'avere un singolo Makefile nella directory di primo livello che elenca tutti i file sorgente da compilare nelle loro sottodirectory. Per esempio::"

#: ../../source/chapter/Converting CMake.rst:43 Existing Systems To
msgid "This approach works just as well with CMake using a similar syntax:"
msgstr "Questo approccio funziona altrettanto bene con CMake utilizzando una sintassi simile:"

#: ../../source/chapter/Converting CMake.rst:54 Existing Systems To
msgid ""
"Another option is to have each subdirectory build a library or libraries "
"that can then be linked into the executables. In those cases, each "
"subdirectory would define its own list of source files and add the "
"appropriate targets. A third option is a mixture of the first two; each "
"subdirectory can have a CMakeLists file that lists its sources, but the "
"top-level CMakeLists file will not use the :command:`add_subdirectory` "
"command to step into the subdirectories. Instead, the top-level "
"CMakeLists file will use the :command:`include` command to include each "
"of the subdirectory's CMakeLists files. For example, a top-level "
"CMakeLists file might include the following code"
msgstr "Un'altra possibilità è fare in modo che ciascuna sottodirectory crei una libreria o librerie che possano poi essere linkate agli eseguibili. In questi casi, ciascuna sottodirectory definirà il proprio elenco di file sorgenti e aggiungerà i target appropriati. Una terza opzione è una mix delle prime due; ogni sottodirectory può avere un file CMakeLists che elenca i suoi sorgenti, ma il file CMakeLists di primo livello non utilizzerà il comando :command:`add_subdirectory` per entrare nelle sottodirectory. Ma, il file CMakeLists di primo livello utilizzerà il comando :command:`include` per includere ciascuno dei file CMakeLists della sottodirectory. Ad esempio, un file CMakeLists di primo livello potrebbe includere il codice seguente"

#: ../../source/chapter/Converting CMake.rst:88 Existing Systems To
msgid ""
"While the CMakeLists files in the subdirectories might look like the "
"following:"
msgstr "Mentre i file CMakeLists nelle sottodirectory potrebbero avere il seguente aspetto:"

#: ../../source/chapter/Converting CMake.rst:99 Existing Systems To
msgid ""
"The approach you use is entirely up to you. For large projects, having "
"multiple shared libraries can certainly improve build times when changes "
"are made. For smaller projects, the other two approaches have their "
"advantages. The main suggestion here is to choose a strategy and stick "
"with it."
msgstr "L'approccio è una scelta personale. Per progetti di grandi dimensioni, avere più librerie condivise può sicuramente migliorare i tempi di compilazione quando vengono apportate modifiche. Per i progetti più piccoli, gli altri due approcci hanno i loro vantaggi. Il suggerimento è quello di scegliere una strategia e seguirla."

#: ../../source/chapter/Converting CMake.rst:111 Existing Systems To
msgid "Build Directories"
msgstr "Directory di Build"

#: ../../source/chapter/Converting CMake.rst:113 Existing Systems To
msgid ""
"The next issue to consider is where to put the resulting object files, "
"libraries, and executables. There are a few different, commonly used "
"approaches, and some work better with CMake than others. The recommended "
"strategy is to put the binary files into a separate tree that has the "
"same structure as the source tree. For example, if the source tree looked"
" like the following::"
msgstr "Il problema successivo da considerare è dove inserire i file oggetto, le librerie e gli eseguibili risultanti. Esistono alcuni approcci diversi e comunemente usati e alcuni funzionano meglio con CMake rispetto ad altri. La strategia consigliata consiste nell'inserire i file binari in un albero separato che abbia la stessa struttura dell'albero dei sorgenti. Ad esempio, se l'albero dei sorgenti fosse simile al seguente::"

#: ../../source/chapter/Converting CMake.rst:124 Existing Systems To
msgid "the binary tree might look like::"
msgstr "l'albero binario potrebbe essere simile a::"

#: ../../source/chapter/Converting CMake.rst:130 Existing Systems To
msgid ""
"For some Windows generators, such as Visual Studio, build files are "
"actually kept in a subdirectory matching the selected configuration; e.g."
" debug, release, etc."
msgstr "Per alcuni generatori di Windows, come Visual Studio, i file di compilazione vengono effettivamente conservati in una sottodirectory corrispondente alla configurazione selezionata; per esempio. debug, release, ecc."

#: ../../source/chapter/Converting CMake.rst:134 Existing Systems To
msgid ""
"If you need to support multiple architectures from one source tree, we "
"highly recommend a directory structure like the following::"
msgstr "Se c'è bisogno di supportare più architetture da un albero di sorgenti, consigliamo vivamente una struttura di directory come la seguente::"

#: ../../source/chapter/Converting CMake.rst:151 Existing Systems To
msgid ""
"That way, each architecture has its own build directory and will not "
"interfere with any other architecture. Remember that not only are the "
"object files kept in the binary directories, but also any configured "
"files that are typically written to the binary tree. Another tree "
"structure found primarily on UNIX projects is one where the binary files "
"for different architectures are kept in subdirectories of the source tree"
" (see below). CMake does not work well with this structure, so we "
"recommend switching to the separate build tree structure shown above."
msgstr "In questo modo, ogni architettura ha la propria directory di build e non interferirà con nessun'altra architettura. Da tenere presente che non solo i file oggetto sono conservati nelle directory binarie, ma anche tutti i file configurati che vengono tipicamente scritti nell'albero binario. Un'altra struttura ad albero che si ritrova principalmente nei progetti UNIX è quella in cui i file binari per diverse architetture sono conservati in sottodirectory dell'albero dei sorgenti (vedere di seguito). CMake non funziona bene con questa struttura, quindi consigliamo di passare alla struttura ad albero di build separata mostrata sopra."

#: ../../source/chapter/Converting CMake.rst:173 Existing Systems To
msgid ""
"CMake provides three variables for controlling where binary targets are "
"written. They are the :variable:`CMAKE_RUNTIME_OUTPUT_DIRECTORY`, "
":variable:`CMAKE_LIBRARY_OUTPUT_DIRECTORY`, and "
":variable:`CMAKE_ARCHIVE_OUTPUT_DIRECTORY` variables. These variables are"
" used to initialize properties of libraries and executables to control "
"where they will be written. Setting these enables a project to place all "
"the libraries and executables into a single directory. For projects with "
"many subdirectories, this can be a real time saver. A typical "
"implementation is shown below:"
msgstr "CMake fornisce tre variabili per controllare dove vengono scritti i target binari. Sono le variabili :variable:`CMAKE_RUNTIME_OUTPUT_DIRECTORY`, :variable:`CMAKE_LIBRARY_OUTPUT_DIRECTORY` e :variable:`CMAKE_ARCHIVE_OUTPUT_DIRECTORY`. Queste variabili vengono utilizzate per inizializzare le proprietà delle librerie e degli eseguibili per controllare dove verranno scritte. L'impostazione di questi consente a un progetto di posizionare tutte le librerie e gli eseguibili in un'unica directory. Per i progetti con molte sottodirectory, questo può essere un vero risparmio di tempo. Un'implementazione tipica è mostrata di seguito:"

#: ../../source/chapter/Converting CMake.rst:193 Existing Systems To
msgid ""
"In this example, all the \"runtime\" binaries will be written to the "
"``bin`` subdirectory of the project's binary tree, including executable "
"files on all platforms and DLLs on Windows.  Other binaries will be "
"written to the ``lib`` directory.  This approach is very useful for "
"projects that make use of shared libraries (DLLs) because it collects all"
" of the shared libraries into one directory. If the executables are "
"placed in the same directory, then they can find the required shared "
"libraries more easily when run on Windows."
msgstr "In questo esempio, tutti i file binari di \"runtime\" verranno scritti nella sottodirectory ``bin`` dell'albero binario del progetto, inclusi i file eseguibili su tutte le piattaforme e le DLL su Windows.  Altri binari verranno scritti nella directory ``lib``.  Questo approccio è molto utile per i progetti che utilizzano librerie condivise [shared] (DLL) perché le raccoglie tutte in una directory. Se gli eseguibili vengono inseriti nella stessa directory, possono trovare più facilmente le librerie condivise richieste quando vengono eseguiti su Windows."

#: ../../source/chapter/Converting CMake.rst:202 Existing Systems To
msgid ""
"One final note on directory structures: with CMake, it is perfectly "
"acceptable to have a project within a project. For example, within the "
"Visualization Toolkit's source tree is a directory that contains a "
"complete copy of the zlib compression library. In writing the CMakeLists "
"file for that library, we use the :command:`project` command to create a "
"project named VTKZLIB even though it is within the VTK source tree and "
"project. This has no real impact on VTK, but it does allow us to build "
"zlib independent of VTK without having to modify its CMakeLists file."
msgstr "Un'ultima nota sulle strutture delle directory: con CMake, è perfettamente accettabile avere un progetto all'interno di un progetto. Ad esempio, all'interno dell'albero dei sorgenti di Visualization Toolkit c'è una directory che contiene una copia completa della libreria di compressione zlib. Nello scrivere il file CMakeLists per quella libreria, usiamo il comando :command:`project` per creare un progetto chiamato VTKZLIB anche se si trova all'interno dell'albero dei sorgenti e del progetto VTK. Ciò non ha alcun impatto reale su VTK, ma ci consente di creare zlib indipendentemente da VTK senza dover modificare il suo file CMakeLists."

#: ../../source/chapter/Converting CMake.rst:213 Existing Systems To
msgid "Useful CMake Commands When Converting Projects"
msgstr "Comandi CMake Utili Durante la Conversione di Progetti"

#: ../../source/chapter/Converting CMake.rst:219 Existing Systems To
msgid ""
"There are a few CMake commands that can make the job of converting an "
"existing project easier and faster. The :command:`file` command with the "
"``GLOB`` argument allows you to quickly set a variable containing a list "
"of all the files that match the glob expression. For example:"
msgstr "Esistono alcuni comandi CMake che possono semplificare e velocizzare il lavoro di conversione di un progetto esistente. Il comando :command:`file` con l'argomento ``GLOB`` consente di impostare rapidamente una variabile contenente un elenco di tutti i file che corrispondono all'espressione glob. Per esempio:"

#: ../../source/chapter/Converting CMake.rst:232 Existing Systems To
msgid ""
"will set the ``SRC_FILES`` variable to a list of all the ``.cxx`` files "
"in the current source directory. It will then create an executable using "
"those source files. Windows developers should be aware that glob matches "
"are case sensitive."
msgstr "imposterà la variabile ``SRC_FILES`` su un elenco di tutti i file ``.cxx`` nella directory corrente dei sorgenti. Creerà quindi un eseguibile utilizzando quei sorgenti. Gli sviluppatori di Windows devono essere consapevoli del fatto che le corrispondenze glob fanno distinzione tra maiuscole e minuscole."

#: ../../source/chapter/Converting CMake.rst:241 Existing Systems To
msgid "Converting UNIX Makefiles"
msgstr "Conversione dei Makefile UNIX"

#: ../../source/chapter/Converting CMake.rst:243 Existing Systems To
msgid ""
"If your project is currently based on standard UNIX Makefiles then their "
"conversion to CMake should be fairly straightforward. Essentially, for "
"every directory in your project that has a Makefile, you will create a "
"matching CMakeLists file. How you handle multiple Makefiles in a "
"directory depends on their function. If the additional Makefiles (or "
"Makefile type files) are simply included in the main Makefile, you can "
"create matching CMake input (.cmake) files and include them into your "
"main CMakeLists file in a similar manner. If the different Makefiles are "
"meant to be invoked on the command line for different situations, "
"consider creating a main CMakeLists file that uses some logic to choose "
"which one to :command:`include` based on a CMake option."
msgstr "Se il progetto è attualmente basato su Makefile UNIX standard, la loro conversione in CMake dovrebbe essere abbastanza semplice. In sostanza, per ogni directory nel progetto che ha un Makefile, si creerà un file CMakeLists corrispondente. Il modo in cui si gestiscono più Makefile in una directory dipende dalla loro funzione. Se i Makefile aggiuntivi (o i file di tipo Makefile) sono semplicemente inclusi nel Makefile principale, è possibile creare file di input CMake corrispondenti (.cmake) e includerli nel file CMakeLists principale allo stesso modo. Se i diversi Makefile devono essere richiamati sulla riga di comando per situazioni diverse, si prenda in considerazione la creazione di un file CMakeLists principale che utilizzi una logica per scegliere quale :command:`include` in base a un'opzione CMake."

#: ../../source/chapter/Converting CMake.rst:255 Existing Systems To
msgid ""
"Frequently Makefiles have a list of object files to compile. These can be"
" converted to CMake variables as follows::"
msgstr "Spesso i Makefile hanno un elenco di file oggetto da compilare. Questi possono essere convertiti in variabili CMake come segue::"

#: ../../source/chapter/Converting CMake.rst:263 Existing Systems To
msgid "becomes"
msgstr "diventa"

#: ../../source/chapter/Converting CMake.rst:273 Existing Systems To
msgid ""
"While the object files are typically listed in a Makefile, in CMake the "
"focus is on the source files. If you used conditional statements in your "
"Makefiles, they can be converted over to CMake :command:`if` commands. "
"Since CMake handles generating dependencies, most dependencies or rules "
"to generate dependencies can be eliminated. Where you have rules to build"
" libraries or executables, replace them with :command:`add_library` or "
":command:`add_executable` commands."
msgstr "Mentre i file oggetto sono in genere elencati in un Makefile, in CMake l'attenzione è sui sorgenti. Se sono usate istruzioni condizionali nei Makefile, possono essere convertite in comandi :command:`if` CMake. Poiché CMake gestisce la generazione delle dipendenze, è possibile eliminare la maggior parte delle dipendenze o delle regole per generarle. Se si hanno regole per creare librerie o eseguibili, si sostituiscono coi comandi :command:`add_library` o :command:`add_executable`."

#: ../../source/chapter/Converting CMake.rst:282 Existing Systems To
msgid ""
"Some UNIX build systems (and source code) make heavy use of the system "
"architecture to determine which files to compile or what flags to use. "
"Typically this information is stored in a Makefile variable called "
"``ARCH`` or ``UNAME``. The first choice in these cases is to replace the "
"architecture-specific code with a more generic test. With some software "
"packages, there is too much architecture specific code for such a change "
"to be reasonable, or you may want to make decisions based on architecture"
" for other reasons. In those cases, you can use the variables "
":variable:`CMAKE_SYSTEM_NAME` and :variable:`CMAKE_SYSTEM_VERSION`. They "
"provide fairly detailed information on the operating system and version "
"of the host computer."
msgstr "Alcuni sistemi di build UNIX (e codice sorgente) fanno un uso massiccio dell'architettura di sistema per determinare quali file compilare o quali flag utilizzare. Tipicamente queste informazioni sono memorizzate in una variabile Makefile chiamata ``ARCH`` o ``UNAME``. La prima scelta in questi casi è sostituire il codice specifico dell'architettura con un test più generico. Con alcuni pacchetti software, c'è troppo codice specifico dell'architettura perché tale modifica sia ragionevole, oppure si potrebbe voler prendere decisioni basate sull'architettura per altri motivi. In questi casi, si possono utilizzare le variabili :variable:`CMAKE_SYSTEM_NAME` e :variable:`CMAKE_SYSTEM_VERSION`. Forniscono informazioni abbastanza dettagliate sul sistema operativo e sulla versione del computer host."

#: ../../source/chapter/Converting CMake.rst:299 Existing Systems To
msgid "Converting Autoconf Based Projects"
msgstr "Conversione di Progetti Basati su Autoconf"

#: ../../source/chapter/Converting CMake.rst:301 Existing Systems To
msgid ""
"Autoconf-based projects primarily consist of three key pieces. The first "
"is the configure.in file which drives the process. The second is "
"Makefile.in which will become the resulting Makefile, and the third piece"
" is the remaining configured files that result from running configure. In"
" converting an autoconf based project to CMake, start with the "
"configure.in and Makefile.in files."
msgstr "I progetti basati su Autoconf consistono principalmente di tre parti chiave. La prima è il file configure.in che guida il processo. La seconda è Makefile.in che diventerà il Makefile risultante, e il terzo pezzo sono i restanti file configurati che risultano dall'esecuzione di configure. Nella conversione di un progetto basato su autoconf in CMake, si inizia con i file configure.in e Makefile.in."

#: ../../source/chapter/Converting CMake.rst:308 Existing Systems To
msgid ""
"The Makefile.in file can be converted to CMake syntax as explained in the"
" preceding section on converting UNIX Makefiles. Once this has been done,"
" convert the configure.in file into CMake syntax. Most functions (macros)"
" in autoconf have corresponding commands in CMake. A short table of some "
"of the basic conversions is listed below:"
msgstr "Il file Makefile.in può essere convertito nella sintassi CMake come spiegato nella sezione precedente sulla conversione dei Makefile UNIX. Fatto ciò, si converte il file configure.in nella sintassi CMake. La maggior parte delle funzioni (macro) in autoconf hanno comandi corrispondenti in CMake. Di seguito è riportata una breve tabella di alcune delle conversioni di base:"

#: ../../source/chapter/Converting CMake.rst:315 Existing Systems To
msgid "**AC_ARG_WITH**"
msgstr "**AC_ARG_WITH**"

#: ../../source/chapter/Converting CMake.rst:315 Existing Systems To
msgid "Use the :command:`option` command."
msgstr "Usa il comando :command:`option`."

#: ../../source/chapter/Converting CMake.rst:319 Existing Systems To
msgid "**AC_CHECK_HEADER**"
msgstr "**AC_CHECK_HEADER**"

#: ../../source/chapter/Converting CMake.rst:318 Existing Systems To
msgid ""
"Use the ``check_include_file`` macro from the :module:`CheckIncludeFile` "
"module."
msgstr "Usa la macro ``check_include_file`` dal modulo :module:`CheckIncludeFile`."

#: ../../source/chapter/Converting CMake.rst:322 Existing Systems To
msgid "**AC_MSG_CHECKING**"
msgstr "**AC_MSG_CHECKING**"

#: ../../source/chapter/Converting CMake.rst:322 Existing Systems To
msgid "Use the :command:`message` command with the ``STATUS`` argument."
msgstr "Usa il comando :command:`message` con l'argomento ``STATUS``."

#: ../../source/chapter/Converting CMake.rst:325 Existing Systems To
msgid "**AC_SUBST**"
msgstr "**AC_SUBST**"

#: ../../source/chapter/Converting CMake.rst:325 Existing Systems To
msgid "Done automatically when using the :command:`configure_file` command."
msgstr "Fatto automaticamente quando si utilizza il comando :command:`configure_file`."

#: ../../source/chapter/Converting CMake.rst:329 Existing Systems To
msgid "**AC_CHECK_LIB**"
msgstr "**AC_CHECK_LIB**"

#: ../../source/chapter/Converting CMake.rst:328 Existing Systems To
msgid ""
"Use the ``check_libary_exists`` macro from the "
":module:`CheckLibraryExists` module."
msgstr "Usa la macro ``check_libary_exists`` dal modulo :module:`CheckLibraryExists`."

#: ../../source/chapter/Converting CMake.rst:332 Existing Systems To
msgid "**AC_CONFIG_SUBDIRS**"
msgstr "**AC_CONFIG_SUBDIRS**"

#: ../../source/chapter/Converting CMake.rst:332 Existing Systems To
msgid "Use the :command:`add_subdirectory` command."
msgstr "Usa il comando :command:`add_subdirectory`."

#: ../../source/chapter/Converting CMake.rst:335 Existing Systems To
msgid "**AC_OUTPUT**"
msgstr "**AC_OUTPUT**"

#: ../../source/chapter/Converting CMake.rst:335 Existing Systems To
msgid "Use the :command:`configure_file` command."
msgstr "Usa il comando :command:`configure_file`."

#: ../../source/chapter/Converting CMake.rst:338 Existing Systems To
msgid "**AC_TRY_COMPILE**"
msgstr "**AC_TRY_COMPILE**"

#: ../../source/chapter/Converting CMake.rst:338 Existing Systems To
msgid "Use the :command:`try_compile` command."
msgstr "Usa il comando :command:`try_compile`."

#: ../../source/chapter/Converting CMake.rst:340 Existing Systems To
msgid ""
"If your configure script performs test compilations using "
"``AC_TRY_COMPILE``, you can use the same code for CMake. Either put it "
"directly into your CMakeLists file if it is short, or preferably put it "
"into a source code file for your project. We typically put such files "
"into a CMake subdirectory for large projects that require such testing."
msgstr "Se lo script di configurazione esegue compilazioni di test utilizzando ``AC_TRY_COMPILE``, si può utilizzare lo stesso codice per CMake. O lo si inserisce direttamente nel file CMakeLists se è breve, o preferibilmente lo si mette in un file di codice sorgente per il progetto. In genere inseriamo tali file in una sottodirectory CMake per progetti di grandi dimensioni che richiedono tali test."

#: ../../source/chapter/Converting CMake.rst:347 Existing Systems To
msgid ""
"Where you are relying on autoconf to configure files, you can use CMake's"
" :command:`configure_file` command. The basic approach is the same and we"
" typically name input files to be configured with a ``.in`` extension "
"just as autoconf does. This command replaces any variables in the input "
"file referenced as ``${VAR}`` or ``@VAR@`` with their values as "
"determined by CMake. If a variable is not defined, it will be replaced "
"with nothing. Optionally, only variables of the form ``@VAR@`` will be "
"replaced and ``${VAR}`` will be ignored. This is useful for configuring "
"files for languages that use ``${VAR}`` as a syntax for evaluating "
"variables. You can also conditionally define variables using the C pre "
"processor by using ``#cmakedefine VAR``. If the variable is defined then "
":command:`configure_file` will convert the ``#cmakedefine`` into a "
"``#define``; if it is not defined, it will become a commented out "
"``#undef``. For example:"
msgstr "Dove ci si affida ad autoconf per configurare i file, si può usare il comando :command:`configure_file` di CMake. L'approccio di base è lo stesso e in genere chiamiamo i file di input da configurare con un'estensione ``.in`` proprio come fa autoconf. Questo comando sostituisce qualsiasi variabile nel file di input indicato come ``${VAR}`` o ``@VAR@`` con i relativi valori determinati da CMake. Se una variabile non è definita, verrà sostituita con niente. Facoltativamente, solo le variabili nella forma ``@VAR@`` verranno sostituite e quelle ``${VAR}`` verranno ignorate. Questo è utile per configurare i file per i linguaggi che usano ``${VAR}`` come sintassi per valutare le variabili. Si possono anche definire condizionalmente le variabili usando il preprocessore C usando ``#cmakedefine VAR``. Se la variabile è definita allora :command:`configure_file` convertirà ``#cmakedefine`` in un ``#define``; se non è definito, diventerà un ``#undef`` commentato. Per esempio:"

#: ../../source/chapter/Converting CMake.rst:379 Existing Systems To
msgid "Converting Windows Based Workspaces"
msgstr "Conversione di Workspace Basati su Windows"

#: ../../source/chapter/Converting CMake.rst:381 Existing Systems To
msgid ""
"To convert a Visual Studio solution to CMake involves a few steps. First "
"you will need to create a CMakeLists file at the top of your source code "
"directory. As always, this file should start with "
":command:`cmake_minimum_required` and :command:`project` command that "
"defines the name of the CMake project. This will become the name of the "
"resulting Visual Studio solution. Next, add all of your source files into"
" CMake variables. For large projects that have multiple directories, "
"create a CMakeLists file in each directory as described in the section on"
" source directory structures at the beginning of this chapter. You will "
"then add your libraries and executables using :command:`add_library` and "
":command:`add_executable`. By default, :command:`add_executable` assumes "
"that your executable is a console application. Adding the ``WIN32`` "
"argument to :command:`add_executable` indicates that it is a Windows "
"application (using WinMain instead of main)."
msgstr "Per convertire una solution di Visual Studio in CMake sono necessari alcuni passaggi. Per prima cosa si dovrà creare un file CMakeLists nella parte superiore della directory del codice sorgente. Come sempre, questo file dovrebbe iniziare col comando :command:`cmake_minimum_required` e :command:`project` che definisce il nome del progetto CMake. Questo diventerà il nome della solution di Visual Studio risultante. Quindi, si aggiungono tutti i file sorgente nelle variabili CMake. Per progetti di grandi dimensioni che dispongono di più directory, creare un file CMakeLists in ciascuna directory come descritto nella sezione sulle strutture delle directory dei sorgenti all'inizio di questo capitolo. Si aggiungeranno poi le librerie e gli eseguibili usando :command:`add_library` e :command:`add_executable`. Per default, :command:`add_executable` presuppone che l'eseguibile sia un'applicazione console. L'aggiunta dell'argomento ``WIN32`` a :command:`add_executable` indica che si tratta di un'applicazione Windows (che utilizza WinMain invece di main)."

#: ../../source/chapter/Converting CMake.rst:396 Existing Systems To
msgid ""
"There are a few nice features that Visual Studio supports and CMake can "
"take advantage of. One is support for class browsing. Typically in CMake,"
" only source files are added to a target, not header files. If you add "
"header files to a target, they will show up in the workspace and then you"
" will be able to browse them as usual. Visual Studio also supports the "
"notion of groups of files. By default, CMake creates groups for source "
"files and header files. Using the :command:`source_group` command, you "
"can create your own groups and assign files to them. If you have any "
"custom build steps in your workspace, these can be added to your "
"CMakeLists files using the :command:`add_custom_command` command. Custom "
"targets (Utility Targets) in Visual Studio can be added with the "
":command:`add_custom_target` command."
msgstr "Ci sono alcune caratteristiche interessanti che Visual Studio supporta e di cui CMake può trarre vantaggio. Uno è il supporto per la navigazione tra le classi. In genere in CMake, solo i file sorgenti vengono aggiunti a un target, non i file header. Se si aggiungono i file header a un target, questi verranno visualizzati nel workspace e si potranno sfogliare come al solito. Visual Studio supporta anche la nozione di gruppi di file. Per default, CMake crea gruppi per file sorgenti e file header. Usando il comando :command:`source_group`, si possono creare i propri gruppi e assegnare loro dei file. Se si hanno passaggi di build personalizzati nel workspace, questi possono essere aggiunti ai file CMakeLists utilizzando il comando :command:`add_custom_command`. I target custom (Utility Target) in Visual Studio possono essere aggiunti con il comando  :command:`add_custom_target`."

#: ../../source/chapter/Cross CMake.rst:2 Compiling With
msgid "Cross Compiling With CMake"
msgstr "Cross Compilazione Con CMake"

#: ../../source/chapter/Cross CMake.rst:4 Compiling With
msgid ""
"Cross-compiling a piece of software means that the software is built on "
"one system, but is intended to run on a different system. The system used"
" to build the software will be called the \"build host,\" and the system "
"for which the software is built will be called the \"target system\" or "
"\"target platform.\" The target system usually runs a different operating"
" system (or none at all) and/or runs on different hardware. A typical use"
" case is in software development for embedded devices like network "
"switches, mobile phones, or engine control units. In these cases, the "
"target platform doesn't have or is not able to run the required software "
"development environment."
msgstr "Cross-compilare un software significa che questo viene compilato su un sistema, ma è destinato a funzionare su un sistema diverso. Il sistema utilizzato per buildare il software sarà chiamato \"build host\" e il sistema per il quale il software è costruito sarà chiamato \"sistema target\" o \"piattaforma target\". Il sistema target di solito esegue un sistema operativo diverso (o nessuno) e/o viene eseguito su hardware diverso. Un caso d'uso tipico è nello sviluppo di software per dispositivi embedded come switch di rete, telefoni cellulari o unità di controllo per motori. In questi casi, la piattaforma target non dispone o non è in grado di eseguire l'ambiente di sviluppo software richiesto."

#: ../../source/chapter/Cross CMake.rst:15 Compiling With
msgid ""
"Cross-compiling is fully supported by CMake, ranging from cross-compiling"
" from Linux to Windows; cross-compiling for supercomputers, through to "
"cross-compiling for small embedded devices without an operating system "
"(OS)."
msgstr "La Cross-compilazione è completamente supportata da CMake, dalla quella da Linux a Windows; cross-compilazione per supercomputer, fino alla cross-compilazione per piccoli dispositivi embedded senza sistema operativo (OS)."

#: ../../source/chapter/Cross CMake.rst:19 Compiling With
msgid "Cross-compiling has several consequences for CMake:"
msgstr "La cross-compilazione ha diverse conseguenze per CMake:"

#: ../../source/chapter/Cross CMake.rst:21 Compiling With
msgid "CMake cannot automatically detect the target platform."
msgstr "CMake non è in grado di rilevare automaticamente la piattaforma target."

#: ../../source/chapter/Cross CMake.rst:22 Compiling With
msgid "CMake cannot find libraries and headers in the default system directories."
msgstr "CMake non riesce a trovare librerie e header nelle directory di sistema di default."

#: ../../source/chapter/Cross CMake.rst:24 Compiling With
msgid "Executables built during cross compiling cannot be executed."
msgstr "Gli eseguibili creati durante la cross-compilazione non possono essere eseguiti."

#: ../../source/chapter/Cross CMake.rst:29 Compiling With
msgid ""
"Cross-compiling support doesn't mean that all CMake-based projects can be"
" magically cross-compiled out-of-the-box (some are), but that CMake "
"separates between information about the build platform and target "
"platform and gives the user mechanisms to solve cross-compiling issues "
"without additional requirements such as running virtual machines, etc."
msgstr "Il supporto cross-compilazione non significa che tutti i progetti basati su CMake possono essere compilati magicamente in modo incrociato (alcuni lo sono), ma che CMake separa le informazioni sulla piattaforma di build e sulla piattaforma target e fornisce all'utente meccanismi per risolvere problemi di cross-compilazione senza requisiti aggiuntivi come l'esecuzione di macchine virtuali, ecc."

#: ../../source/chapter/Cross CMake.rst:35 Compiling With
msgid ""
"To support cross-compiling for a specific software project, CMake must to"
" be told about the target platform via a toolchain file. The "
"CMakeLists.txt may have to be adjusted it is are aware that the build "
"platform may have different properties than the target platform, and it "
"has to deal with the instances where a compiled executable tries to "
"execute on the build host."
msgstr "Per supportare la cross-compilazione per un progetto specifico, è necessario comunicare a CMake la piattaforma target tramite un file toolchain. Potrebbe essere necessario modificare CMakeLists.txt, è consapevole che la piattaforma di build potrebbe avere proprietà diverse rispetto a quella target e deve gestire le istanze in cui un eseguibile compilato tenta di essere eseguito sull'host di build."

#: ../../source/chapter/Cross CMake.rst:47 Compiling With
msgid "Toolchain Files"
msgstr "I File Toolchain"

#: ../../source/chapter/Cross CMake.rst:49 Compiling With
msgid ""
"In order to use CMake for cross-compiling, a CMake file that describes "
"the target platform has to be created, called the \"toolchain file,\" "
"This file tells CMake everything it needs to know about the target "
"platform. Here is an example that uses the MinGW cross-compiler for "
"Windows under Linux; the contents will be explained line-by-line "
"afterwards."
msgstr "Per utilizzare CMake per la cross-compilazione, è necessario creare un file CMake che descriva la piattaforma target, chiamato \"file di toolchain\", questo file dice a CMake tutto ciò che deve sapere sulla piattaforma target. Ecco un esempio che utilizza il cross-compilatore MinGW per Windows sotto Linux; i contenuti verranno spiegati riga per riga in seguito."

#: ../../source/chapter/Cross CMake.rst:77 Compiling With
msgid ""
"Assuming that this file is saved with the name TC-mingw.cmake in your "
"home directory, you instruct CMake to use this file by setting the "
":variable:`CMAKE_TOOLCHAIN_FILE` variable::"
msgstr "Supponendo che questo file sia salvato con il nome TC-mingw.cmake nella home directory, si istruisce CMake a utilizzare questo file impostando la variabile :variable:`CMAKE_TOOLCHAIN_FILE`::"

#: ../../source/chapter/Cross CMake.rst:85 Compiling With
msgid ""
":variable:`CMAKE_TOOLCHAIN_FILE` has to be specified only on the initial "
"CMake run; after that, the results are reused from the CMake cache. You "
"don't need to write a separate toolchain file for every piece of software"
" you want to build. The toolchain files are per target platform; i.e. if "
"you are building several software packages for the same target platform, "
"you only have to write one toolchain file that can be used for all "
"packages."
msgstr ":variable:`CMAKE_TOOLCHAIN_FILE` deve essere specificato solo durante l'esecuzione iniziale di CMake; successivamente, i risultati vengono riutilizzati dalla cache di CMake. Non è necessario scrivere un file di toolchain separato per ogni software che si desidera creare. I file toolchain sono per piattaforma target; cioè se si stanno creando diversi pacchetti software per la stessa piattaforma target, si deve solo scrivere un file toolchain che possa essere utilizzato per tutti i pacchetti."

#: ../../source/chapter/Cross CMake.rst:93 Compiling With
msgid ""
"What do the settings in the toolchain file mean? We will examine them "
"one-by-one. Since CMake cannot guess the target operating system or "
"hardware, you have to set the following CMake variables:"
msgstr "Cosa significano le impostazioni nel file toolchain? Li esamineremo una per una. Poiché CMake non è in grado di indovinare il sistema operativo o l'hardware target, è necessario impostare le seguenti variabili CMake:"

#: ../../source/chapter/Cross CMake.rst:110 Compiling With
msgid ":variable:`CMAKE_SYSTEM_NAME`"
msgstr ":variable:`CMAKE_SYSTEM_NAME`"

#: ../../source/chapter/Cross CMake.rst:98 Compiling With
msgid ""
"This variable is mandatory; it sets the name of the target system, i.e. "
"to the same value as ``CMAKE_SYSTEM_NAME`` would have if CMake were run "
"on the target system. Typical examples are \"Linux\" and \"Windows.\" It "
"is used for constructing the file names of the platform files like "
"Linux.cmake or Windows-gcc.cmake. If your target is an embedded system "
"without an OS, set ``CMAKE_SYSTEM_NAME`` to \"Generic.\" Presetting "
"``CMAKE_SYSTEM_NAME`` this way instead of being detected, automatically "
"causes CMake to consider the build a cross-compiling build and the CMake "
"variable :variable:`CMAKE_CROSSCOMPILING` will be set to TRUE. "
"``CMAKE_CROSSCOMPILING`` is the variable that should be tested in CMake "
"files to determine whether the current build is a cross-compiled build or"
" not."
msgstr "Questa variabile è obbligatoria; imposta il nome del sistema target, ovvero allo stesso valore che ``CMAKE_SYSTEM_NAME`` avrebbe se CMake fosse eseguito sul sistema target. Esempi tipici sono \"Linux\" e \"Windows\". Viene utilizzato per costruire i nomi dei file della piattaforma come Linux.cmake o Windows-gcc.cmake. Se il target è un sistema embedded senza sistema operativo, si imposta ``CMAKE_SYSTEM_NAME`` su \"Generic\". La preimpostazione di ``CMAKE_SYSTEM_NAME`` in questo modo, invece di essere rilevata, fa sì che CMake consideri automaticamente la build una cross-compilazione e la variabile CMake :variable:`CMAKE_CROSSCOMPILING` verrà impostata su TRUE. ``CMAKE_CROSSCOMPILING`` è la variabile che dovrebbe essere testata nei file CMake per determinare se la build corrente è una build cross-compilata o meno."

#: ../../source/chapter/Cross CMake.rst:113 Compiling With
msgid ":variable:`CMAKE_SYSTEM_VERSION`"
msgstr ":variable:`CMAKE_SYSTEM_VERSION`"

#: ../../source/chapter/Cross CMake.rst:113 Compiling With
msgid "Sets the version of your target system."
msgstr "Imposta la versione del sistema target."

#: ../../source/chapter/Cross CMake.rst:123 Compiling With
msgid ":variable:`CMAKE_SYSTEM_PROCESSOR`"
msgstr ":variable:`CMAKE_SYSTEM_PROCESSOR`"

#: ../../source/chapter/Cross CMake.rst:116 Compiling With
msgid ""
"This variable is optional; it sets the processor or hardware name of the "
"target system. It is used in CMake for one purpose, to load the "
"``${CMAKE_SYSTEM_NAME}-COMPILER_ID-${CMAKE_SYSTEM_PROCESSOR}.cmake`` "
"file. This file can be used to modify settings such as compiler flags for"
" the target. You should only have to set this variable if you are using a"
" cross-compiler where each target needs special build settings. The value"
" can be chosen freely, so it could be, for example, i386, IntelPXA255, or"
" MyControlBoardRev42."
msgstr "Questa variabile è facoltativa; imposta il nome del processore o dell'hardware del sistema target. Viene utilizzato in CMake per uno scopo, per caricare il file ``${CMAKE_SYSTEM_NAME}-COMPILER_ID-${CMAKE_SYSTEM_PROCESSOR}.cmake``. Questo file può essere utilizzato per modificare impostazioni come i flag del compilatore per il target. Si deve impostare questa variabile solo se si sta usando un cross-compilatore in cui ogni target necessita di impostazioni di build speciali. Il valore può essere scelto liberamente, quindi potrebbe essere, ad esempio, i386, IntelPXA255 o MyControlBoardRev42."

#: ../../source/chapter/Cross CMake.rst:125 Compiling With
msgid ""
"In CMake code, the ``CMAKE_SYSTEM_XXX`` variables always describe the "
"target platform. The same is true for the short :variable:`WIN32`, "
":variable:`UNIX`, :variable:`APPLE` variables. These variables can be "
"used to test the properties of the target. If it is necessary to test the"
" build host system, there is a corresponding set of variables: "
":variable:`CMAKE_HOST_SYSTEM`, :variable:`CMAKE_HOST_SYSTEM_NAME`, "
":variable:`CMAKE_HOST_SYSTEM_VERSION`, "
":variable:`CMAKE_HOST_SYSTEM_PROCESSOR`; and also the short forms: "
":variable:`CMAKE_HOST_WIN32`, :variable:`CMAKE_HOST_UNIX` and "
":variable:`CMAKE_HOST_APPLE`."
msgstr "Nel codice CMake, le variabili ``CMAKE_SYSTEM_XXX`` descrivono sempre la piattaforma target. Lo stesso vale per le variabili brevi :variable:`WIN32`, :variable:`UNIX`, :variable:`APPLE`. Queste variabili possono essere utilizzate per testare le proprietà del target. Se è necessario testare il sistema host di build, esiste un insieme corrispondente di variabili: :variable:`CMAKE_HOST_SYSTEM`, :variable:`CMAKE_HOST_SYSTEM_NAME`, :variable:`CMAKE_HOST_SYSTEM_VERSION`, :variable:`CMAKE_HOST_SYSTEM_PROCESSOR`; e anche le forme abbreviate: :variable:`CMAKE_HOST_WIN32`, :variable:`CMAKE_HOST_UNIX` e :variable:`CMAKE_HOST_APPLE`."

#: ../../source/chapter/Cross CMake.rst:135 Compiling With
msgid ""
"Since CMake cannot guess the target system, it cannot guess which "
"compiler it should use. Setting the following variables defines what "
"compilers to use for the target system."
msgstr "Poiché CMake non può indovinare il sistema target, non può indovinare quale compilatore dovrebbe usare. L'impostazione delle seguenti variabili definisce quali compilatori utilizzare per il sistema target."

#: ../../source/chapter/Cross CMake.rst:150 Compiling With
msgid ":variable:`CMAKE_C_COMPILER <CMAKE_<LANG>_COMPILER>`"
msgstr ":variable:`CMAKE_C_COMPILER <CMAKE_<LANG>_COMPILER>`"

#: ../../source/chapter/Cross CMake.rst:140 Compiling With
msgid ""
"This specifies the C compiler executable as either a full path or just "
"the filename. If it is specified with full path, then this path will be "
"preferred when searching for the C++ compiler and the other tools "
"(binutils, linker, etc.). If the compiler is a GNU cross-compiler with a "
"prefixed name (e.g. \"arm-elf-gcc\"), CMake will detect this and "
"automatically find the corresponding C++ compiler (i.e. \"arm-elf-c++\")."
" The compiler can also be set via the ``CC`` environment variable. "
"Setting ``CMAKE_C_COMPILER`` directly in a toolchain file has the "
"advantage that the information about the target system is completely "
"contained in this file, and it does not depend on environment variables."
msgstr "Questa specifica l'eseguibile del compilatore C come path completo o solo come nome file. Se viene specificato con il path completo, questo sarà preferito durante la ricerca del compilatore C++ e degli altri tool (binutils, linker, ecc.). Se il compilatore è un cross-compilatore GNU con un nome prefisso (ad esempio \"arm-elf-gcc\"), CMake lo rileverà e troverà automaticamente il compilatore C++ corrispondente (ad esempio \"arm-elf-c++\"). Il compilatore può anche essere impostato tramite la variabile d'ambiente ``CC``. L'impostazione di ``CMAKE_C_COMPILER`` direttamente in un file di toolchain ha il vantaggio che le informazioni sul sistema target sono completamente contenute in questo file e non dipendono dalle variabili di ambiente."

#: ../../source/chapter/Cross CMake.rst:159 Compiling With
msgid ":variable:`CMAKE_CXX_COMPILER <CMAKE_<LANG>_COMPILER>`"
msgstr ":variable:`CMAKE_CXX_COMPILER <CMAKE_<LANG>_COMPILER>`"

#: ../../source/chapter/Cross CMake.rst:153 Compiling With
msgid ""
"This specifies the C++ compiler executable as either a full path or just "
"the filename. It is handled the same way as ``CMAKE_C_COMPILER``. If the "
"toolchain is a GNU toolchain, it should suffice to set only "
"``CMAKE_C_COMPILER``; CMake should find the corresponding C++ compiler "
"automatically. As for ``CMAKE_C_COMPILER``, also for C++ the compiler can"
" be set via the ``CXX`` environment variable."
msgstr "Questa specifica l'eseguibile del compilatore C come path completo o solo come nome file. Viene gestito allo stesso modo di ``CMAKE_C_COMPILER``. Se la toolchain è una toolchain GNU, dovrebbe essere sufficiente impostare solo ``CMAKE_C_COMPILER``; CMake dovrebbe trovare automaticamente il compilatore C++ corrispondente. Come per ``CMAKE_C_COMPILER``, anche per C++ il compilatore può essere impostato tramite la variabile d'ambiente ``CXX``."

#: ../../source/chapter/Cross CMake.rst:162 Compiling With
msgid "Finding External Libraries, Programs and Other Files"
msgstr "Ricerca di Librerie Esterne, Programmi e Altri File"

#: ../../source/chapter/Cross CMake.rst:164 Compiling With
msgid ""
"Most non-trivial projects make use of external libraries or tools. CMake "
"offers the :command:`find_program`, :command:`find_library`, "
":command:`find_file`, :command:`find_path`, and :command:`find_package` "
"commands for this purpose. They search the file system in common places "
"for these files and return the results. :command:`find_package` is a bit "
"different in that it does not actually search itself, but executes "
"``Find<*>.cmake`` modules, which in turn call the "
":command:`find_program`, :command:`find_library`, :command:`find_file`, "
"and :command:`find_path` commands."
msgstr "La maggior parte dei progetti non banali fa uso di librerie o tool esterni. CMake offre i comandi :command:`find_program`, :command:`find_library`, :command:`find_file`, :command:`find_path` e :command:`find_package` per questo scopo. Cercano questi file nel file system in luoghi comuni e restituiscono i risultati. :command:`find_package` è un po' diverso in quanto in realtà non cerca se stesso, ma esegue i moduli ``Find<*>.cmake``, che a loro volta chiamano i comandi :command:`find_program`, :command:`find_library`, :command:`find_file` e :command:`find_path`."

#: ../../source/chapter/Cross CMake.rst:174 Compiling With
msgid ""
"When cross-compiling, these commands become more complicated. For "
"example, when cross-compiling to Windows on a Linux system, getting "
"``/usr/lib/libjpeg.so``` as the result of the command "
":command:`find_package(JPEG)` would be useless, since this would be the "
"JPEG library for the host system and not the target system. In some "
"cases, you want to find files that are meant for the target platform; in "
"other cases you will want to find files for the build host. The following"
" variables are designed to give you the flexibility to change how the "
"typical find commands in CMake work, so that you can find both build host"
" and target files as necessary."
msgstr "Durante la cross-compilazione, questi comandi diventano più complicati. Ad esempio, durante la cross-compilazione su Windows su un sistema Linux, ottenere ``/usr/lib/libjpeg.so`` come risultato del comando :command:`find_package(JPEG)` sarebbe inutile, poiché questa sarebbe la libreria JPEG per il sistema host e non il sistema target. In alcuni casi, si desidera trovare file destinati alla piattaforma target; in altri casi si vorranno trovare i file per l'host di build. Le seguenti variabili sono progettate per dare la flessibilità di modificare il modo in cui funzionano i tipici comandi di ricerca in CMake, in modo da poter trovare sia l'host di build che i file target, se necessario."

#: ../../source/chapter/Cross CMake.rst:185 Compiling With
msgid ""
"The toolchain will come with its own set of libraries and headers for the"
" target platform, which are usually installed under a common prefix. It "
"is a good idea to set up a directory where all the software that is built"
" for the target platform will be installed, so that the software packages"
" don't get mixed up with the libraries that come with the toolchain."
msgstr "La toolchain verrà fornita con il proprio set di librerie e header per la piattaforma target, che di solito sono installate con un prefisso comune. È una buona idea impostare una directory in cui verrà installato tutto il software creato per la piattaforma target, in modo che i pacchetti software non vengano confusi con le librerie fornite con la toolchain."

#: ../../source/chapter/Cross CMake.rst:192 Compiling With
msgid ""
"The :command:`find_program` command is typically used to find a program "
"that will be executed during the build, so this should still search in "
"the host file system, and not in the environment of the target platform. "
":command:`find_library` is normally used to find a library that is then "
"used for linking purposes, so this command should only search in the "
"target environment. For :command:`find_path` and :command:`find_file`, it"
" is not so obvious; in many cases, they are used to search for headers, "
"so by default they should only search in the target environment. The "
"following CMake variables can be set to adjust the behavior of the find "
"commands for cross-compiling."
msgstr "Il comando :command:`find_program` viene in genere utilizzato per trovare un programma che verrà eseguito durante la compilazione, quindi questo dovrebbe comunque cercare nel file system host e non nell'ambiente della piattaforma target. :command:`find_library` viene normalmente utilizzato per trovare una libreria che viene poi utilizzata per scopi di collegamento, quindi questo comando dovrebbe cercare solo nell'ambiente target. Per :command:`find_path` e :command:`find_file`, non è così ovvio; in molti casi, vengono utilizzati per cercare header, quindi per default dovrebbero cercare solo nell'ambiente target. Le seguenti variabili CMake possono essere impostate per regolare il comportamento dei comandi find per la cross-compilazione."

#: ../../source/chapter/Cross CMake.rst:227 Compiling With
msgid ":variable:`CMAKE_FIND_ROOT_PATH`"
msgstr ":variable:`CMAKE_FIND_ROOT_PATH`"

#: ../../source/chapter/Cross CMake.rst:204 Compiling With
msgid ""
"This is a list of the directories that contain the target environment. "
"Each of the directories listed here will be prepended to each of the "
"search directories of every find command. Assuming your target "
"environment is installed under ``/opt/eldk/ppc_74xx`` and your "
"installation for that target platform goes to ``~/install-eldk-ppc74xx``,"
" set :variable:`CMAKE_FIND_ROOT_PATH` to these two directories. Then "
"``find_library(JPEG_LIB jpeg)`` will search in "
"``/opt/eldk/ppc_74xx/lib``, ``/opt/eldk/ppc_74xx/usr/lib``, ``~/install-"
"eldk-ppc74xx/lib``, ``~/install-eldk-ppc74xx/usr/lib``, and should result"
" in ``/opt/eldk/ppc_74xx/usr/lib/libjpeg.so``."
msgstr "Questo è un elenco delle directory che contengono l'ambiente target. Ognuna delle directory elencate qui verrà anteposta a ciascuna delle directory di ricerca di ogni comando find. Supponendo che l'ambiente target sia installato in ``/opt/eldk/ppc_74xx`` e che l'installazione per quella piattaforma target vada in ``~/install-eldk-ppc74xx``, si imposta :variable:`CMAKE_FIND_ROOT_PATH` con queste due directory. Poi ``find_library(JPEG_LIB jpeg)`` cercherà in ``/opt/eldk/ppc_74xx/lib``, ``/opt/eldk/ppc_74xx/usr/lib``, ``~/install-eldk-ppc74xx/lib``, ``~/install-eldk-ppc74xx/usr/lib`` e dovrebbe risultare in ``/opt/eldk/ppc_74xx/usr/lib/libjpeg.so``."

#: ../../source/chapter/Cross CMake.rst:215 Compiling With
msgid ""
"By default, :variable:`CMAKE_FIND_ROOT_PATH` is empty. If set, first the "
"directories prefixed with the path given in "
":variable:`CMAKE_FIND_ROOT_PATH` will be searched, and then the "
"unprefixed versions of the same directories will be searched."
msgstr "Per default, :variable:`CMAKE_FIND_ROOT_PATH` è vuota. Se impostata, verranno cercate prima le directory con il prefisso del percorso fornito in :variable:`CMAKE_FIND_ROOT_PATH`, poi verranno cercate le versioni senza prefisso delle stesse directory."

#: ../../source/chapter/Cross CMake.rst:220 Compiling With
msgid ""
"By setting this variable, you are basically adding a new set of search "
"prefixes to all of the find commands in CMake, but for some find commands"
" you may not want to search the target or host directories. You can "
"control how each find command invocation works by passing in one of the "
"three following options ``NO_CMAKE_FIND_ROOT_PATH``, "
"``ONLY_CMAKE_FIND_ROOT_PATH``, or ``CMAKE_FIND_ROOT_PATH_BOTH`` when you "
"call it. You can also control how the find commands work using the "
"following three variables."
msgstr "Impostando questa variabile, in pratica si sta aggiungendo un nuovo set di prefissi di ricerca a tutti i comandi di ricerca in CMake, ma per alcuni comandi di ricerca si potrebbe non voler cercare nelle directory target o dell'host. Si può controllare come funziona ogni invocazione del comando find passando una delle tre seguenti opzioni ``NO_CMAKE_FIND_ROOT_PATH``, ``ONLY_CMAKE_FIND_ROOT_PATH`` o ``CMAKE_FIND_ROOT_PATH_BOTH`` quando lo si chiama. Si può anche controllare come funzionano i comandi find usando le seguenti tre variabili."

#: ../../source/chapter/Cross CMake.rst:244 Compiling With
msgid ":variable:`CMAKE_FIND_ROOT_PATH_MODE_PROGRAM`"
msgstr ":variable:`CMAKE_FIND_ROOT_PATH_MODE_PROGRAM`"

#: ../../source/chapter/Cross CMake.rst:230 Compiling With
msgid ""
"This sets the default behavior for the :command:`find_program` command. "
"It can be set to NEVER, ONLY, or BOTH. When set to NEVER, "
":variable:`CMAKE_FIND_ROOT_PATH` will not be used for "
":command:`find_program` calls except where it is enabled explicitly. If "
"set to ONLY, only the search directories with the prefixes coming from "
":variable:`CMAKE_FIND_ROOT_PATH` will be used by :command:`find_program`."
" The default is BOTH, which means that first the prefixed directories and"
" then the unprefixed directories, will be searched."
msgstr "Questo imposta il comportamento di default per il comando :command:`find_program`. Può essere impostato su NEVER, ONLY o BOTH. Quando impostato su NEVER, :variable:`CMAKE_FIND_ROOT_PATH` non verrà utilizzato per le chiamate :command:`find_program` tranne dove è abilitato esplicitamente. Se impostato su ONLY, solo le directory di ricerca con i prefissi provenienti da :variable:`CMAKE_FIND_ROOT_PATH` saranno usate da :command:`find_program`. Il default è BOTH, il che significa che verranno cercate prima le directory con prefisso e poi quelle senza prefisso."

#: ../../source/chapter/Cross CMake.rst:239 Compiling With
msgid ""
"In most cases, :command:`find_program` is used to search for an "
"executable which will then be executed, e.g. using "
":command:`execute_process` or :command:`add_custom_command`. So in most "
"cases an executable from the build host is required, so setting "
":variable:`CMAKE_FIND_ROOT_PATH_MODE_PROGRAM` to NEVER is normally "
"preferred."
msgstr "Nella maggior parte dei casi, :command:`find_program` viene utilizzato per cercare un eseguibile che verrà poi eseguito, ad es. utilizzando :command:`execute_process` o :command:`add_custom_command`. Quindi nella maggior parte dei casi è richiesto un eseguibile dall'host di build, quindi è preferibile impostare :variable:`CMAKE_FIND_ROOT_PATH_MODE_PROGRAM` a NEVER."

#: ../../source/chapter/Cross CMake.rst:250 Compiling With
msgid ":variable:`CMAKE_FIND_ROOT_PATH_MODE_LIBRARY`"
msgstr ":variable:`CMAKE_FIND_ROOT_PATH_MODE_LIBRARY`"

#: ../../source/chapter/Cross CMake.rst:247 Compiling With
msgid ""
"This is the same as above, but for the :command:`find_library` command. "
"In most cases this is used to find a library which will then be used for "
"linking, so a library for the target is required. In most cases, it "
"should be set to ONLY."
msgstr "Questo è lo stesso di sopra, ma per il comando :command:`find_library`. Nella maggior parte dei casi questo viene utilizzato per trovare una libreria che verrà poi utilizzata per il link, quindi è necessaria una libreria per il target. Nella maggior parte dei casi, dovrebbe essere impostato su ONLY."

#: ../../source/chapter/Cross CMake.rst:261 Compiling With
msgid ":variable:`CMAKE_FIND_ROOT_PATH_MODE_INCLUDE`"
msgstr ":variable:`CMAKE_FIND_ROOT_PATH_MODE_INCLUDE`"

#: ../../source/chapter/Cross CMake.rst:253 Compiling With
msgid ""
"This is the same as above and used for both :command:`find_path` and "
":command:`find_file`. In most cases, this is used for finding include "
"directories, so the target environment should be searched. In most cases,"
" it should be set to ONLY. If you also need to find files in the file "
"system of the build host (e.g. some data files that will be processed "
"during the build); you may need to adjust the behavior for those "
":command:`find_path` or :command:`find_file` calls using the "
"``NO_CMAKE_FIND_ROOT_PATH``, ``ONLY_CMAKE_FIND_ROOT_PATH`` and "
"``CMAKE_FIND_ROOT_PATH_BOTH`` options."
msgstr "Questo è lo stesso di sopra e utilizzato sia per :command:`find_path` che per :command:`find_file`. Nella maggior parte dei casi, viene utilizzato per trovare le directory include, quindi la ricerca deve essere eseguita nell'ambiente target. Nella maggior parte dei casi, dovrebbe essere impostato su ONLY. Se c'è anche bisogno di trovare file nel file system dell'host di build (ad esempio alcuni file di dati che verranno elaborati durante la build); potrebbe essere necessario modificare il comportamento per quelle chiamate a :command:`find_path` o a :command:`find_file` utilizzando le opzioni ``NO_CMAKE_FIND_ROOT_PATH``, ``ONLY_CMAKE_FIND_ROOT_PATH`` e ``CMAKE_FIND_ROOT_PATH_BOTH``."

#: ../../source/chapter/Cross CMake.rst:263 Compiling With
msgid ""
"With a toolchain file set up as described, CMake now knows how to handle "
"the target platform and the cross-compiler. We should now able to build "
"software for the target platform. For complex projects, there are more "
"issues that must to be taken care of."
msgstr "Con un file di toolchain impostato come descritto, CMake ora sa come gestire la piattaforma target e il cross-compilatore. Ora dovremmo essere in grado di creare software per la piattaforma target. Per progetti complessi, ci sono più problemi che devono essere risolti."

#: ../../source/chapter/Cross ../../source/chapter/System CMake.rst:272
#: Compiling Inspection.rst:2 With
msgid "System Inspection"
msgstr "Ispezione del Sistema"

#: ../../source/chapter/Cross CMake.rst:274 Compiling With
msgid ""
"Most portable software projects have a set of system inspection tests for"
" determining the properties of the (target) system. The simplest way to "
"check for a system feature with CMake is by testing variables. For this "
"purpose, CMake provides the variables :variable:`UNIX`, "
":variable:`WIN32`, and :variable:`APPLE`. When cross-compiling, these "
"variables apply to the target platform, for testing the build host "
"platform there are corresponding variables :variable:`CMAKE_HOST_UNIX`, "
":variable:`CMAKE_HOST_WIN32`, and :variable:`CMAKE_HOST_APPLE`."
msgstr "La maggior parte dei progetti software portabili dispone di una serie di test di ispezione del sistema per determinarne le proprietà (del target). Il modo più semplice per verificare una funzionalità di sistema con CMake è testare le variabili. A tale scopo, CMake fornisce le variabili :variable:`UNIX`, :variable:`WIN32` e :variable:`APPLE`. Durante la cross-compilazione, queste variabili si applicano alla piattaforma target, per testare la piattaforma host di build ci sono variabili corrispondenti :variable:`CMAKE_HOST_UNIX`, :variable:`CMAKE_HOST_WIN32` e :variable:`CMAKE_HOST_APPLE`."

#: ../../source/chapter/Cross CMake.rst:284 Compiling With
msgid ""
"If this granularity is too coarse, the variables "
":variable:`CMAKE_SYSTEM_NAME`, :variable:`CMAKE_SYSTEM`, "
":variable:`CMAKE_SYSTEM_VERSION`, and :variable:`CMAKE_SYSTEM_PROCESSOR` "
"can be tested, along with their counterparts "
":variable:`CMAKE_HOST_SYSTEM_NAME`, :variable:`CMAKE_HOST_SYSTEM`, "
":variable:`CMAKE_HOST_SYSTEM_VERSION`, and "
":variable:`CMAKE_HOST_SYSTEM_PROCESSOR`, which contain the same "
"information, but for the build host and not for the target system."
msgstr "Se questa granularità è troppo grossolana, si possono testare le variabili :variable:`CMAKE_SYSTEM_NAME`, :variable:`CMAKE_SYSTEM`, :variable:`CMAKE_SYSTEM_VERSION` e :variable:`CMAKE_SYSTEM_PROCESSOR`, insieme alle loro controparti :variable:`CMAKE_HOST_SYSTEM_NAME`, :variable:`CMAKE_HOST_SYSTEM`, :variable:`CMAKE_HOST_SYSTEM_VERSION` e :variable:`CMAKE_HOST_SYSTEM_PROCESSOR`, che contengono le stesse informazioni, ma per l'host di build e non per il sistema target."

#: ../../source/chapter/Cross CMake.rst:304 Compiling With
msgid "Using Compile Checks"
msgstr "Utilizzo dei Controlli di Compilazione"

#: ../../source/chapter/Cross CMake.rst:306 Compiling With
msgid ""
"In CMake, there are macros such as :module:`check_include_files "
"<CheckIncludeFiles>` and :module:`check_c_source_runs <CheckCSourceRuns>`"
" that are used to test the properties of the platform. Most of these "
"macros internally use either the :command:`try_compile` or the "
":command:`try_run` commands. The :command:`try_compile` command works as "
"expected when cross-compiling; it tries to compile the piece of code with"
" the cross-compiling toolchain, which will give the expected result."
msgstr "In CMake, ci sono macro come :module:`check_include_files <CheckIncludeFiles>` e :module:`check_c_source_runs <CheckCSourceRuns>` che vengono utilizzate per testare le proprietà della piattaforma. La maggior parte di queste macro utilizza internamente il comando :command:`try_compile` o il :command:`try_run`. Il comando :command:`try_compile` funziona come previsto durante la cross-compilazione; tenta di compilare il pezzo di codice con la toolchain di cross-compilazione, che darà il risultato atteso."

#: ../../source/chapter/Cross CMake.rst:315 Compiling With
msgid ""
"All tests using :command:`try_run` will not work since the created "
"executables cannot normally run on the build host. In some cases, this "
"might be possible (e.g. using virtual machines, emulation layers like "
"Wine or interfaces to the actual target) as CMake does not depend on such"
" mechanisms. Depending on emulators during the build process would "
"introduce a new set of potential problems; they may have a different view"
" on the file system, use other line endings, require special hardware or "
"software, etc."
msgstr "Tutti i test che utilizzano :command:`try_run` non funzioneranno poiché gli eseguibili creati normalmente non possono essere eseguiti sull'host di build. In alcuni casi, ciò potrebbe essere possibile (ad esempio utilizzando macchine virtuali, layer di emulazione come Wine o interfacce al target effettivo) poiché CMake non dipende da tali meccanismi. La dipendenza dagli emulatori durante il processo di build introdurrebbe una nuova serie di potenziali problemi; possono avere una visione diversa del file system, utilizzare altre terminazioni di riga, richiedere hardware o software speciali, ecc."

#: ../../source/chapter/Cross CMake.rst:324 Compiling With
msgid ""
"If :command:`try_run` is invoked when cross-compiling, it will first try "
"to compile the software, which will work the same way as when not cross "
"compiling. If this succeeds, it will check the variable "
":variable:`CMAKE_CROSSCOMPILING` to determine whether the resulting "
"executable can be executed or not. If it cannot, it will create two cache"
" variables, which then have to be set by the user or via the CMake cache."
" Assume the command looks like this:"
msgstr "Se :command:`try_run` viene invocato durante la cross-compilazione, proverà prima a compilare il software, che funzionerà allo stesso modo di quando non si esegue la cross-compilazione. Se ciò riesce, controllerà la variabile :variable:`CMAKE_CROSSCOMPILING` per determinare se l'eseguibile risultante può essere eseguito o meno. In caso contrario, creerà due variabili di cache, che dovranno essere impostate dall'utente o tramite la cache di CMake. Supponiamo che il comando assomigli a questo:"

#: ../../source/chapter/Cross CMake.rst:345 Compiling With
msgid ""
"In this example, the source file ``SharedLibraryPathInfo.cxx`` will be "
"compiled and if that succeeds, the resulting executable should be "
"executed. The variable ``SHARED_LIBRARY_PATH_INFO_COMPILED`` will be set "
"to the result of the build, i.e. TRUE or FALSE. CMake will create a cache"
" variable ``SHARED_LIBRARY_PATH_TYPE`` and preset it to "
"``PLEASE_FILL_OUT-FAILED_TO_RUN``. This variable must be set to what the "
"exit code of the executable would have been if it had been executed on "
"the target. Additionally, CMake will create a cache variable "
"``SHARED_LIBRARY_PATH_TYPE__TRYRUN_OUTPUT`` and preset it to "
"``PLEASE_FILL_OUT-NOTFOUND``. This variable should be set to the output "
"that the executable prints to stdout and stderr if it were executed on "
"the target. This variable is only created if the :command:`try_run` "
"command was used with the ``RUN_OUTPUT_VARIABLE`` or the "
"``OUTPUT_VARIABLE`` argument. You have to fill in the appropriate values "
"for these variables. To help you with this CMake tries its best to give "
"you useful information. To accomplish this CMake creates a file "
"``${CMAKE_BINARY_DIR}/TryRunResults.cmake``, which you can see an example"
" of here:"
msgstr "In questo esempio, il file sorgente ``SharedLibraryPathInfo.cxx`` verrà compilato e, se l'operazione riesce, l'eseguibile risultante dovrebbe essere eseguito. La variabile ``SHARED_LIBRARY_PATH_INFO_COMPILED`` verrà impostata sul risultato della compilazione, ovvero TRUE o FALSE. CMake creerà una variabile cache ``SHARED_LIBRARY_PATH_TYPE`` e la preimposta su ``PLEASE_FILL_OUT-FAILED_TO_RUN``. Questa variabile deve essere impostata su quello che sarebbe stato il codice di uscita dell'eseguibile se fosse stato eseguito sul target. Inoltre, CMake creerà una variabile cache ``SHARED_LIBRARY_PATH_TYPE__TRYRUN_OUTPUT`` preimpostandola su ``PLEASE_FILL_OUT-NOTFOUND``. Questa variabile deve essere impostata sull'output che l'eseguibile stampa su stdout e stderr se è stato eseguito sul target. Questa variabile viene creata solo se il comando :command:`try_run` è stato utilizzato con l'argomento ``RUN_OUTPUT_VARIABLE`` o con ``OUTPUT_VARIABLE``. Si devono inserire i valori appropriati per queste variabili. Per aiutare con questo, CMake fa del suo meglio per dare informazioni utili. Per fare questo CMake crea un file ``${CMAKE_BINARY_DIR}/TryRunResults.cmake``, di cui si può vedere un esempio qui:"

#: ../../source/chapter/Cross CMake.rst:394 Compiling With
msgid ""
"You can find all of the variables that CMake could not determine, from "
"which CMake file they were called, the source file, the arguments for the"
" executable, and the path to the executable. CMake will also copy the "
"executables to the build directory; they have the names "
"``cmTryCompileExec-<name of the variable>``, e.g. in this case "
"``cmTryCompileExec-SHARED_LIBRARY_PATH_TYPE``. You can then try to run "
"this executable manually on the actual target platform and check the "
"results."
msgstr "Si possono trovare tutte le variabili che CMake non è stato in grado di determinare, da quale file CMake sono state chiamate, il file sorgente, gli argomenti per l'eseguibile e il path dell'eseguibile. CMake copierà anche gli eseguibili nella directory di build; hanno i nomi ``cmTryCompileExec-<nome della variabile>``, ad es. in questo caso ``cmTryCompileExec-SHARED_LIBRARY_PATH_TYPE``. Si può quindi provare a eseguire questo eseguibile manualmente sulla piattaforma target effettiva e controllare i risultati."

#: ../../source/chapter/Cross CMake.rst:403 Compiling With
msgid ""
"Once you have these results, they have to be put into the CMake cache. "
"This can be done by using ccmake or cmake-gui. and editing the variables "
"directly in the cache. It is not possible to reuse these changes in "
"another build directory or if CMakeCache.txt is removed."
msgstr "Una volta ottenuti questi risultati, devono essere inseriti nella cache di CMake. Questo può essere fatto usando ccmake o cmake-gui, e modificando le variabili direttamente nella cache. Non è possibile riutilizzare queste modifiche in un'altra directory di build o se CMakeCache.txt viene rimosso."

#: ../../source/chapter/Cross CMake.rst:409 Compiling With
msgid ""
"The recommended approach is to use the TryRunResults.cmake file created "
"by CMake. You should copy it to a safe location (i.e. where it will not "
"be removed if the build directory is deleted) and give it a useful name, "
"e.g. TryRunResults-MyProject-eldk-ppc.cmake. The contents of this file "
"have to be edited so that the set commands set the required variables to "
"the appropriate values for the target system. This file can then be used "
"to preload the CMake cache by using the -C option of cmake::"
msgstr "L'approccio consigliato consiste nell'usare il file TryRunResults.cmake creato da CMake. Lo si dovrebbe copiare in una posizione sicura (ovvero dove non verrà rimosso se la directory di build viene eliminata) e assegnargli un nome utile, ad es. TryRunResults-MyProject-eldk-ppc.cmake. Il contenuto di questo file deve essere modificato in modo che i comandi set impostino le variabili richieste sui valori appropriati per il sistema target. Questo file può quindi essere utilizzato per precaricare la cache di CMake utilizzando l'opzione -C di cmake::"

#: ../../source/chapter/Cross CMake.rst:420 Compiling With
msgid ""
"You do not have to use the other CMake options again as they are now in "
"the cache. This way you can use MyProjectTryRunResults-eldk-ppc.cmake in "
"multiple build trees, and it can be distributed with your project so that"
" it is easier for other users to cross compile it."
msgstr "Non è necessario utilizzare nuovamente le altre opzioni di CMake poiché ora sono nella cache. In questo modo si può utilizzare MyProjectTryRunResults-eldk-ppc.cmake in più alberi di build e può essere distribuito col progetto in modo che sia più facile per altri utenti cross-compilarlo."

#: ../../source/chapter/Cross CMake.rst:427 Compiling With
msgid "Running Executables Built in the Project"
msgstr "Esecuzione di Eseguibili Creati nel Progetto"

#: ../../source/chapter/Cross CMake.rst:429 Compiling With
msgid ""
"In some cases it is necessary that during a build, an executable is "
"invoked that was built earlier in the same build; this is usually the "
"case for code generators and similar tools. This does not work when cross"
" compiling, as the executables are built for the target platform and "
"cannot run on the build host (without the use of virtual machines, "
"compatibility layers, emulators, etc.). With CMake, these programs are "
"created using :command:`add_executable`, and executed with "
":command:`add_custom_command` or :command:`add_custom_target`. The "
"following three options can be used to support these executables with "
"CMake. The old version of the CMake code could look something like this"
msgstr "In alcuni casi è necessario che durante una build venga richiamato un eseguibile compilato in precedenza nella stessa build; questo di solito è il caso di generatori di codice e strumenti simili. Questo non funziona durante la cross-compilazione, poiché gli eseguibili sono creati per la piattaforma target e non possono essere eseguiti sull'host di build (senza l'uso di macchine virtuali, layer di compatibilità, emulatori, ecc.). Con CMake, questi programmi vengono creati utilizzando :command:`add_executable`, ed eseguiti con :command:`add_custom_command` o con :command:`add_custom_target`. Le seguenti tre opzioni possono essere utilizzate per supportare questi eseguibili con CMake. La vecchia versione del codice CMake potrebbe essere simile a questa"

#: ../../source/chapter/Cross CMake.rst:454 Compiling With
msgid ""
"Now we will show how this file can be modified so that it works when "
"cross-compiling. The basic idea is that the executable is built only when"
" doing a native build for the build host, and is then exported as an "
"executable target to a CMake script file. This file is then included when"
" cross-compiling, and the executable target for the executable mygen will"
" be loaded. An imported target with the same name as the original target "
"will be created. :command:`add_custom_command` recognizes target names as"
" executables, so for the command in :command:`add_custom_command`, simply"
" the target name can  be used; it is not necessary to use the LOCATION "
"property to obtain  the path of the executable:"
msgstr "Ora mostreremo come questo file può essere modificato in modo che funzioni durante la cross-compilazione. L'idea di base è che l'eseguibile viene compilato solo quando si esegue una compilazione nativa per l'host di build e viene poi esportato come target eseguibile in un file di script CMake. Questo file viene quindi incluso durante la cross-compilazione e verrà caricato il target eseguibile di mygen. Verrà creato un target importato con lo stesso nome del target originale. :command:`add_custom_command` riconosce i nomi dei target come eseguibili, quindi per il comando in :command:`add_custom_command`, può essere utilizzato semplicemente il nome del target; non è necessario utilizzare la proprietà LOCATION per ottenere il path dell'eseguibile:"

#: ../../source/chapter/Cross CMake.rst:480 Compiling With
msgid ""
"With the CMakeLists.txt modified like this, the project can be cross-"
"compiled. First, a native build has to be done in order to create the "
"necessary mygen executable. After that, the cross-compiling build can "
"begin. The build directory of the native build has to be given to the "
"cross-compiling build as the location of the MyGen package, so that "
"find_package(MyGen) can find it::"
msgstr "Con CMakeLists.txt modificato in questo modo, il progetto può essere cross-compilato. Innanzitutto, è necessario eseguire una build nativa per creare l'eseguibile mygen necessario. Successivamente, si può iniziare la cross-compilazione. La directory di build della build nativa deve essere assegnata a quella della cross-compilazione come la posizione del pacchetto MyGen, in modo che find_package(MyGen) possa trovarlo::"

#: ../../source/chapter/Cross CMake.rst:501 Compiling With
msgid "Cross-Compiling Hello World"
msgstr "Cross-Compilare Hello World"

#: ../../source/chapter/Cross CMake.rst:503 Compiling With
msgid ""
"Now let's actually start with the cross-compiling. The first step is to "
"install a cross-compiling toolchain. If this is already installed, you "
"can skip the next paragraph."
msgstr "Ora iniziamo effettivamente con la cross-compilazione. Il primo passo consiste nell'installare una toolchain di cross-compilazione. Se questo è già installato, si può saltare il paragrafo successivo."

#: ../../source/chapter/Cross CMake.rst:507 Compiling With
msgid ""
"There are many different approaches and projects that deal with cross-"
"compiling for Linux, ranging from free software projects working on "
"Linux-based PDAs to commercial embedded Linux vendors. Most of these "
"projects come with their own way to build and use the respective "
"toolchain. Any of these toolchains can be used with CMake; the only "
"requirement is that it works in the normal file system and does not "
"expect a \"sandboxed\" environment, like for example the Scratchbox "
"project."
msgstr "Esistono molti approcci e progetti diversi che si occupano di cross-compilazione per Linux, che vanno dai progetti di software libero che lavorano su PDA basati su Linux ai fornitori commerciali di Linux embedded. La maggior parte di questi progetti ha il proprio modo di buildare e utilizzare la rispettiva toolchain. Ciascuna di queste toolchain può essere utilizzata con CMake; l'unico requisito è che funzioni nel normale file system e non preveda un ambiente \"sandboxed\", come ad esempio il progetto Scratchbox."

#: ../../source/chapter/Cross CMake.rst:516 Compiling With
msgid ""
"An easy-to-use toolchain with a relatively complete target environment is"
" the Embedded Linux Development Toolkit "
"(http://www.denx.de/wiki/DULG/ELDK). It supports ARM, PowerPC, and MIPS "
"as target platforms. ELDK can be downloaded from "
"ftp://ftp.sunet.se/pub/Linux/distributions/eldk/. The easiest way is to "
"download the ISOs, mount them, and then install them::"
msgstr "Una toolchain di facile utilizzo con un ambiente target relativamente completo è l'Embedded Linux Development Toolkit (http://www.denx.de/wiki/DULG/ELDK). Supporta ARM, PowerPC e MIPS come piattaforme target. ELDK è scaricabile da ftp://ftp.sunet.se/pub/Linux/distributions/eldk/. Il modo più semplice è quello di scaricare gli ISO, montarli e poi installarli::"

#: ../../source/chapter/Cross CMake.rst:534 Compiling With
msgid ""
"ELDK (and other toolchains) can be installed anywhere, either in the home"
" directory or system-wide if there are more users working with them. In "
"this example, the toolchain will now be located in /home/alex/eldk-"
"mips/usr/bin/ and the target environment is in /home/alex/eldk-"
"mips/mips_4KC/."
msgstr "ELDK (e altre toolchain) possono essere installate ovunque, nella home directory o in tutto il sistema se ci sono più utenti che ci lavorano. In questo esempio, la toolchain si troverà in /home/alex/eldk-mips/usr/bin/ e l'ambiente target in /home/alex/eldk-mips/mips_4KC/."

#: ../../source/chapter/Cross CMake.rst:540 Compiling With
msgid ""
"Now that a cross-compiling toolchain is installed, CMake has to be set up"
" to use it. As already described, this is done by creating a toolchain "
"file for CMake. In this example, the toolchain file looks like this:"
msgstr "Ora che è installata una toolchain per la cross-compilazione incrociata, CMake deve essere configurato per utilizzarla. Come già descritto, questo viene fatto creando un file di toolchain per CMake. In questo esempio, il file della toolchain ha questo aspetto:"

#: ../../source/chapter/Cross CMake.rst:566 Compiling With
msgid ""
"The toolchain files can be located anywhere, but it is a good idea to put"
" them in a central place so that they can be reused in multiple projects."
" We will save this file as ~/Toolchains/Toolchain-eldk-mips4K.cmake. The "
"variables mentioned above are set here: :variable:`CMAKE_SYSTEM_NAME`, "
"the C/C++ compilers, and :variable:`CMAKE_FIND_ROOT_PATH` to specify "
"where libraries and headers for the target environment are located. The "
"find modes are also set up so that libraries and headers are searched for"
" in the target environment only, whereas programs are searched for in the"
" host environment only. Now we will cross-compile the hello world project"
" from Chapter 2"
msgstr "I file della toolchain possono trovarsi ovunque, ma è una buona idea metterli in una posizione centralizzata in modo che possano essere riutilizzati in più progetti. Salveremo questo file come ~/Toolchains/Toolchain-eldk-mips4K.cmake. Le variabili sopra menzionate sono impostate qui: :variable:`CMAKE_SYSTEM_NAME`, i compilatori C/C++ e :variable:`CMAKE_FIND_ROOT_PATH` per specificare dove si trovano le librerie e gli header per l'ambiente target. Anche le modalità di ricerca sono impostate in modo che le librerie e gli header vengano cercati solo nell'ambiente target, mentre i programmi vengono cercati solo nell'ambiente host. Ora cross-compileremo il progetto hello world del Capitolo 2"

#: ../../source/chapter/Cross CMake.rst:585 Compiling With
msgid "Run CMake, this time telling it to use the toolchain file from above::"
msgstr "Si esegue CMake, questa volta dicendogli di usare il file toolchain precedente::"

#: ../../source/chapter/Cross CMake.rst:592 Compiling With
msgid ""
"This should give you an executable that can run on the target platform. "
"Thanks to the VERBOSE=1 option, you should see that the cross-compiler is"
" used. Now we will make the example a bit more sophisticated by adding "
"system inspection and install rules. We will build and install a shared "
"library named Tools, and then build the Hello application which links to "
"the Tools library."
msgstr "Questo dovrebbe dare un eseguibile per la piattaforma target. Grazie all'opzione VERBOSE=1, si dovrebbe vedere che viene utilizzato il cross-compilatore. Ora renderemo l'esempio un po' più sofisticato aggiungendo l'ispezione del sistema e le regole di installazione. Eseguiremo la build e installeremo una libreria shared denominata Tools, poi creeremo l'applicazione Hello che si linka alla libreria Tools."

#: ../../source/chapter/Cross CMake.rst:626 Compiling With
msgid ""
"There is no difference in a normal CMakeLists.txt; no special "
"prerequisites are required for cross-compiling. The CMakeLists.txt checks"
" that the header stdio.h is available and sets the version number for the"
" Tools library. These are configured into config.h, which is then used in"
" tools.cxx. The version number is also used to set the version number of "
"the Tools library. The library and headers are installed to "
"${:variable:`CMAKE_INSTALL_PREFIX`}/lib and "
"${``CMAKE_INSTALL_PREFIX``}/include respectively. Running CMake gives "
"this result::"
msgstr "Non c'è differenza in un normale CMakeLists.txt; non sono richiesti prerequisiti speciali per la cross-compilazione. CMakeLists.txt verifica che l'header stdio.h sia disponibile e imposta il numero di versione per la libreria Tools. Questi vengono configurati in config.h, che viene poi utilizzato in tools.cxx. Il numero di versione viene utilizzato anche per impostare quello della libreria Tools. La libreria e gli header sono installati rispettivamente in ${:variable:`CMAKE_INSTALL_PREFIX`}/lib e in ${``CMAKE_INSTALL_PREFIX``}/include. L'esecuzione di CMake dà questo risultato::"

#: ../../source/chapter/Cross CMake.rst:665 Compiling With
msgid ""
"As can be seen in the output above, CMake detected the correct compiler, "
"found the stdio.h header for the target platform, and successfully "
"generated the Makefiles. The make command was invoked, which then "
"successfully built and installed the library in the specified "
"installation directory. Now we can build an executable that uses the "
"Tools library and does some system inspection"
msgstr "Come si può vedere nell'output precedente, CMake ha rilevato il compilatore corretto, ha trovato l'header stdio.h per la piattaforma target e ha generato correttamente i Makefile. È stato richiamato il comando make, che ha poi compilato e installato correttamente la libreria nella directory di installazione specificata. Ora possiamo buildare un eseguibile che usa la libreria Tools ed esegue un'ispezione del sistema"

#: ../../source/chapter/Cross CMake.rst:711 Compiling With
msgid ""
"Building works in the same way as with the library; the toolchain file "
"has to be used and then it should just work::"
msgstr "La build funziona allo stesso modo della libreria; il file toolchain deve essere utilizzato e poi dovrebbe funzionare::"

#: ../../source/chapter/Cross CMake.rst:737 Compiling With
msgid ""
"Obviously CMake found the correct zlib and also libTools.so, which had "
"been installed in the previous step."
msgstr "Ovviamente CMake ha trovato lo zlib corretto e anche libTools.so, che era stato installato nel passaggio precedente."

#: ../../source/chapter/Cross CMake.rst:744 Compiling With
msgid "Cross-Compiling for a Microcontroller"
msgstr "Cross-Compilazione per un Microcontroller"

#: ../../source/chapter/Cross CMake.rst:746 Compiling With
msgid ""
"CMake can be used for more than cross-compiling to targets with operating"
" systems, it is also possible to use it in development for deeply-"
"embedded devices with small microcontrollers and no operating system at "
"all. As an example, we will use the Small Devices C Compiler "
"(http://sdcc.sourceforge.net), which runs under Windows, Linux, and Mac "
"OS X, and supports 8 and 16 Bit microcontrollers. For driving the build, "
"we will use MS NMake under Windows. As before, the first step is to write"
" a toolchain file so that CMake knows about the target platform. For "
"sdcc, it should look something like this"
msgstr "CMake può essere utilizzato per molto di più della cross-compilazione su target con sistemi operativi, è anche possibile utilizzarlo in fase di sviluppo per dispositivi \"deeply-embedded\" con piccoli microcontrollori e nessun sistema operativo. Ad esempio, utilizzeremo Small Devices C Compiler (http://sdcc.sourceforge.net), che funziona su Windows, Linux e Mac OS X e supporta microcontrollori a 8 e 16 bit. Per gestire la build, useremo MS NMake sotto Windows. Come prima, il primo passo è scrivere un file di toolchain in modo che CMake conosca la piattaforma target. CMakeLists.txt dovrebbe essere simile al seguente"

#: ../../source/chapter/Cross CMake.rst:764 Compiling With
msgid ""
"The system name for targets that do not have an operating system, "
"\"Generic,\" should be used as the :variable:`CMAKE_SYSTEM_NAME`. The "
"CMake platform file for \"Generic\" doesn't set up any specific features."
" All that it assumes is that the target platform does not support shared "
"libraries, and so all properties will depend on the compiler and "
":variable:`CMAKE_SYSTEM_PROCESSOR`. The toolchain file above does not set"
" the FIND-related variables. As long as none of the find commands is used"
" in the CMake commands, this is fine. In many projects for small "
"microcontrollers, this will be the case. The CMakeLists.txt should look "
"like the following"
msgstr "Il nome del sistema per i target che non dispongono di un sistema operativo, \"Generic\", deve essere utilizzato come :variable:`CMAKE_SYSTEM_NAME`. Il file della piattaforma CMake per \"Generic\" non imposta alcuna funzionalità specifica. Tutto ciò che presuppone è che la piattaforma target non supporti le librerie shared, quindi tutte le proprietà dipenderanno dal compilatore e da :variable:`CMAKE_SYSTEM_PROCESSOR`. Il file toolchain sopra non imposta le variabili relative a FIND. Finché nessuno dei comandi find viene utilizzato nei comandi CMake, va bene. In molti progetti per piccoli microcontrollori, sarà così. CMakeLists.txt dovrebbe essere simile al seguente"

#: ../../source/chapter/Cross CMake.rst:791 Compiling With
msgid ""
"There are no major differences in other CMakeLists.txt files. One "
"important point is that the language \"C\" is enabled explicitly using "
"the :command:`project` command. If this is not done, CMake will also try "
"to enable support for C++, which will fail as sdcc only has support for "
"C. Running CMake and building the project should work as usual::"
msgstr "Non ci sono grandi differenze in altri file CMakeLists.txt. Un punto importante è che il linguaggio \"C\" è abilitato esplicitamente usando il comando :command:`project`. Se ciò non viene fatto, CMake proverà anche ad abilitare il supporto per C++, che fallirà poiché sdcc supporta solo C. L'esecuzione di CMake e la creazione del progetto dovrebbero funzionare come al solito::"

#: ../../source/chapter/Cross CMake.rst:821 Compiling With
msgid ""
"This was a simple example using NMake with sdcc with the default settings"
" of sdcc. Of course, more sophisticated project layouts are possible. For"
" this kind of project, it is also a good idea to set up an install "
"directory where reusable libraries can be installed, so it is easier to "
"use them in multiple projects. It is normally necessary to choose the "
"correct target platform for sdcc; not everybody uses i8051, which is the "
"default for sdcc. The recommended way to do this is via setting "
":variable:`CMAKE_SYSTEM_PROCESSOR`."
msgstr "Questo era un semplice esempio usando NMake con sdcc con le impostazioni di default di sdcc. Naturalmente, sono possibili layout di progetto più sofisticati. Per questo tipo di progetto, è anche una buona idea impostare una directory di installazione in cui è possibile installare librerie riutilizzabili, quindi è più facile utilizzarle in più progetti. Normalmente è necessario scegliere la piattaforma target corretta per sdcc; non tutti usano i8051, che è il default per sdcc. Il modo consigliato per farlo è impostando :variable:`CMAKE_SYSTEM_PROCESSOR`."

#: ../../source/chapter/Cross CMake.rst:830 Compiling With
msgid ""
"This will cause CMake to search for and load the platform file Platform"
"/Generic-SDCC-C-${CMAKE_SYSTEM_PROCESSOR}.cmake. As this happens, right "
"before loading Platform/Generic-SDCC-C.cmake, it can be used to set up "
"the compiler and linker flags for the specific target hardware and "
"project. Therefore, a slightly more complex toolchain file is required"
msgstr "In questo modo CMake cercherà e caricherà il file della piattaforma Platform/Generic-SDCC-C-${CMAKE_SYSTEM_PROCESSOR}.cmake. Poiché ciò accade, subito prima di caricare Platform/Generic-SDCC-C.cmake, può essere utilizzato per impostare i flag del compilatore e del linker per l'hardware e il progetto target specifici. Pertanto, è necessario un file di toolchain leggermente più complesso"

#: ../../source/chapter/Cross CMake.rst:862 Compiling With
msgid ""
"This toolchain file contains a few new settings; it is also about the "
"most complicated toolchain file you should ever need. "
":variable:`CMAKE_SYSTEM_PROCESSOR` is set to Test_DS80C400_Rev_1, an "
"identifier for the specific target hardware. This has the effect that "
"CMake will try to load Platform/Generic-SDCC-C-Test_DS80C400_Rev_1.cmake."
" As this file does not exist in the CMake system module directory, the "
"CMake variable :variable:`CMAKE_MODULE_PATH` has to be adjusted so that "
"this file can be found. If this toolchain file is saved to c:/Toolchains"
"/sdcc-ds400.cmake, the hardware-specific file should be saved in "
"c:/Toolchains/Modules/Platform/. An example of this is shown below:"
msgstr "Questo file di toolchain contiene alcune nuove impostazioni; si tratta anche del file di toolchain più complicato di cui si dovrebbe mai aver bisogno. :variable:`CMAKE_SYSTEM_PROCESSOR` è impostato su Test_DS80C400_Rev_1, un identificatore per l'hardware target specifico. Ciò ha l'effetto che CMake proverà a caricare Platform/Generic-SDCC-C-Test_DS80C400_Rev_1.cmake. Poiché questo file non esiste nella directory del modulo di sistema CMake, la variabile CMake :variable:`CMAKE_MODULE_PATH` deve essere aggiustata in modo che questo file possa essere trovato. Se questo file della toolchain viene salvato in c:/Toolchains/sdcc-ds400.cmake, il file specifico dell'hardware deve essere salvato in c:/Toolchains/Modules/Platform/. Un esempio di ciò è mostrato di seguito:"

#: ../../source/chapter/Cross CMake.rst:883 Compiling With
msgid ""
"This will select the DS80C390 as the target platform and add the --use-"
"accelerator argument to the default compile flags. In this example the "
"\"NMake Makefiles\" generator was used. In the same way e.g. the \"MinGW "
"Makefiles\" generator could be used for a GNU make from MinGW, or another"
" Windows version of GNU make, are available. At least version 3.78 is "
"required, or the \"Unix Makefiles\" generator under UNIX. Also, any "
"Makefile-based, IDE-project generators could be used; e.g. the Eclipse, "
"CodeBlocks, or the KDevelop3 generator."
msgstr "Questo selezionerà DS80C390 come piattaforma target e aggiungerà l'argomento --use-accelerator ai flag di compilazione di default. In questo esempio è stato utilizzato il generatore \"NMake Makefiles\". Allo stesso modo sono disponibili, ad es., il generatore e.g. \"MinGW Makefiles\" potrebbe essere utilizzato per un make GNU da MinGW, o un'altra versione Windows di GNU make. È richiesta almeno la versione 3.78 o il generatore \"Unix Makefiles\" sotto UNIX. Inoltre, è possibile utilizzare qualsiasi generatore di progetti IDE basato su Makefile; per esempio. il generatore Eclipse, CodeBlocks o KDevelop3."

#: ../../source/chapter/Cross CMake.rst:893 Compiling With
msgid "Cross-Compiling a Complex Project - VTK"
msgstr "Cross-Compilazione di un Progetto Complesso - VTK"

#: ../../source/chapter/Cross CMake.rst:895 Compiling With
msgid ""
"Building a complex project is a multi-step process. Complex in this case "
"means that the project uses tests that run executables, and that it "
"builds executables which are used later in the build to generate code (or"
" something similar). One such project is VTK, which uses several "
":command:`try_run` tests and creates several code generators. When "
"running CMake on the project, every :command:`try_run` command will  "
"produce an error message; at the end there will be a "
"``TryRunResults.cmake`` file in the build directory. You need to go "
"through all of the entries of this file and fill in the appropriate "
"values. If you are uncertain about the correct result, you can also try "
"to execute the test binaries on the real target platform, where they are "
"saved in the binary directory."
msgstr "La Build di un progetto complesso è un processo in più fasi. Complesso in questo caso significa che il progetto utilizza test che eseguono eseguibili e che crea eseguibili utilizzati successivamente nella build per generare codice (o qualcosa di simile). Uno di questi progetti è VTK, che utilizza diversi test :command:`try_run` e crea diversi generatori di codice. Quando si esegue CMake sul progetto, ogni comando :command:`try_run` produrrà un messaggio di errore; alla fine ci sarà un file ``TryRunResults.cmake`` nella directory di build. È necessario esaminare tutte le voci di questo file e inserire i valori appropriati. Se non si è certi della correttezza del risultato, si può anche provare a eseguire i binari di test sulla piattaforma target reale, dove vengono salvati nella directory binaria."

#: ../../source/chapter/Cross CMake.rst:908 Compiling With
msgid ""
"VTK contains several code generators, one of which is ProcessShader. "
"These code generators are added using :command:`add_executable`; "
":command:`get_target_property(LOCATION)` is used to get the locations of "
"the resulting binaries, which are then used in "
":command:`add_custom_command` or :command:`add_custom_target` commands. "
"Since the cross-compiled executables cannot be executed during the build,"
" the :command:`add_executable` calls are surrounded by ``if (NOT "
"CMAKE_CROSSCOMPILING)`` commands and the executable targets are imported "
"into the project using the :command:`add_executable` command with the "
"``IMPORTED`` option. These import statements are in the file "
"``VTKCompileToolsConfig.cmake``, which does not have to be created "
"manually, but it is created by a native build of VTK."
msgstr "VTK contiene diversi generatori di codice, uno dei quali è ProcessShader. Questi generatori di codice vengono aggiunti utilizzando :command:`add_executable`; :command:`get_target_property(LOCATION)` viene utilizzato per ottenere le posizioni dei file binari risultanti, che vengono poi utilizzati nei comandi :command:`add_custom_command` o :command:`add_custom_target` commands. Poiché gli eseguibili cross-compilati non possono essere eseguiti durante la compilazione, le chiamate :command:`add_executable` sono circondate dai comandi  ``if (NOT CMAKE_CROSSCOMPILING)`` e gli eseguibili target vengono importati nel progetto col comando :command:`add_executable` con l'opzione ``IMPORTED``. Queste istruzioni di importazione si trovano nel file ``VTKCompileToolsConfig.cmake``, che non deve essere creato manualmente, ma viene creato da una build nativa di VTK."

#: ../../source/chapter/Cross CMake.rst:922 Compiling With
msgid "In order to cross-compile VTK, you need to:"
msgstr "Per eseguire la cross-compilazione di VTK, è necessario:"

#: ../../source/chapter/Cross CMake.rst:924 Compiling With
msgid "Install a toolchain and create a toolchain file for CMake."
msgstr "Installare una toolchain e creare un file toolchain per CMake."

#: ../../source/chapter/Cross CMake.rst:925 Compiling With
msgid "Build VTK natively for the build host."
msgstr "Eseguire una build di VTK nativamente per l'host di build."

#: ../../source/chapter/Cross CMake.rst:926 Compiling With
msgid "Run CMake for the target platform."
msgstr "Eseguire CMake per la piattaforma target."

#: ../../source/chapter/Cross CMake.rst:927 Compiling With
msgid "Complete ``TryRunResults.cmake``."
msgstr "Completare ``TryRunResults.cmake``."

#: ../../source/chapter/Cross CMake.rst:928 Compiling With
msgid "Use the ``VTKCompileToolsConfig.cmake`` file from the native build."
msgstr "Usa il file ``VTKCompileToolsConfig.cmake`` dalla build nativa."

#: ../../source/chapter/Cross CMake.rst:929 Compiling With
msgid "Build."
msgstr "Eseguire la build."

#: ../../source/chapter/Cross CMake.rst:931 Compiling With
msgid ""
"So first, build a native VTK for the build host using the standard "
"procedure."
msgstr "Quindi, per prima cosa, si crea un VTK nativo per l'host di build utilizzando la procedura standard."

#: ../../source/chapter/Cross CMake.rst:941 Compiling With
msgid ""
"Ensure that all required options are enabled using ccmake; e.g. if you "
"need Python wrapping for the target platform, you must enable Python "
"wrapping in ``build-native/``. Once this build has finished, there will "
"be a ``VTKCompileToolsConfig.cmake`` file in ``build-native/``. If this "
"succeeded, we can continue to cross compiling the project, in this "
"example for an IBM BlueGene supercomputer."
msgstr "Tutte le opzioni richieste devono essere abilitate usando ccmake; per esempio. se c'è bisogno del wrapping di Python per la piattaforma target, si deve abilitare il wrapping Python in ``build-native/``. Una volta terminata questa build, ci sarà un file ``VTKCompileToolsConfig.cmake`` in ``build-native/``. Se ciò ha avuto successo, possiamo continuare a cross-compilare il progetto, in questo esempio per un supercomputer IBM BlueGene."

#: ../../source/chapter/Cross CMake.rst:957 Compiling With
msgid ""
"This will finish with an error message for each :command:`try_run` and a "
"``TryRunResults.cmake file``, that you have to complete as described "
"above. You should save the file to a safe location, or it will be "
"overwritten on the next CMake run."
msgstr "Questo finirà con un messaggio di errore per ogni :command:`try_run` e un file ``TryRunResults.cmake``, da completare come descritto precedentemente. Si dovrebbe salvare il file in una posizione sicura, altrimenti verrà sovrascritto alla prossima esecuzione di CMake."

#: ../../source/chapter/Cross CMake.rst:969 Compiling With
msgid ""
"On the second run of ccmake, all the other arguments can be skipped as "
"they are now in the cache. It is possible to point CMake to the build "
"directory that contains a CMakeCache.txt, so CMake will figure out that "
"this is the build directory."
msgstr "Alla seconda esecuzione di ccmake, tutti gli altri argomenti possono essere saltati perché ora sono nella cache. È possibile indirizzare CMake alla directory di build che contiene un CMakeCache.txt, poi CMake capirà che questa è la directory di build."

#: ../../source/chapter/Cross CMake.rst:975 Compiling With
msgid "Some Tips and Tricks"
msgstr "Alcuni Suggerimenti e Trucchi"

#: ../../source/chapter/Cross CMake.rst:978 Compiling With
msgid "Dealing with try_run tests"
msgstr "Gestione dei test try_run"

#: ../../source/chapter/Cross CMake.rst:980 Compiling With
msgid ""
"In order to make cross compiling your project easier, try to avoid "
":command:`try_run` tests and use other methods to test something instead."
" If you cannot avoid :command:`try_run` tests, try to use only the exit "
"code from the run and not the output of the process. That way it will not"
" be necessary to set both the exit code and the stdout and stderr "
"variables for the :command:`try_run` test when cross-compiling. This "
"allows the ``OUTPUT_VARIABLE`` or the ``RUN_OUTPUT_VARIABLE`` options for"
" :command:`try_run` to be omitted."
msgstr "Per semplificare la cross-compilazione del progetto, si cercano di evitare i test :command:`try_run` usando invece altri metodi per testare qualcosa. Se non si possono evitare i test :command:`try_run`, provare a utilizzare solo il codice di uscita dall'esecuzione e non l'output del processo. In questo modo non sarà necessario impostare sia il codice output che le variabili stdout e stderr per il test :command:`try_run` durante la cross-compilazione. Ciò consente di omettere le opzioni ``OUTPUT_VARIABLE`` o ``RUN_OUTPUT_VARIABLE`` per :command:`try_run`."

#: ../../source/chapter/Cross CMake.rst:989 Compiling With
msgid ""
"If you have done that, created and completed a correct "
"``TryRunResults.cmake`` file for the target platform, you might consider "
"adding this file to the sources of the project, so that it can be reused "
"by others. These files are per-target, per-toolchain."
msgstr "Facendolo, si crea e si completa un file ``TryRunResults.cmake`` corretto per la piattaforma target, si potrebbe considerare di aggiungere questo file ai sorgenti del progetto, in modo che possa essere riutilizzato da altri. Questi file sono per target, per toolchain."

#: ../../source/chapter/Cross CMake.rst:995 Compiling With
msgid "Target platform and toolchain issues"
msgstr "Problemi relativi alla piattaforma e alla toolchain target"

#: ../../source/chapter/Cross CMake.rst:997 Compiling With
msgid ""
"If your toolchain is unable to build a simple program without special "
"arguments, like e.g. a linker script file or a memory layout file, the "
"tests CMake does initially will fail. To make it work the CMake module "
"CMakeForceCompiler offers the following macros:"
msgstr "Se la toolchain non è in grado di creare un semplice programma senza argomenti speciali, come ad es. un file di script del linker o un file di layout di memoria, i test inizialmente eseguiti da CMake falliranno. Per farlo funzionare, il modulo CMake CMakeForceCompiler offre le seguenti macro:"

#: ../../source/chapter/Cross CMake.rst:1008 Compiling With
msgid ""
"These macros can be used in a toolchain file so that the required "
"variables will be preset and the CMake tests avoided."
msgstr "Queste macro possono essere utilizzate in un file di toolchain in modo che le variabili richieste vengano preimpostate e i test CMake evitati."

#: ../../source/chapter/Cross CMake.rst:1015 Compiling With
msgid "RPATH handling under UNIX"
msgstr "Gestione di RPATH sotto UNIX"

#: ../../source/chapter/Cross CMake.rst:1017 Compiling With
msgid ""
"For native builds, CMake builds executables and libraries by default with"
" RPATH. In the build tree, the RPATH is set so that the executables can "
"be run from the build tree; i.e. the RPATH points into the build tree. "
"When installing the project, CMake links the executables again, this time"
" with the RPATH for the install tree, which is empty by default."
msgstr "Per le build native, CMake crea eseguibili e librerie per default con RPATH. Nell'albero di build, RPATH è impostato in modo che gli eseguibili possano essere eseguiti dall'albero di build; cioè i punti RPATH nell'albero di build. Durante l'installazione del progetto, CMake linka nuovamente gli eseguibili, questa volta con l'RPATH per l'albero di installazione, che è vuoto per default."

#: ../../source/chapter/Cross CMake.rst:1024 Compiling With
msgid ""
"When cross-compiling you probably want to set up RPATH handling "
"differently. As the executable cannot run on the build host, it makes "
"more sense to build it with the install RPATH right from the start. There"
" are several CMake variables and target properties for adjusting RPATH "
"handling."
msgstr "Durante la cross-compilazione probabilmente si vorrà impostare la gestione di RPATH in modo diverso. Poiché l'eseguibile non può essere lanciato sull'host di build, ha più senso compilarlo con l'installazione RPATH fin dall'inizio. Esistono diverse variabili CMake e proprietà del target per regolare la gestione di RPATH."

#: ../../source/chapter/Cross CMake.rst:1035 Compiling With
msgid ""
"With these two settings, the targets will be built with the install RPATH"
" instead of the build RPATH, which avoids the need to link them again "
"when installing. If you don't need RPATH support in your project, you "
"don't need to set :variable:`CMAKE_INSTALL_RPATH`; it is empty by "
"default."
msgstr "Con queste due impostazioni, i target verranno compilati con l'RPATH di installazione anziché con l'RPATH di build, il che evita la necessità di linkarli nuovamente durante l'installazione. Se non c'è bisogno del supporto RPATH nel progetto, non c'è bisogno di impostare :variable:`CMAKE_INSTALL_RPATH`; è vuota per default."

#: ../../source/chapter/Cross CMake.rst:1041 Compiling With
msgid ""
"Setting :variable:`CMAKE_INSTALL_RPATH_USE_LINK_PATH` to ``TRUE`` is "
"useful for native builds, since it automatically collects the RPATH from "
"all libraries against which a targets links. For cross-compiling it "
"should be left at the default setting of ``FALSE``, because on the target"
" the automatically generated RPATH will be wrong in most cases; it will "
"probably have a different file system layout than the build host."
msgstr "L'impostazione di :variable:`CMAKE_INSTALL_RPATH_USE_LINK_PATH` a ``TRUE`` è utile per le build native, poiché raccoglie automaticamente l'RPATH da tutte le librerie a cui si linka un target. Per la cross-compilazione dovrebbe essere lasciato all'impostazione di default ``FALSE``, perché sul target l'RPATH generato automaticamente sarà errato nella maggior parte dei casi; probabilmente avrà un layout di file system diverso rispetto all'host di build."

#: ../../source/chapter/Custom Commands.rst:2
msgid "Custom Commands"
msgstr "Comandi Custom"

#: ../../source/chapter/Custom Commands.rst:4
msgid ""
"Frequently the build process for a software project goes beyond simply "
"compiling libraries and executables. In many cases, additional tasks may "
"be required during or after the build process. Common examples include: "
"compiling documentation using a documentation package; generating source "
"files by running another executable; generating files using tools for "
"which CMake doesn't have rules (such as lex and yacc); moving the "
"resulting executables; post processing the executable, etc. CMake "
"supports these additional tasks using the :command:`add_custom_command` "
"and :command:`add_custom_target` commands. This chapter will describe how"
" to use custom commands and targets to perform complex tasks that CMake "
"does not inherently support."
msgstr "Spesso il processo di build di un progetto software va oltre la semplice compilazione di librerie e di eseguibili. In molti casi, potrebbero essere necessarie attività aggiuntive durante o dopo il processo di build. Esempi comuni includono: compilazione della documentazione utilizzando un pacchetto di documentazione; generare un file sorgente eseguendo un altro eseguibile; generare file utilizzando strumenti per i quali CMake non ha regole (come lex e yacc); spostare gli eseguibili risultanti; post-elaborazione dell'eseguibile, ecc. CMake supporta queste attività aggiuntive utilizzando i comandi :command:`add_custom_command` e :command:`add_custom_target` commands. Questo capitolo descriverà come utilizzare comandi e obiettivi personalizzati per eseguire attività complesse che CMake non supporta nativamente."

#: ../../source/chapter/Custom Commands.rst:22
msgid "Portable Custom Commands"
msgstr "Comandi Custom Portatili"

#: ../../source/chapter/Custom Commands.rst:24
msgid ""
"Before going into detail on how to use custom commands, we will discuss "
"how to deal with some of their portability issues. Custom commands "
"typically involve running programs with files as inputs or outputs. Even "
"a simple command, such as copying a file, can be tricky to do in a cross-"
"platform way. For example, copying a file on UNIX is done with the ``cp``"
" command, while on Windows it is done with the ``copy`` command. To make "
"matters worse, frequently the names of files will change on different "
"platforms. Executables on Windows end with .exe, while on UNIX they do "
"not. Even between UNIX implementations there are differences, such as "
"which extensions are used for shared libraries; .so, .sl, .dylib, etc."
msgstr "Prima di entrare nei dettagli su come utilizzare i comandi personalizzati, discuteremo come affrontare alcuni dei loro problemi di portabilità. I comandi personalizzati in genere comportano l'esecuzione di programmi con file come input o output. Anche un semplice comando, come la copia di un file, può essere complicato da eseguire in modo multipiattaforma. Ad esempio, la copia di un file su UNIX viene eseguita con il comando ``cp``, mentre su Windows viene eseguita con il comando ``copy``. A peggiorare le cose, spesso i nomi dei file cambieranno su piattaforme diverse. Gli eseguibili su Windows terminano con .exe, mentre su UNIX no. Anche tra le implementazioni UNIX ci sono differenze, ad esempio le estensioni utilizzate per le librerie condivise; .so, .sl, .dylib, ecc."

#: ../../source/chapter/Custom Commands.rst:36
msgid ""
"CMake provides three main tools for handling these differences. The first"
" is the ``-E`` option (short for execute) to :manual:`cmake <cmake(1)>`. "
"When the :manual:`cmake <cmake(1)>` executable is passed the ``-E`` "
"option, it acts as a general purpose, cross-platform utility command. The"
" arguments following the ``-E`` option indicate what :manual:`cmake "
"<cmake(1)>` should do. These options provide a platform-independent way "
"to perform a few common tasks including copy or remove files, compare and"
" conditionally copy, time, create symlinks and others. The :manual:`cmake"
" <cmake(1)>` executable can be referenced by using the "
":variable:`CMAKE_COMMAND` variable in your CMakeLists files, as later "
"examples will show."
msgstr "CMake fornisce tre strumenti principali per gestire queste differenze. La prima è l'opzione ``-E`` (abbreviazione di execute) per :manual:`cmake <cmake(1)>`. Quando all'eseguibile :manual:`cmake <cmake(1)>` viene passata l'opzione ``-E``, agisce come un comando di utilità generico multipiattaforma. Gli argomenti che seguono l'opzione ``-E`` indicano cosa dovrebbe fare :manual:`cmake <cmake(1)>`. Queste opzioni forniscono un modo indipendente dalla piattaforma per eseguire alcune attività comuni tra cui copiare o rimuovere file, confrontare e copiare in modo condizionale, cronometrare, creare collegamenti simbolici e altro. È possibile fare riferimento all'eseguibile :manual:`cmake <cmake(1)>` utilizzando la variabile :variable:`CMAKE_COMMAND` nei file CMakeLists, come mostreranno i prossimi esempi."

#: ../../source/chapter/Custom Commands.rst:48
msgid ""
"Of course, CMake doesn't limit you to using ``cmake -E`` in all your "
"custom commands. You can use any command that you like, though it's "
"important to consider portability issues when doing it. A common practice"
" is to use :command:`find_program` to find an executable (Perl, for "
"example), and then use that executable in your custom commands."
msgstr "Naturalmente, CMake non limita l'uso di ``cmake -E`` in tutti i comandi personalizzati. Si può usare qualsiasi comando, anche se è importante considerare i problemi di portabilità. Una pratica comune è quella di usare :command:`find_program` per trovare un eseguibile (Perl, per esempio), e poi usare quell'eseguibile nei comandi personalizzati."

#: ../../source/chapter/Custom Commands.rst:54
msgid ""
"The second tool that CMake provides to address portability issues is a "
"number of variables describing the characteristics of the platform. The "
":manual:`cmake-variables(7)` manual lists many variables that are useful "
"for custom commands that need to reference files with platform-dependent "
"names.  These include :variable:`CMAKE_EXECUTABLE_SUFFIX`, "
":variable:`CMAKE_SHARED_LIBRARY_PREFIX`, etc. which describe file naming "
"conventions."
msgstr "Il secondo strumento fornito da CMake per affrontare i problemi di portabilità è una serie di variabili che descrivono le caratteristiche della piattaforma. Il manuale :manual:`cmake-variables(7)` elenca molte variabili utili per i comandi personalizzati che devono fare riferimento a file con nomi dipendenti dalla piattaforma.  Questi includono :variable:`CMAKE_EXECUTABLE_SUFFIX`, :variable:`CMAKE_SHARED_LIBRARY_PREFIX`, ecc. che descrivono le convenzioni di denominazione dei file."

#: ../../source/chapter/Custom Commands.rst:62
msgid ""
"Finally, CMake supports :manual:`generator expressions <cmake-generator-"
"expressions(7)>` in custom commands. These are expressions that use the "
"special syntax ``$<...>`` and are not evaluated while processing CMake "
"input files, but are instead delayed until generation of the final build "
"system.  Therefore, the values substituted for them know all the details "
"of their evaluation context, including the current build configuration "
"and all build properties associated with a target."
msgstr "Infine, CMake supporta :manual:`generator expressions <cmake-generator-expressions(7)>` nei comandi custom. Si tratta di espressioni che utilizzano la sintassi speciale ``$<...>`` e non vengono valutate durante l'elaborazione dei file di input CMake, ma vengono invece posticipate fino alla generazione del sistema di build finale.  Pertanto, i valori che li sostituiscono conoscono tutti i dettagli del loro contesto di valutazione, inclusa la configurazione di build corrente e tutte le proprietà di build associate a un target."

#: ../../source/chapter/Custom Commands.rst:79
msgid "Add Custom Command"
msgstr "Aggiungere Comandi Custom"

#: ../../source/chapter/Custom Commands.rst:81
msgid ""
"Now we will consider the signature for :command:`add_custom_command`. In "
"Makefile terminology, :command:`add_custom_command` adds a rule to a "
"Makefile. For those more familiar with Visual Studio, it adds a custom "
"build step to a file. :command:`add_custom_command` has two main "
"signatures: one for adding a custom command to a target and one for "
"adding a custom command to build a file."
msgstr "Ora considereremo la firma per :command:`add_custom_command`. Nella terminologia Makefile, :command:`add_custom_command` aggiunge una regola a un Makefile. Per chi ha più familiarità con Visual Studio, aggiunge un passaggio di compilazione personalizzato a un file. :command:`add_custom_command` ha due firme principali: una per aggiungere un comando personalizzato a un target e una per aggiungere un comando personalizzato per la build di un file."

#: ../../source/chapter/Custom Commands.rst:88
msgid ""
"The target is the name of a CMake target (executable, library, or custom)"
" to which you want to add the custom command. There is a choice of when "
"the custom command should be executed. You can specify as many commands "
"as you want for a custom command. They will be executed in the order "
"specified."
msgstr "Il target è il nome di una target CMake (eseguibile, libreria, o custom) a cui si desidera aggiungere il comando custom. È possibile scegliere quando eseguire il comando custom. Si possono specificare tutti i comandi desiderati per un comando personalizzato. Verranno eseguiti nell'ordine specificato."

#: ../../source/chapter/Custom Commands.rst:93
msgid ""
"Now let us consider a simple custom command for copying an executable "
"once it has been built."
msgstr "Consideriamo ora un semplice comando personalizzato per copiare un eseguibile una volta compilato."

#: ../../source/chapter/Custom Commands.rst:113
msgid ""
"The first command in this example is the standard command for creating an"
" executable from a list of source files. In this case, an executable "
"named ``Foo`` is created from the source file ``bar.c``. Next is the "
":command:`add_custom_command` invocation. Here the target is simply "
"``Foo`` and we are adding a post build command. The command to execute is"
" :manual:`cmake <cmake(1)>` which has its full path specified in the "
":variable:`CMAKE_COMMAND` variable. Its arguments are ``-E copy`` and the"
" source and destination locations. In this case, it will copy the ``Foo``"
" executable from where it was built into the "
"``/testing_department/files`` directory. Note that the ``TARGET`` "
"parameter accepts a CMake target (``Foo`` in this example), but arguments"
" specified to the ``COMMAND`` parameter normally require full paths. In "
"this case, we pass to ``cmake -E copy``, the full path to the executable "
"referenced via the ``$<TARGET_FILE:...>`` generator expression."
msgstr "Il primo comando in questo esempio è quello standard per la creazione di un eseguibile da un elenco di sorgenti. In questo caso, viene creato un eseguibile chiamato ``Foo`` dal file sorgente ``bar.c``. Poi c'è l'invocazione di :command:`add_custom_command`. Qui l'obiettivo è semplicemente ``Foo`` e stiamo aggiungendo un comando post build. Il comando da eseguire è :manual:`cmake <cmake(1)>` il cui path completo è specificato nella variabile :variable:`CMAKE_COMMAND`. I suoi argomenti sono ``-E copy`` e le posizioni di origine e destinazione. In questo caso, copierà l'eseguibile ``Foo`` da dove è stato compilato nella directory ``/testing_department/files``. Notare che il parametro ``TARGET`` accetta un target CMake (``Foo`` in questo esempio), ma gli argomenti specificati nel parametro ``COMMAND`` normalmente richiedono path completi. In questo caso, passiamo a ``cmake -E copy``, il path completo dell'eseguibile referenziato tramite l'espressione del generatore ``$<TARGET_FILE:...>``."

#: ../../source/chapter/Custom Commands.rst:133
msgid "Generate a File"
msgstr "Generare un File"

#: ../../source/chapter/Custom Commands.rst:135
msgid ""
"The second use for :command:`add_custom_command` is to add a rule for how"
" to build an output file. Here the rule provided will replace any current"
" rules for building that file. Keep in mind that "
":command:`add_custom_command` output must be consumed by a target in the "
"same scope. As discussed later, the :command:`add_custom_target` command "
"can be used for this."
msgstr "Il secondo uso di :command:`add_custom_command` è quello di aggiungere una regola su come creare un file di output. Qui la regola fornita sostituirà qualsiasi regola corrente per la creazione di quel file. Si tenga presente che l'output di :command:`add_custom_command` deve essere utilizzato da un target nello stesso scope. Come discusso in seguito, il comando :command:`add_custom_target` può essere utilizzato per questo."

#: ../../source/chapter/Custom Commands.rst:145
msgid "Using an Executable to Build a Source File"
msgstr "Utilizzo di un Eseguibile per Creare un File Sorgente"

#: ../../source/chapter/Custom Commands.rst:147
msgid ""
"Sometimes a software project builds an executable that is then used for "
"generating source files, which are used to build other executables or "
"libraries. This may sound like an odd case, but it occurs quite "
"frequently. One example is the build process for the TIFF library, which "
"creates an executable that is then run to generate a source file that has"
" system specific information in it. This file is then used as a source "
"file in building the main TIFF library. Another example is the "
"Visualization Toolkit (VTK), which builds an executable called "
"``vtkWrapTcl`` that wraps C++ classes into Tcl. The executable is built "
"and then used to create more source files for the build process."
msgstr "A volte un progetto software crea un eseguibile che viene poi utilizzato per generare un file sorgente, che viene utilizzato per creare altri eseguibili o librerie. Questo può sembrare un caso strano, ma si verifica abbastanza frequentemente. Un esempio è il processo di build per la libreria TIFF, che crea un eseguibile per generare un file sorgente contenente informazioni specifiche del sistema. Questo file viene poi utilizzato come file sorgente nella creazione della libreria TIFF principale. Un altro esempio è il Visualization Toolkit (VTK), che crea un eseguibile chiamato ``vtkWrapTcl`` che racchiude le classi C++ nel Tcl. L'eseguibile viene compilato e utilizzato per creare più file sorgenti per il processo di build."

#: ../../source/chapter/Custom Commands.rst:178
msgid ""
"The first part of this example produces the ``creator`` executable from "
"the source file ``creator.cxx``. The custom command then sets up a rule "
"for producing the source file ``created.c`` by running the executable "
"``creator``. The custom command depends on the ``creator`` target and "
"writes its result into the output tree (:variable:`PROJECT_BINARY_DIR`). "
"Finally, an executable target called ``Foo`` is added, which is built "
"using the ``created.c`` source file. CMake will create all the required "
"rules in the Makefile (or Visual Studio workspace) so that when you build"
" the project, the ``creator`` executable will be built, and run to create"
" ``created.c``, which will then be used to build the ``Foo`` executable."
msgstr "La prima parte di questo esempio produce l'eseguibile ``creator`` dal file sorgente ``creator.cxx``. Il comando custom poi imposta una regola per produrre il file sorgente ``created.c`` eseguendo l'eseguibile ``creator``. Il comando custom dipende dal target ``creator`` e scrive il suo risultato nell'albero di output (:variable:`PROJECT_BINARY_DIR`). Infine, viene aggiunto un target eseguibile chiamato ``Foo``, creato utilizzando il file sorgente ``created.c``. CMake creerà tutte le regole richieste nel Makefile (o nel workspace di Visual Studio) in modo che quando si crea il progetto, l'eseguibile ``creator`` verrà compilato ed eseguito per creare ``created.c``, che verrà poi utilizzato per creare l'eseguibile ``Foo``."

#: ../../source/chapter/Custom Commands.rst:196
msgid "Adding a Custom Target"
msgstr "Aggiungere un Comando Custom"

#: ../../source/chapter/Custom Commands.rst:198
msgid ""
"In the discussion so far, CMake targets have generally referred to "
"executables and libraries. CMake supports a more general notion of "
"targets, called custom targets, which can be used whenever you want the "
"notion of a target but without the end product being a library or an "
"executable. Examples of custom targets include targets to build "
"documentation, run tests, or update web pages. To add a custom target, "
"use the :command:`add_custom_target` command."
msgstr "Nella discussione finora, i target di CMake hanno generalmente fatto riferimento a eseguibili e librerie. CMake supporta una nozione più generale di target, chiamati target custom (personalizzati), utilizzabili ogni volta che si desidera la nozione di target ma senza che il prodotto finale sia una libreria o un eseguibile. Esempi di target custom includono quelli per creare documentazione, eseguire test o aggiornare pagine web. Per aggiungere un target custom, si usa il comando :command:`add_custom_target`."

#: ../../source/chapter/Custom Commands.rst:206
msgid ""
"The name specified will be the name given to the target. You can use that"
" name to specifically build that target with Makefiles (make name) or "
"Visual Studio (right-click on the target and then select Build). If the "
"optional ``ALL`` argument is specified, this target will be included in "
"the ``ALL_BUILD`` target and will automatically be built whenever the "
"Makefile or Project is built. The command and arguments are optional; if "
"specified, they will be added to the target as a post-build command. For "
"custom targets that will only execute a command this is all you will "
"need. More complex custom targets may depend on other files, in these "
"cases the ``DEPENDS`` arguments are used to list which files this target "
"depends on. We will consider examples of both cases. First, let us look "
"at a custom target that has no dependencies:"
msgstr "Il nome specificato sarà il nome assegnato al target. È possibile utilizzare quel nome per creare in modo specifico tale target con Makefiles (make nome) o Visual Studio (click destro sul target e quindi selezionare Build). Se viene specificato l'argomento facoltativo ``ALL``, il target verrà incluso nel target ``ALL_BUILD`` e verrà compilato automaticamente ogni volta che viene eseguita la build di Makefile o di Project. Il comando e gli argomenti sono facoltativi; se specificati, verranno aggiunti al target come comando di post-build. Per i target custom che eseguiranno solo un comando, questo è tutto ciò di cui c'è bisogno. Target custom più complessi possono dipendere da altri file, in questi casi vengono utilizzati gli argomenti ``DEPENDS`` per elencare da quali file dipende questo target. Prenderemo in considerazione esempi di entrambi i casi. Per prima cosa, esaminiamo un target custom che non ha dipendenze:"

#: ../../source/chapter/Custom Commands.rst:226
msgid ""
"With the above definition, whenever the ``FooJAR`` target is built, it "
"will run Java's Archiver (jar) to create the ``Foo.jar`` file from java "
"classes in the ``${PROJECT_SOURCE_DIR}/Java`` directory. In essence, this"
" type of custom target allows the developer to tie a command to a target "
"so that it can be conveniently invoked during the build process. Now let "
"us consider a more complex example that roughly models the generation of "
"PDF files from LaTeX. In this case, the custom target depends on other "
"generated files (mainly the end product .pdf files)"
msgstr "Con la definizione di cui sopra, ogni volta che il target ``FooJAR`` viene compilato, eseguirà l'Archiver di Java (jar) per creare il file ``Foo.jar`` dalle classi java nella directory ``${PROJECT_SOURCE_DIR}/Java``. In sostanza, questo tipo di target custom consente allo sviluppatore di associare un comando a un target in modo che possa essere comodamente richiamato durante il processo di build. Consideriamo ora un esempio più complesso che modella approssimativamente la generazione di file PDF da LaTeX. In questo caso, il target custom dipende da altri file generati (principalmente i file .pdf del prodotto finale)"

#: ../../source/chapter/Custom Commands.rst:268
msgid ""
"This example makes use of both :command:`add_custom_command` and "
":command:`add_custom_target`. The two :command:`add_custom_command` "
"invocations are used to specify the rules for producing a .pdf file from "
"a .tex file. In this case, there are two steps and two custom commands. "
"First a .dvi file is produced from the .tex file by running LaTeX, then "
"the .dvi file is processed to produce the desired .pdf file. Finally, a "
"custom target is added called TDocument. Its command simply echoes out "
"what it is doing, while the real work is done by the two custom commands."
" The ``DEPENDS`` argument sets up a dependency between the custom target "
"and the custom commands. When TDocument is built, it will first look to "
"see if all of its dependencies are built. If any are not built, it will "
"invoke the appropriate custom commands to build them. This example can be"
" shortened by combining the two custom commands into one custom command, "
"as shown in the following example:"
msgstr "Questo esempio utilizza sia :command:`add_custom_command` che :command:`add_custom_target`. Le due invocazioni :command:`add_custom_command` vengono utilizzate per specificare le regole per la produzione di un file .pdf da un file .tex. In questo caso, ci sono due passaggi e due comandi personalizzati [custom]. Prima viene prodotto un file .dvi dal file .tex eseguendo LaTeX, quindi il file .dvi viene processato per produrre il file .pdf desiderato. Infine, viene aggiunto un target personalizzato chiamato TDocument. Il suo comando fa semplicemente una \"echo\" di ciò che sta facendo, mentre il vero lavoro viene svolto dai due comandi custom. L'argomento ``DEPENDS`` imposta una dipendenza tra il target custom e i comandi custom. Quando TDocument viene compilato, cercherà prima di vedere se tutte le sue dipendenze sono state compilate. Se qualcuna non viene compilata, richiamerà i comandi personalizzati appropriati per crearli. Questo esempio può essere abbreviato combinando i due comandi in un unico comando custom, come mostrato nell'esempio seguente:"

#: ../../source/chapter/Custom Commands.rst:302
msgid ""
"Now consider a case where the documentation consists of multiple files. "
"The above example can be modified to handle many files by using a list of"
" inputs and a :command:`foreach` loop. For example"
msgstr "Si consideri ora un caso in cui la documentazione sia costituita da più file. L'esempio precedente può essere modificato per gestire molti file utilizzando un elenco di input e un ciclo :command:`foreach`. Per esempio"

#: ../../source/chapter/Custom Commands.rst:334
msgid ""
"In this example, building the custom target ``TDocument`` will cause all "
"of the specified .pdf files to be generated. Adding a new document to the"
" list is simply a matter of adding its filename to the ``DOCS`` variable "
"at the top of the example."
msgstr "In questo esempio, la build del target custom ``TDocument`` provocherà la generazione di tutti i file .pdf specificati. Aggiungere un nuovo documento all'elenco è consiste semplicemente nell'aggiungere il suo nome alla variabile ``DOCS`` all'inizio dell'esempio."

#: ../../source/chapter/Custom Commands.rst:340
msgid "Specifying Dependencies and Outputs"
msgstr "Specifica delle Dipendenze e degli Output"

#: ../../source/chapter/Custom Commands.rst:342
msgid ""
"When using custom commands and custom targets you will often be "
"specifying dependencies. When you specify a dependency or the output of a"
" custom command, you should always specify the full path. For example, if"
" the command produces ``foo.h`` in the binary tree then its output should"
" be something like ``${PROJECT_BINARY_DIR}/foo.h``. CMake will try to "
"determine the correct path for the file if it is not specified; complex "
"projects frequently end up using files in both the source and build "
"trees, this can eventually lead to errors if the full paths are not "
"specified."
msgstr "Quando si utilizzano comandi e obiettivi custom, spesso si specificano le dipendenze. Quando si specifica una dipendenza o l'output di un comando custom, si dovrebbe sempre specificare il path completo. Ad esempio, se il comando produce ``foo.h`` nell'albero binario, il suo output dovrebbe essere qualcosa come ``${PROJECT_BINARY_DIR}/foo.h``. CMake proverà a determinare il path corretto per il file se non è specificato; progetti complessi spesso finiscono per utilizzare file sia nell'albero dei sorgenti che in quello di compilazione, questo può eventualmente portare a errori se non vengono specificati i percorsi completi."

#: ../../source/chapter/Custom Commands.rst:352
msgid ""
"When specifying a target as a dependency, you can leave off the full path"
" and executable extension, referencing it simply by its name. Consider "
"the specification of the generator target as an "
":command:`add_custom_command` dependency in the example earlier in this "
"chapter. CMake recognizes ``creator`` as matching an existing target and "
"properly handles the dependencies."
msgstr "Quando si specifica un target come dipendenza, è possibile tralasciare il path completo e l'estensione eseguibile, facendovi riferimento semplicemente col suo nome. Si consideri la specifica dei target del generatore come una dipendenza di :command:`add_custom_command` nell'esempio precedente in questo capitolo. CMake riconosce ``creator`` come corrispondente a un target esistente e gestisce correttamente le dipendenze."

#: ../../source/chapter/Custom Commands.rst:360
msgid "When There Isn't One Rule For One Output"
msgstr "Quando Non c'è una Regola Per Un Output"

#: ../../source/chapter/Custom Commands.rst:362
msgid ""
"There are a couple of unusual cases that can arise when using custom "
"commands that warrant further explanation. The first is a case where one "
"command (or executable) can create multiple outputs, and the second is "
"when multiple commands can be used to create a single output."
msgstr "Ci sono un paio di casi insoliti che possono sorgere quando si utilizzano comandi custom che richiedono ulteriori spiegazioni. Il primo è un caso in cui un comando (o eseguibile) può creare più output e il secondo è quando è possibile utilizzare più comandi per creare un singolo output."

#: ../../source/chapter/Custom Commands.rst:369
msgid "A Single Command Producing Multiple Outputs"
msgstr "Un Singolo Comando che Produce più Output"

#: ../../source/chapter/Custom Commands.rst:371
msgid ""
"In CMake, a custom command can produce multiple outputs simply by listing"
" multiple outputs after the ``OUTPUT`` keyword. CMake will create the "
"correct rules for your build system so that no matter which output is "
"required for a target, the right rules will be run. If the executable "
"happens to produce a few outputs but the build process is only using one "
"of them, then you can simply ignore the other outputs when creating your "
"custom command. Say that the executable produces a source file that is "
"used in the build process, and also an execution log that is not used. "
"The custom command should specify the source file as the output and "
"ignore the fact that a log file is also generated."
msgstr "In CMake, un comando custom può produrre più output semplicemente elencando più output dopo la parola chiave ``OUTPUT``. CMake creerà le regole corrette per il sistema di build in modo che, indipendentemente dall'output richiesto per un target, verranno eseguite le regole giuste. Se l'eseguibile produce alcuni output ma il processo di build ne utilizza solo uno, si possono semplicemente ignorare gli altri output durante la creazione del comando custom. Supponiamo che l'eseguibile produca un file sorgente utilizzato nel processo di build e anche un log di esecuzione che non viene utilizzato. Il comando custom deve specificare il file sorgente come output e ignorare il fatto che viene generato anche un file di log."

#: ../../source/chapter/Custom Commands.rst:383
msgid ""
"Another case of having one command with multiple outputs is when the "
"command is the same but the arguments to it change. This is effectively "
"the same as having a different command, and each case should have its own"
" custom command. An example of this was the documentation example, where "
"a custom command was added for each .tex file. The command is the same "
"but the arguments passed to it change each time."
msgstr "Un altro caso in cui si ha un comando con più output è quando il comando è lo stesso ma gli argomenti cambiano. Questo è effettivamente come avere un comando diverso e ogni caso dovrebbe avere il proprio comando custom. Un esempio di ciò è stato l'esempio della documentazione, in cui è stato aggiunto un comando personalizzato per ogni file .tex. Il comando è lo stesso ma gli argomenti passati cambiano ogni volta."

#: ../../source/chapter/Custom Commands.rst:391
msgid "Having One Output That Can Be Generated By Different Commands"
msgstr "Avere un Output che può Essere Generato da Diversi Comandi"

#: ../../source/chapter/Custom Commands.rst:393
msgid ""
"In rare cases, you may find that you have more than one command that you "
"can use to generate an output. Most build systems, such as make and "
"Visual Studio, do not support this and likewise CMake does not. There are"
" two common approaches that can be used to resolve this. If you truly "
"have two different commands that produce the same output and no other "
"significant outputs, then you can simply pick one of them and create a "
"custom command for it."
msgstr "In rari casi, si potrebbero avere più di un comando che utilizzabile per generare un output. La maggior parte dei sistemi di build, come make e Visual Studio, non lo supporta e allo stesso modo nemmeno CMake. Esistono due approcci comuni che possono essere utilizzati per risolvere questo problema. Se si hanno veramente due comandi diversi che producono lo stesso output e nessun altro output significativo, si può semplicemente sceglierne uno e crearne un comando custom."

#: ../../source/chapter/Custom Commands.rst:401
msgid ""
"In more complex cases there are multiple commands with multiple outputs; "
"for example:"
msgstr "Nei casi più complessi ci sono più comandi con più output; Per esempio:"

#: ../../source/chapter/Custom Commands.rst:409
msgid ""
"There are a few approaches that can be used in this case. You might "
"consider combining both commands and all three outputs into a single "
"custom command, so that whenever one output is required, all three are "
"built at the same time. You could also create three custom commands, one "
"for each unique output. The custom command for ``foo.h`` would invoke "
"Command1, while the one for ``widget.h`` would invoke Command2. When "
"specifying the custom command for ``bar.h``, you could choose either "
"Command1 or Command2."
msgstr "Ci sono alcuni approcci che possono essere utilizzati in questo caso. Si potrebbe considerare di combinare entrambi i comandi e tutti e tre gli output in un singolo comando custom, in modo che ogni volta che è richiesto un output, tutti e tre vengano compilati contemporaneamente. Si possono anche creare tre comandi custom, uno per ogni output univoco. Il comando custom per ``foo.h`` invocherebbe Command1, mentre quello per ``widget.h`` invocherebbe Command2. Quando si specifica il comando custom per ``bar.h``, si può scegliere Command1 o Command2."

#: ../../source/chapter/Finding Packages.rst:2
msgid "Finding Packages"
msgstr "Ricerca dei Pacchetti"

#: ../../source/chapter/Finding Packages.rst:4
msgid ""
"Many software projects provide tools and libraries that are meant as "
"building blocks for other projects and applications. CMake projects that "
"depend on outside packages locate their dependencies using the "
":command:`find_package` command. A typical invocation is of the form:"
msgstr "Molti progetti software forniscono strumenti e librerie intesi come elementi costitutivi per altri progetti e applicazioni. I progetti CMake che dipendono da pacchetti esterni individuano le loro dipendenze utilizzando il comando :command:`find_package`. Una tipica invocazione è della forma:"

#: ../../source/chapter/Finding Packages.rst:13
msgid ""
"where ``<Package>`` is the name of the package to be found, and "
"``[version]`` is an optional version request (of the form "
"``major[.minor.[patch]]``). The command's notion of a package is distinct"
" from that of CPack, which is meant for creating source and binary "
"distributions and installers."
msgstr "dove ``<Package>`` è il nome del pacchetto da trovare e ``[version]`` è una richiesta di versione facoltativa (nella forma ``major[.minor.[patch]]``). La nozione del comando 'package' è distinta da quella di CPack, che ha lo scopo di creare distribuzioni e programmi di installazione di sorgenti e binari."

#: ../../source/chapter/Finding Packages.rst:19
msgid ""
"The command operates in two modes: ``Module`` mode and ``Config`` mode. "
"In Module mode, the command searches for a :manual:`find module <cmake-"
"developer(7)>`: a file named ``Find<Package>.cmake``. It looks first in "
"the :variable:`CMAKE_MODULE_PATH` and then in the CMake installation. If "
"a find module is found, it is loaded to search for individual components "
"of the package. Find modules contain package-specific knowledge of the "
"libraries and other files they expect to find, and internally use "
"commands like :command:`find_library` to locate them. CMake provides find"
" modules for many common packages; see the :manual:`cmake-modules(7)` "
"manual."
msgstr "Il comando opera in due modalità: modalità ``Module`` e modalità ``Config``. In modalità Module, il comando cerca un :manual:`find module <cmake-developer(7)>`: un file chiamato ``Find<Package>.cmake``. Cerca prima in :variable:`CMAKE_MODULE_PATH` e poi nell'installazione di CMake. Se viene trovato un modulo 'find', viene caricato per cercare i singoli componenti del pacchetto. I moduli Find contengono una conoscenza specifica del pacchetto delle librerie e di altri file che si aspettano di trovare e usano internamente comandi come :command:`find_library` per individuarli. CMake fornisce moduli di ricerca per molti pacchetti comuni; vedere il manuale :manual:`cmake-modules(7)`."

#: ../../source/chapter/Finding Packages.rst:30
msgid ""
"The Config mode of :command:`find_package` provides a powerful "
"alternative through cooperation with the package to be found. It enters "
"this mode after failing to locate a find module or when explicitly "
"requested by the caller. In Config mode the command searches for a "
"``package configuration file``: a file named ``<Package>Config.cmake`` or"
" ``<package>-config.cmake`` which is provided by the package to be found."
" Given the name of a package, the :command:`find_package` command knows "
"how to search deep inside installation prefixes for locations like::"
msgstr "La modalità Config di :command:`find_package` fornisce una potente alternativa attraverso la cooperazione col pacchetto da trovare. Entra in questa modalità dopo aver fallito nell'individuare un modulo 'find' o quando esplicitamente richiesto dal chiamante. In modalità Config il comando cerca un ``file di configurazione del pacchetto``: un file chiamato ``<Package>Config.cmake`` o ``<package>-config.cmake`` fornito dal pacchetto da trovare. Dato il nome di un pacchetto, il comando :command:`find_package` sa come cercare approfonditamente all'interno dei prefissi di installazione per locazioni come::"

#: ../../source/chapter/Finding Packages.rst:42
msgid ""
"(see documentation of the :command:`find_package` command for a complete "
"list of locations).  CMake creates a cache entry called ``<Package>_DIR``"
" to store the location found or allow the user to set it.  Since a "
"package configuration file comes with an installation of its package, it "
"knows exactly where to find everything provided by the installation. Once"
" the :command:`find_package` command locates the file it provides the "
"locations of package components without any additional searching."
msgstr "(consultare la documentazione del comando :command:`find_package` per un elenco completo delle locazioni).  CMake crea una voce della cache chiamata ``<Package>_DIR`` per memorizzare la posizione trovata o consentire all'utente di impostarla.  Dat che un file di configurazione del pacchetto viene fornito con una sua installazione, sa esattamente dove trovare tutto ciò che viene fornito. Una volta che il comando :command:`find_package` ha individuato il file, fornisce le posizioni dei componenti del pacchetto senza ulteriori ricerche."

#: ../../source/chapter/Finding Packages.rst:51
msgid ""
"The ``[version]`` option asks :command:`find_package` to locate a "
"particular version of the package. In Module mode, the command passes the"
" request on to the find module. In Config mode the command looks next to "
"each candidate package configuration file for a ``package version file``:"
" a file named ``<Package>ConfigVersion.cmake`` or "
"``<package>-config-<version>.cmake``. The version file is loaded to test "
"whether the package version is an acceptable match for the version "
"requested (see documentation of :command:`find_package` for the version "
"file API specification). If the version file claims compatibility, the "
"configuration file is accepted, or is otherwise ignored. This approach "
"allows each project to define its own rules for version compatibility."
msgstr "L'opzione ``[version]`` chiede a :command:`find_package` di individuare una particolare versione del pacchetto. In modalità Modulo, il comando passa la richiesta al modulo find. In modalità Config il comando cerca accanto a ciascun file di configurazione del pacchetto candidato un ``file di versione del pacchetto``: un file denominato ``<Package>ConfigVersion.cmake`` o ``<package>-config-<version>.cmake``. Il file della versione viene caricato per verificare se la versione del pacchetto è una corrispondenza accettabile per quella richiesta (vedere la documentazione di :command:`find_package` per la specifica dell'API del file della versione). Se il file della versione dichiara la compatibilità, il file di configurazione viene accettato, altrimenti ignorato. Questo approccio consente a ciascun progetto di definire le proprie regole per la compatibilità delle versioni."

#: ../../source/chapter/Finding Packages.rst:69
msgid "Built-in Find Modules"
msgstr "Moduli Find Nativi"

#: ../../source/chapter/Finding Packages.rst:71
msgid ""
"CMake has many predefined modules that can be found in the Modules "
"subdirectory of CMake. The modules can find many common software "
"packages. See the :manual:`cmake-modules(7)` manual for a detailed list."
msgstr "CMake ha molti moduli predefiniti che si trovano nella sottodirectory Modules di CMake. I moduli possono trovare molti pacchetti software comuni. Consultare il manuale :manual:`cmake-modules(7)` per un elenco dettagliato."

#: ../../source/chapter/Finding Packages.rst:76
msgid ""
"Each ``Find<XX>.cmake`` module defines a set of variables that will allow"
" a project to use the software package once it is found. Those variables "
"all start with the name of the software being found <XX>. With CMake we "
"have tried to establish a convention for naming these variables, but you "
"should read the comments at the top of the module for a more definitive "
"answer. The following variables are used by convention when needed:"
msgstr "Ciascun modulo ``Find<XX>.cmake`` definisce un insieme di variabili che consentiranno a un progetto di utilizzare il pacchetto software una volta trovato. Queste variabili iniziano tutte con il nome del software trovato <XX>. Con CMake abbiamo provato a stabilire una convenzione per nominare queste variabili, ma si devono leggere i commenti all'inizio del modulo per una risposta definitiva. Le seguenti variabili sono utilizzate per convenzione quando necessario:"

#: ../../source/chapter/Finding Packages.rst:85
msgid "**<XX>_INCLUDE_DIRS**"
msgstr "**<XX>_INCLUDE_DIRS**"

#: ../../source/chapter/Finding Packages.rst:85
msgid "Where to find the package's header files, typically <XX>.h, etc."
msgstr "Dove trovare i file header del pacchetto, in genere <XX>.h, ecc."

#: ../../source/chapter/Finding Packages.rst:88
msgid "**<XX>_LIBRARIES**"
msgstr "**<XX>_LIBRARIES**"

#: ../../source/chapter/Finding Packages.rst:88
msgid "The libraries to link against to use <XX>. These include full paths."
msgstr "Le librerie a cui linkare per utilizzare <XX>. Queste includono path completi."

#: ../../source/chapter/Finding Packages.rst:91
msgid "**<XX>_DEFINITIONS**"
msgstr "**<XX>_DEFINITIONS**"

#: ../../source/chapter/Finding Packages.rst:91
msgid "Preprocessor definitions to use when compiling code that uses <XX>."
msgstr "Definizioni del preprocessore da utilizzare durante la compilazione del codice che utilizza <XX>."

#: ../../source/chapter/Finding Packages.rst:94
msgid "**<XX>_EXECUTABLE**"
msgstr "**<XX>_EXECUTABLE**"

#: ../../source/chapter/Finding Packages.rst:94
msgid "Where to find the <XX> tool that is part of the package."
msgstr "Dove trovare il tool <XX> che fa parte del pacchetto."

#: ../../source/chapter/Finding Packages.rst:97
msgid "**<XX>_<YY>_EXECUTABLE**"
msgstr "**<XX>_<YY>_EXECUTABLE**"

#: ../../source/chapter/Finding Packages.rst:97
msgid "Where to find the <YY> tool that comes with <XX>."
msgstr "Dove trovare il tool <YY> fornito con <XX>."

#: ../../source/chapter/Finding Packages.rst:100
msgid "**<XX>_ROOT_DIR**"
msgstr "**<XX>_ROOT_DIR**"

#: ../../source/chapter/Finding Packages.rst:100
msgid ""
"Where to find the base directory of the installation of <XX>. This is "
"useful for large packages where you want to reference many files relative"
" to a common base (or root) directory."
msgstr "Dove trovare la directory di base dell'installazione di <XX>. Ciò è utile per pacchetti di grandi dimensioni in cui si desidera fare riferimento a molti file relativi a una directory di base (o root) comune."

#: ../../source/chapter/Finding Packages.rst:103
msgid "**<XX>_VERSION_<YY>**"
msgstr "**<XX>_VERSION_<YY>**"

#: ../../source/chapter/Finding Packages.rst:103
msgid ""
"Version <YY> of the package was found if true. Authors of find modules "
"should make sure at most one of these is ever true. For example "
"TCL_VERSION_84."
msgstr "Se true, è stata trovata la versione <YY> del pacchetto. Gli autori dei moduli find dovrebbero assicurarsi che al massimo uno di questi non sia mai vero. Per esempio TCL_VERSION_84."

#: ../../source/chapter/Finding Packages.rst:106
msgid "**<XX>_<YY>_FOUND**"
msgstr "**<XX>_<YY>_FOUND**"

#: ../../source/chapter/Finding Packages.rst:106
msgid "If false, then the optional <YY> part of <XX> package is unavailable."
msgstr "Se false, la parte facoltativa <YY> del pacchetto <XX> non è disponibile."

#: ../../source/chapter/Finding Packages.rst:109
msgid "**<XX>_FOUND**"
msgstr "**<XX>_FOUND**"

#: ../../source/chapter/Finding Packages.rst:109
msgid "Set to false or undefined if we haven't found or don't want to use <XX>."
msgstr "Impostato su false o indefinito se non abbiamo trovato o non vogliamo utilizzare <XX>."

#: ../../source/chapter/Finding Packages.rst:111
msgid ""
"Not all of the variables are present in each of the ``FindXX.cmake "
"files``. However, the ``<XX>_FOUND`` should exist under most "
"circumstances. If ``<XX>`` is a library, then ``<XX>_LIBRARIES`` should "
"also be defined, and ``<XX>_INCLUDE_DIR`` should usually be defined."
msgstr "Non tutte le variabili sono presenti in ciascuno dei file ``FindXX.cmake``. Tuttavia, nella maggior parte dei casi, ``<XX>_FOUND`` dovrebbe esistere. Se ``<XX>`` è una libreria, si devono definire anche ``<XX>_LIBRARIES`` e ``<XX>_INCLUDE_DIR``."

#: ../../source/chapter/Finding Packages.rst:117
msgid ""
"Modules can be included in a project either with the :command:`include` "
"command or the :command:`find_package` command."
msgstr "I moduli possono essere inclusi in un progetto sia col comando :command:`include` che con :command:`find_package`."

#: ../../source/chapter/Finding Packages.rst:124
msgid "is equivalent to:"
msgstr "è equivalente a:"

#: ../../source/chapter/Finding Packages.rst:130
msgid "and"
msgstr "e"

#: ../../source/chapter/Finding Packages.rst:136
msgid ""
"If the project converts over to CMake for its build system, the "
":command:`find_package` will still work if the package provides a "
"``<XX>Config.cmake`` file. How to create a CMake package is described "
"later in this chapter."
msgstr "Se il progetto viene convertito in CMake per il suo sistema di build, :command:`find_package` funzionerà ancora se il pacchetto fornisce un file ``<XX>Config.cmake``. Come creare un pacchetto CMake è descritto più avanti in questo capitolo."

#: ../../source/chapter/Finding Packages.rst:143
msgid "Creating CMake Package Configuration Files"
msgstr "Creazione dei File di Configurazione del Pacchetto CMake"

#: ../../source/chapter/Finding Packages.rst:145
msgid ""
"Projects must provide package configuration files so that outside "
"applications can find them. Consider a simple project \"Gromit\" "
"providing an executable to generate source code and a library against "
"which the generated code must link. The ``CMakeLists.txt`` file might "
"start with:"
msgstr "I progetti devono fornire i file di configurazione del pacchetto in modo che le applicazioni esterne possano trovarli. Si consideri un semplice progetto \"Gromit\" che fornisce un eseguibile per generare il codice sorgente e una libreria a cui il codice generato deve linkarsi. Il file ``CMakeLists.txt`` potrebbe iniziare con:"

#: ../../source/chapter/Finding Packages.rst:161
msgid ""
"In order to install Gromit and export its targets for use by outside "
"projects, add the code:"
msgstr "Per installare Gromit ed esportare i suoi target per l'utilizzo da parte di progetti esterni, si aggiunge il codice:"

#: ../../source/chapter/Finding Packages.rst:174
msgid ""
"Finally, Gromit must provide a package configuration file in its "
"installation tree so that outside projects can locate it with "
":command:`find_package`:"
msgstr "Infine, Gromit deve fornire un file di configurazione del pacchetto nel suo albero di installazione in modo che i progetti esterni possano individuarlo con :command:`find_package`:"

#: ../../source/chapter/Finding Packages.rst:192
msgid ""
"This code configures and installs the package configuration file and a "
"corresponding package version file. The package configuration input file "
"``gromit-config.cmake.in`` has the code:"
msgstr "Questo codice configura e installa il file di configurazione del pacchetto e un corrispondente file di versione. Il file di input della configurazione del pacchetto ``gromit-config.cmake.in`` contiene il codice:"

#: ../../source/chapter/Finding Packages.rst:208
msgid ""
"After installation, the configured package configuration file ``gromit-"
"config.cmake`` knows the locations of other installed files relative to "
"itself. The corresponding package version file is configured from its "
"input file ``gromit-config-version.cmake.in``, which contains code such "
"as:"
msgstr "Dopo l'installazione, il file di configurazione del pacchetto configurato ``gromit-config.cmake`` conosce le posizioni degli altri file installati rispetto a se stesso. Il file della versione corrispondente del pacchetto è configurato dal suo file di input ``gromit-config-version.cmake.in``, che contiene codice come:"

#: ../../source/chapter/Finding Packages.rst:227
msgid ""
"An application that uses the Gromit package might create a CMake file "
"that looks like this:"
msgstr "Un'applicazione che utilizza il pacchetto Gromit potrebbe creare un file CMake simile al seguente:"

#: ../../source/chapter/Finding Packages.rst:243
msgid ""
"The call to :command:`find_package` locates an installation of Gromit or "
"terminates with an error message if none can be found (due to "
"``REQUIRED``). After the command succeeds, the Gromit package "
"configuration file ``gromit-config.cmake`` has been loaded, so Gromit "
"targets have been imported and variables like ``gromit_INCLUDE_DIRS`` "
"have been defined."
msgstr "La chiamata a :command:`find_package` individua un'installazione di Gromit o termina con un messaggio di errore se non viene trovato (a causa di ``REQUIRED``). Dopo che il comando ha avuto successo, il file di configurazione del pacchetto Gromit ``gromit-config.cmake`` è stato caricato, quindi i target Gromit sono stati importati e sono state definite variabili come ``gromit_INCLUDE_DIRS``."

#: ../../source/chapter/Finding Packages.rst:250
msgid ""
"The above example creates a package configuration file and places it in "
"the ``install`` tree. One may also create a package configuration file in"
" the ``build`` tree to allow applications to use the project without "
"installation. In order to do this, one extends Gromit's CMake file with "
"the code:"
msgstr "L'esempio precedente crea un file di configurazione del pacchetto e lo inserisce nell'albero ``install``. Si può anche creare un file di configurazione del pacchetto nell'albero ``build`` per consentire alle applicazioni di utilizzare il progetto senza installazione. Per fare ciò, si estende il file CMake di Gromit con il codice:"

#: ../../source/chapter/Finding Packages.rst:263
msgid ""
"This :command:`configure_file` call uses a different input file, "
"``gromit-config.cmake.in``, containing:"
msgstr "Questa chiamata a :command:`configure_file` utilizza un file di input diverso, ``gromit-config.cmake.in``, contenente:"

#: ../../source/chapter/Finding Packages.rst:274
msgid ""
"The package configuration file ``gromit-config.cmake`` placed in the "
"build tree provides the same information to an outside project as that in"
" the install tree, but refers to files in the source and build trees. It "
"shares an identical package version file ``gromit-config-version.cmake`` "
"which is placed in the install tree."
msgstr "Il file di configurazione del pacchetto ``gromit-config.cmake`` posizionato nell'albero di build fornisce a un progetto esterno le stesse informazioni di quelle nell'albero di installazione, ma fa riferimento ai file nell'albero dei sorgenti e di compilazione. Condivide un file di versione del pacchetto identico ``gromit-config-version.cmake`` che si trova nell'albero di installazione."

#: ../../source/chapter/Finding Packages.rst:281
msgid "CMake Package Registry"
msgstr "Registro CMake dei Pacchetti"

#: ../../source/chapter/Finding Packages.rst:283
msgid ""
"CMake provides two central locations to register packages that have been "
"built or installed anywhere on a system: a *User Package Registry* and a "
"*System Package Registry*. The :command:`find_package` command searches "
"the two package registries as two of the search steps specified in its "
"documentation.  The registries are especially useful for helping projects"
" find packages in non-standard install locations or directly in the "
"package build trees. A project may populate either the user or system "
"registry (using its own means) to refer to its location. In either case, "
"the package should store a package configuration file at the registered "
"location and optionally a package version file earlier in this chapter."
msgstr "CMake fornisce due posizioni centrali per registrare i pacchetti che sono stati compilati o installati ovunque su un sistema: un *User Package Registry* e un *System Package Registry*. Il comando :command:`find_package` cerca nei due registri dei pacchetti come due dei passi di ricerca specificati nella sua documentazione.  I registri sono particolarmente utili per aiutare i progetti a trovare i pacchetti in percorsi di installazione non standard o direttamente negli alberi di build dei pacchetti. Un progetto può popolare il registro utente o di sistema (usando i propri mezzi) per fare riferimento alla sua posizione. In entrambi i casi, il pacchetto dovrebbe memorizzare un file di configurazione del pacchetto nella posizione registrata e facoltativamente un file di versione del pacchetto precedentemente descritto in questo capitolo."

#: ../../source/chapter/Finding Packages.rst:295
msgid ""
"The *User Package Registry* is stored in a platform-specific, per-user "
"location.  On Windows it is stored in the Windows registry under a key in"
" ``HKEY_CURRENT_USER``. A ``<package>`` may appear under registry key"
msgstr "Lo *User Package Registry* è memorizzato in una posizione specifica della piattaforma per utente.  Su Windows è memorizzato nel registro di Windows sotto una chiave in ``HKEY_CURRENT_USER``. Un ``<package>`` potrebbe apparire sotto la chiave di registro"

#: ../../source/chapter/Finding Packages.rst:304
msgid ""
"as a ``REG_SZ`` value with arbitrary name that specifies the directory "
"containing the package configuration file. On UNIX platforms, the user "
"package registry is stored in the user home directory under "
"``~/.cmake/packages``. A ``<package>`` may appear under the directory"
msgstr "come valore ``REG_SZ`` con un nome arbitrario che specifica la directory contenente il file di configurazione del pacchetto. Sulle piattaforme UNIX, il registro del pacchetto utente è memorizzato nella directory home dell'utente in ``~/.cmake/packages``. Un ``<package>`` potrebbe apparire sotto la directory"

#: ../../source/chapter/Finding Packages.rst:313
msgid ""
"as a file with arbitrary name whose content specifies the directory "
"containing the package configuration file.  The "
":command:`export(PACKAGE)` command may be used to register a project "
"build tree in the user package registry. CMake does not currently provide"
" an interface to add install trees to the user package registry; "
"installers must be manually taught to register their packages if desired."
msgstr "come file con nome arbitrario il cui contenuto specifica la directory contenente il file di configurazione del pacchetto.  Il comando :command:`export(PACKAGE)` può essere utilizzato per registrare un albero di build del progetto nello \"user package registry\". CMake attualmente non fornisce un'interfaccia per aggiungere alberi di installazione al registro dei pacchetti utente; agli installatori deve essere insegnato manualmente a registrare i propri pacchetti, se lo si desidera."

#: ../../source/chapter/Finding Packages.rst:320
msgid ""
"The *System Package Registry* is stored in a platform-specific, system-"
"wide location. On Windows it is stored in the Windows registry under a "
"key in ``HKEY_LOCAL_MACHINE``. A ``<package>`` may appear under registry "
"key"
msgstr "Il *System Package Registry* è archiviato in una posizione specifica per la piattaforma, a livello di sistema. Su Windows è memorizzato nel registro di Windows sotto una chiave in ``HKEY_LOCAL_MACHINE``. Un ``<package>`` potrebbe apparire sotto la chiave di registro"

#: ../../source/chapter/Finding Packages.rst:329
msgid ""
"as a ``REG_SZ`` value with arbitrary name that specifies the directory "
"containing the package configuration file.  There is no system package "
"registry on non-Windows platforms.  CMake does not provide an interface "
"to add to the system package registry; installers must be manually taught"
" to register their packages if desired."
msgstr "come valore ``REG_SZ`` con un nome arbitrario che specifica la directory contenente il file di configurazione del pacchetto.  Non esiste un registro dei pacchetti di sistema su piattaforme diverse da Windows.  CMake non fornisce un'interfaccia da aggiungere al registro dei pacchetti di sistema; agli installatori deve essere insegnato manualmente a registrare i propri pacchetti, se lo si desidera."

#: ../../source/chapter/Finding Packages.rst:335
msgid ""
"Package registry entries are individually owned by the project "
"installations that they reference. A package installer is responsible for"
" adding its own entry and the corresponding uninstaller is responsible "
"for removing it. However, in order to keep the registries clean, the "
":command:`find_package` command automatically removes stale package "
"registry entries it encounters if it has sufficient permissions.  An "
"entry is considered stale if it refers to a directory that does not exist"
" or does not contain a matching package configuration file.  This is "
"particularly useful for user package registry entries created by the "
":command:`export(PACKAGE)` command for build trees which have no "
"uninstall event and are simply deleted by developers."
msgstr "Le voci di registro dei pacchetti sono di proprietà individuale delle installazioni del progetto a cui fanno riferimento. Un programma di installazione del pacchetto è responsabile dell'aggiunta della propria voce e il programma di disinstallazione corrispondente è responsabile della sua rimozione. Tuttavia, per mantenere puliti i registri, il comando :command:`find_package` rimuove automaticamente le voci di registro dei pacchetti obsoleti che incontra se dispone di autorizzazioni sufficienti.  Una voce è considerata obsoleta se fa riferimento a una directory che non esiste o che non contiene un file di configurazione del pacchetto corrispondente.  Questo è particolarmente utile per le voci di registro dei pacchetti utente create dal comando :command:`export(PACKAGE)` per costruire alberi che non hanno eventi di disinstallazione e vengono semplicemente cancellati dagli sviluppatori."

#: ../../source/chapter/Finding Packages.rst:348
msgid ""
"Package registry entries may have arbitrary name.  A simple convention "
"for naming them is to use content hashes, as they are deterministic and "
"unlikely to collide.  The :command:`export(PACKAGE)` command uses this "
"approach. The name of an entry referencing a specific directory is simply"
" the content hash of the directory path itself.  For example, a project "
"may create package registry entries such as"
msgstr "Le voci di registro dei pacchetti possono avere un nome arbitrario.  Una semplice convenzione per denominarli consiste nell'utilizzare gli hash di contenuto, poiché sono deterministici ed è improbabile che collidano.  Il comando :command:`export(PACKAGE)` utilizza questo approccio. Il nome di una voce che fa riferimento a una directory specifica è semplicemente l'hash del contenuto del path della directory stessa.  Ad esempio, un progetto può creare voci di registro del pacchetto come"

#: ../../source/chapter/Finding Packages.rst:364
msgid "on Windows, or"
msgstr "su  Windows, oppure"

#: ../../source/chapter/Finding Packages.rst:373
msgid ""
"on UNIX.  The command :command:`find_package(MyPackage)` will search the "
"registered locations for package configuration files. The search order "
"among package registry entries for a single package is unspecified. "
"Registered locations may contain package version files to tell "
":command:`find_package` whether a specific location is suitable for the "
"version requested."
msgstr "su UNIX.  Il comando :command:`find_package(MyPackage)` cercherà i path registrati per i file di configurazione del pacchetto. L'ordine di ricerca tra le voci di registro dei pacchetti per un singolo pacchetto non è specificato. Le posizioni registrate possono contenere file di versione del pacchetto per indicare a :command:`find_package` se una posizione specifica è adatta per la versione richiesta."

#: ../../source/chapter/Getting Started.rst:2
msgid "Getting Started"
msgstr "Per Iniziare"

#: ../../source/chapter/Getting Started.rst:5
msgid "Getting and Installing CMake on Your Computer"
msgstr "Ottenere e Installare CMake sul Computer"

#: ../../source/chapter/Getting Started.rst:7
msgid ""
"Before using CMake, you will need to install or build the CMake binaries "
"on your system. On many systems, you may find that CMake is already "
"installed or is available for installation with the standard package "
"manager tool for the system. Cygwin, Debian, FreeBSD, OS X MacPorts, Mac "
"OS X Fink, and many others all have CMake distributions."
msgstr "Prima di utilizzare CMake, si dovranno installare o creare i binari di CMake. Su molti sistemi, CMake è già installato o è disponibile per l'installazione col tool di gestione pacchetti standard. Cygwin, Debian, FreeBSD, OS X MacPorts, Mac OS X Fink e molti altri hanno tutti distribuzioni di CMake."

#: ../../source/chapter/Getting Started.rst:19
msgid ""
"If your system does not have a CMake package, you can find CMake "
"precompiled for many common architectures on the CMake `Download "
"<www.cmake.org/download>`_ page. Select the desired release and follow "
"the download instructions. CMake may be installed to any directory, so "
"root privileges are not required for installation."
msgstr "Se il sistema non ha un pacchetto CMake, lo si può trovare precompilato per molte architetture nella pagina di `Download <www.cmake.org/download>`_. Selezionare la versione desiderata e seguire le istruzioni per il download. CMake può essere installato in qualsiasi directory, quindi i privilegi di root non sono richiesti."

#: ../../source/chapter/Getting Started.rst:25
msgid ""
"If you do not find precompiled binaries for your system, then you can "
"build CMake from source. To build CMake, you will need a modern C++ "
"compiler and the source distribution from the `CMake Download "
"<http://www.cmake.org/download>`_ page or `Kitware’s GitLab instance "
"<https://gitlab.kitware.com/cmake/cmake>`_. To build CMake, follow the "
"instructions in ``Readme.txt`` at the top of the source tree."
msgstr "Se non si trovano i binari precompilati per il proprio sistema, si può creare CMake dal sorgente. Per creare CMake, c'è bisogno di un compilatore C++ moderno e dei sorgenti dalla pagina di `Download di CMake <http://www.cmake.org/download>`_ o dall'istanza GitLab di `Kitware <https://gitlab.kitware.com/cmake/cmake>`_. Per creare CMake, seguire le istruzioni nel ``Readme.txt`` nella root dell'albero dei sorgenti."

#: ../../source/chapter/Getting Started.rst:34
msgid "Directory Structure"
msgstr "Struttura della Directory"

#: ../../source/chapter/Getting Started.rst:36
msgid ""
"There are two main directories CMake uses when building a project: the "
"source directory and the binary directory. The source directory is where "
"the source code for the project is located. This is also where the "
"CMakeLists files will be found. The binary directory is sometimes "
"referred to as the build directory and is where CMake will put the "
"resulting object files, libraries, and executables. CMake will not write "
"any files to the source directory, only to the binary directory."
msgstr "Esistono due directory principali utilizzate da CMake durante la creazione di un progetto: la directory dei sorgenti e la directory dei binari. La directory dei sorgenti è dove si trova il codice sorgente per il progetto. Questo è anche il punto in cui verranno si troveranno i file CMakeLists. La directory dei binari è talvolta indicata come directory di build ed è dove CMake inserirà i file oggetto, le librerie e gli eseguibili risultanti. CMake non scriverà alcun file nella directory dei sorgenti, solo in quella dei binari."

#: ../../source/chapter/Getting Started.rst:44
msgid ""
"Out-of-source builds, where the source and binary directories are "
"different, are strongly encouraged. In-source builds where the source and"
" binary directories are the same are supported but should be avoided if "
"possible. Out-of-source builds make it very easy to maintain a clean "
"source tree and allow quick removal of all of the files generated by a "
"build. Having the build tree differ from the source tree also makes it "
"easy to support having multiple builds of a single source tree. This is "
"useful when you want to have multiple builds with different options but "
"just one copy of the source code."
msgstr "Le build \"out-of-source\", in cui le directory dei sorgenti e dei binarie sono diverse, sono fortemente volute. Le build \"in-source\" in cui le directory dei sorgenti e dei binari sono le stesse sono supportate, ma dovrebbero essere evitate se possibile. Le build \"out-of-source\" facilitano molto la manutenzione di un albero dei sorgenti pulito e consentono una rapida rimozione di tutti i file generati da una build. Il fatto che l'albero di compilazione sia diverso da quello dei sorgenti semplifica anche il supporto di più build di un singolo albero di sorgenti. Questo è utile quando si vogliono avere più build con diverse opzioni ma solo una copia del codice sorgente."

#: ../../source/chapter/Getting Started.rst:55
msgid "Basic CMake Usage"
msgstr "Utilizzo di Base di CMake"

#: ../../source/chapter/Getting Started.rst:57
msgid ""
"CMake takes one or more CMakeLists files as input and produces project "
"files or Makefiles for use with a wide variety of native development "
"tools."
msgstr "CMake accetta uno o più file CMakeLists come input e produce file di progetto o Makefile da utilizzare con un'ampia varietà di strumenti di sviluppo nativi."

#: ../../source/chapter/Getting Started.rst:60
msgid "The typical CMake process is as follows:"
msgstr "Il processo tipico di CMake è il seguente:"

#: ../../source/chapter/Getting Started.rst:62
msgid "The project is defined in one or more CMakeLists files"
msgstr "Il progetto è definito in uno o più file CMakeLists"

#: ../../source/chapter/Getting Started.rst:63
msgid "CMake configures and generates the project"
msgstr "CMake configura e genera il progetto"

#: ../../source/chapter/Getting Started.rst:64
msgid "Users build project with their favorite native development tool"
msgstr "Gli utenti creano progetti con il loro strumento di sviluppo nativo preferito"

#: ../../source/chapter/Getting Started.rst:66
msgid "Each step of the process is described in detail in the following sections."
msgstr "Ogni fase del processo è descritta in dettaglio nelle sezioni seguenti."

#: ../../source/chapter/Getting Started.rst:70
msgid "CMakeLists Files"
msgstr "I File CMakeLists"

#: ../../source/chapter/Getting Started.rst:72
msgid ""
"The CMakeLists files (actually ``CMakeLists.txt`` but it is common to "
"leave off the extension) are plain text files that contain the project "
"description in CMake's Language. The :manual:`cmake-language <cmake-"
"language(7)>` is expressed as a series of comments, commands and "
"variables. You might wonder why CMake decided to have its own language "
"instead of using an existing one such as Python, Java, or Tcl. The main "
"reason is that CMake developers did not want to make CMake require an "
"additional tool to run. By requiring one of these other languages, all "
"users of CMake would be required to have that language installed, and "
"potentially a specific version of that language. This is on top of the "
"language extensions that would be required to do some of the CMake work, "
"for both performance and capability reasons."
msgstr "I file CMakeLists (in realtà ``CMakeLists.txt`` ma di solito si tralascia l'estensione) sono file di semplice testo che contengono la descrizione del progetto nel linguaggio di CMake. Il :manual:`cmake-language <cmake-language(7)>` è espresso come una serie di commenti, comandi e variabili. Si si potrebbe chiedere perché CMake ha deciso di avere il proprio linguaggio invece di usarne uno esistente come Python, Java o Tcl. Il motivo principale è che gli sviluppatori di CMake non volevano che CMake richiedesse uno strumento aggiuntivo per l'esecuzione. Richiedendo uno di questi altri linguaggi, tutti gli utenti di CMake dovrebbero avere tale linguaggio installato e potenzialmente una versione specifica. Questo è in cima alle estensioni del linguaggio che sarebbero necessarie per eseguire parte del lavoro di CMake, sia per motivi di prestazioni che di capacità."

#: ../../source/chapter/Getting Started.rst:86
msgid "Hello World for CMake"
msgstr "Lo \"Hello World\" di CMake"

#: ../../source/chapter/Getting Started.rst:88
msgid ""
"To begin, let us consider the simplest possible CMakeLists file. To "
"compile an executable from one source file, the CMakeLists file would "
"contain three lines:"
msgstr "Per iniziare, consideriamo il file CMakeLists più semplice possibile. Per compilare un eseguibile da un file sorgente, il file CMakeLists conterrebbe tre righe:"

#: ../../source/chapter/Getting Started.rst:98
msgid ""
"The first line of the top level CMakeLists file should always be "
":command:`cmake_minimum_required`. This allows projects to require a "
"given version of CMake and, in addition, allows CMake to be backwards "
"compatible."
msgstr "La prima riga del file CMakeLists di primo livello dovrebbe essere sempre :command:`cmake_minimum_required`. Ciò consente ai progetti di richiedere una determinata versione di CMake e, inoltre, consente a CMake di essere compatibile con le versioni precedenti."

#: ../../source/chapter/Getting Started.rst:102
msgid ""
"The next line of any top level CMakeLists file should be the "
":command:`project` command. This command sets the name of the project and"
" may specify other options such as language or version."
msgstr "La riga successiva di qualsiasi file CMakeLists di primo livello dovrebbe essere il comando :command:`project`. Questo comando imposta il nome del progetto e può specificare altre opzioni come il linguaggio o la versione."

#: ../../source/chapter/Getting Started.rst:106
msgid ""
"For each directory in a project where the CMakeLists.txt file invokes the"
" :command:`project` command, CMake generates a top-level Makefile or IDE "
"project file. The project will contain all targets that are in the "
"CMakeLists.txt file and any subdirectories, as specified by the "
":command:`add_subdirectory` command. If the :prop_dir:`EXCLUDE_FROM_ALL` "
"option is used in the :command:`add_subdirectory` command, the generated "
"project will not appear in the top-level Makefile or IDE project file; "
"this is useful for generating sub-projects that do not make sense as part"
" of the main build process. Consider that a project with a number of "
"examples could use this feature to generate the build files for each "
"example with one run of CMake, but not have the examples built as part of"
" the normal build process."
msgstr "Per ogni directory in un progetto in cui il file CMakeLists.txt richiama il comando :command:`project`, CMake genera un Makefile di primo livello o un file di progetto IDE. Il progetto conterrà tutti i target che si trovano nel file CMakeLists.txt e tutte le sottodirectory, come specificato dal comando :command:`add_subdirectory`. Se l'opzione :prop_dir:`EXCLUDE_FROM_ALL` è usata nel comando :command:`add_subdirectory`, il progetto generato non apparirà nel Makefile di primo livello o nel file di progetto IDE; questo è utile per generare sottoprogetti che non hanno senso come parte del processo di build principale. Si consideri che un progetto con un numero di esempi potrebbe utilizzare questa funzione per generare i file di build per ogni esempio con un'esecuzione di CMake, ma non avere gli esempi compilati come parte del normale processo di compilazione."

#: ../../source/chapter/Getting Started.rst:119
msgid ""
"Finally, use the :command:`add_executable` command to add an executable "
"to the project using the given source file."
msgstr "Infine, c'è il comando :command:`add_executable` per aggiungere un eseguibile al progetto utilizzando il file sorgente specificato."

#: ../../source/chapter/Getting Started.rst:122
msgid ""
"In this example, there are two files in the source directory: "
"``CMakeLists.txt`` and ``Hello.c``."
msgstr "In questo esempio, ci sono due file nella directory dei sorgenti: ``CMakeLists.txt`` e ``Hello.c``."

#: ../../source/chapter/Getting Started.rst:125
msgid ""
"The next sections will describe how to configure and build the project "
"using the CMake GUI and command line interfaces."
msgstr "Le sezioni successive descriveranno come configurare e creare il progetto utilizzando la GUI di CMake e le interfacce a riga di comando."

#: ../../source/chapter/Getting Started.rst:129
msgid "Configure and Generate"
msgstr "Configurare e Generare"

#: ../../source/chapter/Getting Started.rst:131
msgid ""
"After a CMakeLists file has been created, CMake processes the text file "
"and creates entries in a cache file. Users may edit the CMakeLists file "
"or specify cache values with the CMake gui or ccmake and re-configure. "
"Next, CMake uses the cache entries to generate a project in the user's "
"desired build system (e.g. Makefile or Visual Studio solution)."
msgstr "Dopo che un file CMakeLists è stato creato, CMake elabora il file di testo e crea le voci in un file di cache. Gli utenti possono modificare il file CMakeLists o specificare i valori della cache con l'interfaccia grafica di CMake o ccmake e riconfigurare. Successivamente, CMake utilizza le voci della cache per generare un progetto nel sistema di build desiderato dall'utente (ad es. Makefile o soluzione Visual Studio)."

#: ../../source/chapter/Getting Started.rst:138
msgid "Running the CMake GUI"
msgstr "Esecuzione della GUI di CMake"

#: ../../source/chapter/Getting Started.rst:140
msgid ""
"CMake includes a Qt-based user interface that can be used on most "
"platforms, including UNIX, Mac OS X, and Windows. The :manual:`cmake-gui "
"<cmake-gui(1)>` is included in the CMake source code, but you will need "
"an installation of Qt on your system in order to build it."
msgstr "CMake include un'interfaccia utente basata su Qt utilizzabile sulla maggior parte delle piattaforme, inclusi UNIX, Mac OS X e Windows. La :manual:`cmake-gui <cmake-gui(1)>` è inclusa nel codice sorgente di CMake, ma c'è bisogno di un'installazione di Qt sul sistema per compilarla."

#: ../../source/chapter/Getting Started.rst:149
msgid "Qt based CMake GUI"
msgstr "La GUI CMake basata su Qt"

#: ../../source/chapter/Getting Started.rst:151
msgid ""
"On Windows, the executable is named ``cmake-gui.exe`` and it should be in"
" your Start menu under Program Files. There may also be a shortcut on "
"your desktop, or if you built CMake from the source, it will be in the "
"build directory. For UNIX and Mac users, the executable is named ``cmake-"
"gui`` and it can be found where you installed the CMake executables. A "
"GUI will appear similar to what is shown in Figure :num:`figure-"
"QtbasedCMakeGUI`. The top two fields are the source code and binary "
"directories. They allow you to specify where the source code is located "
"for what you want to compile, and where the resulting binaries should be "
"placed. You should set these two values first. If the binary directory "
"you specify does not exist, it will be created for you. If the binary "
"directory has been configured by CMake before, it will then automatically"
" set the source tree."
msgstr "Su Windows, l'eseguibile si chiama ``cmake-gui.exe`` e dovrebbe trovarsi nel menù Start sotto Programmi. Potrebbe anche esserci un collegamento sul desktop o, se CMake è stato creato dai sorgenti, sarà nella directory di build. Per gli utenti UNIX e Mac, l'eseguibile si chiama ``cmake-gui`` e si trova dove sono installati gli eseguibili di CMake. Apparirà una GUI simile a quella mostrata in Figura :num:`figure-QtbasedCMakeGUI`. I primi due campi sono il codice sorgente e le directory dei file binari. Consentono di specificare dove si trova il codice sorgente per ciò che si desidera compilare e dove devono essere posizionati i binari risultanti. Si devono impostare per primi questi valori. Se la directory binaria specificata non esiste, verrà creata. Se la directory dei binari è stata configurata in precedenza da CMake, imposterà automaticamente l'albero dei sorgenti."

#: ../../source/chapter/Getting Started.rst:170
msgid "Running the ccmake Curses Interface"
msgstr "Esecuzione di ccmake con l'Interfaccia di Curses"

#: ../../source/chapter/Getting Started.rst:172
msgid ""
"On most UNIX platforms, if the curses library is supported, CMake "
"provides an executable called :manual:`ccmake <ccmake(1)>`. This "
"interface is a terminal-based text application that is very similar to "
"the :manual:`cmake-gui <cmake-gui(1)>`. To run :manual:`ccmake "
"<ccmake(1)>`, change directories into the directory where you want the "
"binaries to be placed. Then run :manual:`ccmake <ccmake(1)>` with the "
"path to the source directory on the command line. This will start the "
"text interface as shown in Figure :num:`figure-ccmakerunningonUNIX`."
msgstr "Sulla maggior parte delle piattaforme UNIX, se la libreria curses è supportata, CMake fornisce un eseguibile chiamato :manual:`ccmake <ccmake(1)>`. Questa interfaccia è un'applicazione testuale basata su terminale, molto simile a :manual:`cmake-gui <cmake-gui(1)>`. Per eseguire :manual:`ccmake <ccmake(1)>`, cambiare le directory in quella in cui si desidera posizionare i file binari. Poi eseguire :manual:`ccmake <ccmake(1)>` con il path della directory dei sorgenti sulla riga di comando. Questo avvierà l'interfaccia testuale come mostrato in Figura :num:`figure-ccmakerunningonUNIX`."

#: ../../source/chapter/Getting Started.rst:185
msgid "ccmake running on UNIX"
msgstr "ccmake in esecuzione su UNIX"

#: ../../source/chapter/Getting Started.rst:187
msgid ""
"Brief instructions are displayed in the bottom of the window. If you hit "
"the \"c\" key, it will configure the project. You should always configure"
" after changing values in the cache. To change values, use the arrow keys"
" to select cache entries, and hit the enter key to edit them. Boolean "
"values will toggle with the enter key. Once you have set all the values "
"as you like, you can hit the \"g\" key to generate the Makefiles and "
"exit. You can also hit \"h\" for help, \"q\" to quit, and \"t\" to toggle"
" the viewing of advanced cache entries."
msgstr "Delle brevi istruzioni vengono visualizzate nella parte inferiore della finestra. Premendo il tasto \"c\", si configurerà il progetto. Si deve sempre configurare dopo aver modificato i valori nella cache. Per modificare i valori, utilizzare i tasti freccia per selezionare le voci della cache e premere il tasto Invio per modificarle. I valori booleani verranno scambiati con il tasto Invio. Una volta impostati tutti i valori, si preme il tasto \"g\" per generare i Makefile ed uscire. Si può anche premere \"h\" per l'help, \"q\" per uscire e \"t\" per attivare o disattivare la visualizzazione delle voci avanzate della cache."

#: ../../source/chapter/Getting Started.rst:197
msgid "Running CMake from the Command Line"
msgstr "Esecuzione di CMake da Riga di Comando"

#: ../../source/chapter/Getting Started.rst:199
msgid ""
"From the command line, the :manual:`cmake <cmake(1)>` executable can be "
"used to generate a project buildsystem. This is best suited for projects "
"with few or no options. For larger projects like VTK, using "
":manual:`ccmake <ccmake(1)>`, or the :manual:`cmake-gui <cmake-gui(1)>` "
"is recommended. To build a project with :manual:`cmake <cmake(1)>`, first"
" create and change directory to where you want the binaries to be placed."
" Run :manual:`cmake <cmake(1)>` specifying the path to the source tree "
"and pass in any options using the ``-D`` flag. Unlike :manual:`ccmake "
"<ccmake(1)>`, or the :manual:`cmake-gui <cmake-gui(1)>`, the configure "
"and generate steps are combined into one when using the :manual:`cmake "
"<cmake(1)>` executable."
msgstr "Dalla riga di comando, l'eseguibile :manual:`cmake <cmake(1)>` è utilizzabile per generare un sistema di compilazione del progetto. Questo è adatto per progetti con poche o nessuna opzione. Per progetti più grandi come VTK, si consiglia di utilizzare :manual:`ccmake <ccmake(1)>` o :manual:`cmake-gui <cmake-gui(1)>`. Per creare un progetto con :manual:`cmake <cmake(1)>`, prima si crea e si modifica la directory in cui si desidera posizionare i file binari. Si esegue :manual:`cmake <cmake(1)>` specificando il path dell'alberatura dei sorgenti e si passa qualsiasi opzione usando il flag ``-D``. A differenza di :manual:`ccmake <ccmake(1)>`, o di :manual:`cmake-gui <cmake-gui(1)>`, i passaggi di configurazione e generazione sono combinati in uno solo quando si usa l'eseguibile :manual:`cmake <cmake(1)>`."

#: ../../source/chapter/Getting Started.rst:215
msgid "Specifying the Compiler to CMake"
msgstr "Specificare il compilatore per CMake"

#: ../../source/chapter/Getting Started.rst:220
msgid ""
"On some systems, you may have more than one compiler to choose from or "
"your compiler may be in a non-standard place. In these cases, you will "
"need to specify to CMake where your desired compiler is located. There "
"are three ways to specify this: the generator can specify the compiler; "
"an environment variable can be set; or a cache entry can be set. Some "
"generators are tied to a specific compiler; for example, the Visual "
"Studio 19 generator always uses the Microsoft Visual Studio 19 compiler. "
"For Makefile-based generators, CMake will try a list of usual compilers "
"until it finds a working one."
msgstr "Su alcuni sistemi, si potrebbero avere più di un compilatore tra cui scegliere o il compilatore potrebbe trovarsi in una posizione non standard. In questi casi, si dovrà specificare a CMake dove si trova il compilatore desiderato. Ci sono tre modi per farlo: il generatore può specificare il compilatore; è possibile impostare una variabile d'ambiente; oppure è possibile impostare una voce della cache. Alcuni generatori sono legati a un compilatore specifico; ad esempio, il generatore di Visual Studio 19 utilizza sempre il compilatore Microsoft Visual Studio 19. Per i generatori basati su Makefile, CMake proverà un elenco di compilatori soliti fino a quando non ne troverà uno funzionante."

#: ../../source/chapter/Getting Started.rst:233
msgid ""
"The lists can be preempted with environment variables that can be set "
"before CMake is run. The ``CC`` environment variable specifies the C "
"compiler, while ``CXX`` specifies the C++ compiler. You can specify the "
"compilers directly on the command line by using "
"``-DCMAKE_CXX_COMPILER=cl`` for example. Once :manual:`cmake <cmake(1)>` "
"has been run and picked a compiler, if you wish to change the compiler, "
"start over with an empty binary directory."
msgstr "Gli elenchi possono essere superati con variabili di ambiente impostabili prima dell'esecuzione di CMake. La variabile d'ambiente ``CC`` specifica il compilatore C, mentre ``CXX`` specifica quello C++. Si possono specificare i compilatori direttamente sulla riga di comando usando ``-DCMAKE_CXX_COMPILER=cl`` per esempio. Una volta che :manual:`cmake <cmake(1)>` è stato eseguito e si è scelto un compilatore, se si desidera cambiare il compilatore, si ricomincia daccapo con una directory binaria vuota."

#: ../../source/chapter/Getting Started.rst:241
msgid ""
"The flags for the compiler and the linker can also be changed by setting "
"environment variables. Setting ``LDFLAGS`` will initialize the cache "
"values for link flags, while ``CXXFLAGS`` and ``CFLAGS`` will initialize "
"``CMAKE_CXX_FLAGS`` and ``CMAKE_C_FLAGS`` respectively."
msgstr "I flag per il compilatore e il linker possono anche essere modificati impostando le variabili di ambiente. L'impostazione ``LDFLAGS`` inizializzerà i valori della cache per i flag dei link, mentre ``CXXFLAGS`` e ``CFLAGS`` inizializzeranno ``CMAKE_CXX_FLAGS`` e ``CMAKE_C_FLAGS`` rispettivamente."

#: ../../source/chapter/Getting Started.rst:250
msgid "Build Configurations"
msgstr "Configurazioni della Build"

#: ../../source/chapter/Getting Started.rst:252
msgid ""
"Build configurations allow a project to be built in different ways for "
"debug, optimized, or any other special set of flags. CMake supports, by "
"default, Debug, Release, MinSizeRel, and RelWithDebInfo configurations. "
"Debug has the basic debug flags turned on. Release has the basic "
"optimizations turned on. MinSizeRel has flags that produce the smallest "
"object code, but not necessarily the fastest code. RelWithDebInfo builds "
"an optimized build with debug information as well."
msgstr "Le configurazioni della build consentono di creare un progetto in modi diversi per il debug, per l'ottimizzazione o per qualsiasi altro set speciale di flag. CMake supporta, per default, le configurazioni Debug, Release, MinSizeRel e RelWithDebInfo. Debug ha i flag di debug di base attivati. Release ha le ottimizzazioni di base attivate. MinSizeRel ha flag che producono il codice oggetto più piccolo, ma non necessariamente quello più veloce. RelWithDebInfo crea una build ottimizzata anche con informazioni di debug."

#: ../../source/chapter/Getting Started.rst:264
msgid ""
"CMake handles the configurations in slightly different ways depending on "
"the generator being used. The conventions of the native build system are "
"followed when possible. This means that configurations impact the build "
"in different ways when using Makefiles versus using Visual Studio project"
" files."
msgstr "CMake gestisce le configurazioni in modi leggermente diversi a seconda del generatore utilizzato. Quando possibile, vengono seguite le convenzioni del sistema di build nativo. Ciò significa che le configurazioni influiscono sulla build in modi diversi quando si usano i Makefile rispetto ai file di progetto di Visual Studio."

#: ../../source/chapter/Getting Started.rst:270
msgid ""
"The Visual Studio IDE supports the notion of Build Configurations. A "
"default project in Visual Studio usually has Debug and Release "
"configurations. From the IDE you can select build Debug, and the files "
"will be built with Debug flags. The IDE puts all of the binary files into"
" directories with the name of the active configuration. This brings about"
" an extra complexity for projects that build programs that need to be run"
" as part of the build process from custom commands. See the "
":variable:`CMAKE_CFG_INTDIR` variable and the custom commands section for"
" more information about how to handle this issue. The variable "
":variable:`CMAKE_CONFIGURATION_TYPES` is used to tell CMake which "
"configurations to put in the workspace."
msgstr "L'IDE di Visual Studio supporta la nozione di Build Configuration. Un progetto di default in Visual Studio ha in genere configurazioni di Debug e di Release. Dall'IDE è possibile selezionare build Debug e i file verranno compilati con i flag Debug. L'IDE inserisce tutti i file binari nelle directory con il nome della configurazione attiva. Ciò comporta un'ulteriore complessità per i progetti che compilano programmi che devono essere eseguiti come parte del processo di build da comandi personalizzati. Consultare la variabile :variable:`CMAKE_CFG_INTDIR` e la sezione dei comandi personalizzati per ulteriori informazioni su come gestire questo problema. La variabile :variable:`CMAKE_CONFIGURATION_TYPES` viene utilizzata per indicare a CMake quali configurazioni inserire nell'area di lavoro [workspace]."

#: ../../source/chapter/Getting Started.rst:287
msgid ""
"With Makefile-based generators, only one configuration can be active at "
"the time CMake is run, and it is specified with the "
":variable:`CMAKE_BUILD_TYPE` variable. If the variable is empty then no "
"flags are added to the build. If the variable is set to the name of a "
"configuration, then the appropriate variables and rules (such as "
"``CMAKE_CXX_FLAGS_<ConfigName>``) are added to the compile lines. "
"Makefiles do not use special configuration subdirectories for object "
"files. To build both debug and release trees, the user is expected to "
"create multiple build directories using the out-of-source build feature "
"of CMake, and set the :variable:`CMAKE_BUILD_TYPE` to the desired "
"selection for each build. For example:"
msgstr "Con i generatori basati su Makefile, solo una configurazione può essere attiva al momento dell'esecuzione di CMake ed è specificata con la variabile \n"
":variable:`CMAKE_BUILD_TYPE`. Se la variabile è vuota, non vengono aggiunti flag alla build. Se la variabile è impostata sul nome di una configurazione, le variabili e le regole appropriate (come ``CMAKE_CXX_FLAGS_<ConfigName>``) vengono aggiunte alle righe di compilazione. I makefile non usano sottodirectory di configurazione speciali per i file oggetto. Per creare alberature di debug e release, l'utente deve creare più directory di build utilizzando la funzionalità di build out-of-source di CMake e impostare :variable:`CMAKE_BUILD_TYPE` sulla selezione desiderata per ogni build. Per esempio:"

#: ../../source/chapter/Getting Started.rst:309
msgid "Building Your Project"
msgstr "Building del Progetto"

#: ../../source/chapter/Getting Started.rst:311
msgid ""
"After you have run CMake, your project will be ready to be built. If your"
" target generator is based on Makefiles then you can build your project "
"by changing the directory to your binary tree and typing make (or gmake "
"or nmake as appropriate). If you generated files for an IDE such as "
"Visual Studio, you can start your IDE, load the project files into it, "
"and build as you normally would."
msgstr "Dopo aver eseguito CMake, il progetto sarà pronto per il building. Se il generatore target è basato su Makefile, si può creare il progetto cambiando la directory nell'albero binario e digitando make (o gmake o nmake a seconda dei casi). Se è stato generato un file per un IDE come Visual Studio, si avviare l'IDE, caricarvi i file di progetto e compilare come si farebbe normalmente."

#: ../../source/chapter/Getting Started.rst:318
msgid ""
"Another option is to use :manual:`cmake <cmake(1)>`'s ``--build`` option "
"from the command line. This option is simply a convenience that allows "
"you to build your project from the command line, even if that requires "
"launching an IDE."
msgstr "Un'altra possibilità è quella di usare l'opzione di :manual:`cmake <cmake(1)>` ``--build`` dalla riga di comando. Questa opzione è semplicemente una comodità che consente di creare il progetto dalla riga di comando, anche se ciò richiede l'avvio di un IDE."

#: ../../source/chapter/Getting Started.rst:323
msgid ""
"That is all there is to installing and running CMake for simple projects."
" In the following chapters, we will consider CMake in more detail and "
"explain how to use it on more complex software projects."
msgstr "Questo è tutto ciò che serve per installare ed eseguire CMake per progetti semplici. Nei capitoli seguenti considereremo CMake in modo più dettagliato e spiegheremo come utilizzarlo su progetti software più complessi."

#: ../../source/chapter/Install.rst:2 ../../source/chapter/Install.rst:265
msgid "Installing Files"
msgstr "Installazione di File"

#: ../../source/chapter/Install.rst:4
msgid ""
"Software is typically installed into a directory separate from the source"
" and build trees. This allows it to be distributed in a clean form and "
"isolates users from the details of the build process. CMake provides the "
":command:`install` command to specify how a project is to be installed. "
"This command is invoked by a project in the CMakeLists file and tells "
"CMake how to generate installation scripts. The scripts are executed at "
"install time to perform the actual installation of files. For Makefile "
"generators (UNIX, NMake, MinGW, etc.), the user simply runs ``make "
"install`` (or ``nmake install``) and the make tool will invoke CMake's "
"installation module. With GUI based systems (Visual Studio, Xcode, etc.),"
" the user simply builds the target called ``INSTALL``."
msgstr "Il software viene in genere installato in una directory separata dalle directory dei sorgenti e da quelle di build. Ciò consente di distribuirlo in una forma pulita e isola gli utenti dai dettagli del processo di build. CMake fornisce il comando :command:`install` per specificare come deve essere installato un progetto. Questo comando viene richiamato da un progetto nel file CMakeLists e indica a CMake come generare gli script di installazione. Gli script vengono eseguiti al momento dell'installazione per fare l'effettiva installazione dei file. Per i generatori di Makefile (UNIX, NMake, MinGW, ecc.), l'utente esegue semplicemente ``make install`` (o ``nmake install``) e lo strumento make invocherà il modulo di installazione di CMake. Con i sistemi basati su GUI (Visual Studio, Xcode, ecc.), l'utente builda semplicemente il target chiamato ``INSTALL``."

#: ../../source/chapter/Install.rst:17
msgid ""
"Each call to the :command:`install` command defines some installation "
"rules. Within one CMakeLists file (source directory), these rules will be"
" evaluated in the order that the corresponding commands are invoked. The "
"order across multiple directories changed in CMake 3.14."
msgstr "Ogni chiamata al comando :command:`install` definisce alcune regole di installazione. All'interno di un file CMakeLists (directory sorgente), queste regole verranno valutate nell'ordine in cui vengono richiamati i comandi corrispondenti. L'ordine tra directory multiple è cambiato in CMake 3.14."

#: ../../source/chapter/Install.rst:22
msgid ""
"The :command:`install` command has several signatures designed for common"
" installation use cases. A particular invocation of the command specifies"
" the signature as the first argument. The signatures are ``TARGETS``, "
"``FILES`` or ``PROGRAMS``, ``DIRECTORY``, ``SCRIPT``, ``CODE`` and "
"``EXPORT``."
msgstr "Il comando :command:`install` ha diverse firme progettate per casi d'uso di installazione comuni. Una particolare invocazione del comando specifica la firma come primo argomento. Le firme [signature] sono ``TARGETS``, ``FILES`` o ``PROGRAMS``, ``DIRECTORY``, ``SCRIPT``, ``CODE`` e ``EXPORT``."

#: ../../source/chapter/Install.rst:30
msgid "**install(TARGETS ...)**"
msgstr "**install(TARGETS ...)**"

#: ../../source/chapter/Install.rst:29
msgid ""
"Installs the binary files corresponding to targets built inside the "
"project."
msgstr "Installa i file binari corrispondenti ai target compilati all'interno del progetto."

#: ../../source/chapter/Install.rst:35
msgid "**install(FILES ...)**"
msgstr "**install(FILES ...)**"

#: ../../source/chapter/Install.rst:33
msgid ""
"General-purpose file installation, which is typically used for header "
"files, documentation, and data files required by your software."
msgstr "Installa file per uso generico, generalmente utilizzata per file header, documentazione e file di dati richiesti dal software."

#: ../../source/chapter/Install.rst:41
msgid "**install(PROGRAMS ...)**"
msgstr "**install(PROGRAMS ...)**"

#: ../../source/chapter/Install.rst:38
msgid ""
"Installs executable files not built by the project, such as shell "
"scripts. This argument is identical to ``install(FILES)`` except that the"
" default permissions of the installed file include the executable bit.`"
msgstr "Installa i file eseguibili non compilati dal progetto, come gli script della shell. Questo argomento è identico a ``install(FILES)`` tranne per il fatto che i permessi di default del file installato includono il bit eseguibile."

#: ../../source/chapter/Install.rst:45
msgid "**install(DIRECTORY ...)**"
msgstr "**install(DIRECTORY ...)**"

#: ../../source/chapter/Install.rst:44
msgid ""
"This argument installs an entire directory tree. It may be used for "
"installing directories with resources, such as icons and images."
msgstr "Questo argomento installa un intero albero di directory. Può essere utilizzato per installare directory con risorse, come icone e immagini."

#: ../../source/chapter/Install.rst:50
msgid "**install(SCRIPT ...)**"
msgstr "**install(SCRIPT ...)**"

#: ../../source/chapter/Install.rst:48
msgid ""
"Specifies a user-provided CMake script file to be executed during "
"installation. This is typically used to define pre-install or post-"
"install actions for other rules."
msgstr "Specifica un file di script CMake fornito dall'utente da eseguire durante l'installazione. Questo è in genere utilizzato per definire le azioni pre-installazione o post-installazione per altre regole."

#: ../../source/chapter/Install.rst:55
msgid "**install(CODE ...)**"
msgstr "**install(CODE ...)**"

#: ../../source/chapter/Install.rst:53
msgid ""
"Specifies user-provided CMake code to be executed during the "
"installation. This is similar to ``install (SCRIPT)`` but the code is "
"provided inline in the call as a string."
msgstr "Specifica il codice CMake fornito dall'utente da eseguire durante l'installazione. È simile a ``install (SCRIPT)`` ma il codice viene fornito in linea nella chiamata come stringa."

#: ../../source/chapter/Install.rst:59
msgid "**install(EXPORT ...)**"
msgstr "**install(EXPORT ...)**"

#: ../../source/chapter/Install.rst:58
msgid ""
"Generates and installs a CMake file containing code to import targets "
"from the installation tree into another project."
msgstr "Genera e installa un file CMake contenente il codice per importare i target dall'albero di installazione in un altro progetto."

#: ../../source/chapter/Install.rst:61
msgid ""
"The ``TARGETS``, ``FILES``, ``PROGRAMS``, and ``DIRECTORY`` signatures "
"are all meant to create install rules for files. The targets, files, or "
"directories to be installed are listed immediately after the signature "
"name argument. Additional details can be specified using keyword "
"arguments followed by corresponding values. Keyword arguments provided by"
" most of the signatures are as follows."
msgstr "Le firme ``TARGETS``, ``FILES``, ``PROGRAMS`` e ``DIRECTORY`` hanno tutte lo scopo di creare regole di installazione per i file. I target, i file o le directory da installare sono elencati immediatamente dopo l'argomento del nome della firma. Ulteriori dettagli possono essere specificati utilizzando argomenti di parole chiave seguiti dai valori corrispondenti. Gli argomenti delle parole chiave forniti dalla maggior parte delle firme sono i seguenti."

#: ../../source/chapter/Install.rst:79
msgid "**DESTINATION**"
msgstr "**DESTINATION**"

#: ../../source/chapter/Install.rst:68
msgid ""
"This argument specifies the location where the installation rule will "
"place files, and must be followed by a directory path indicating the "
"location. If the directory is specified as a full path, it will be "
"evaluated at install time as an absolute path. If the directory is "
"specified as a relative path, it will be evaluated at install time "
"relative to the installation prefix. The prefix may be set by the user "
"through the cache variable :variable:`CMAKE_INSTALL_PREFIX`. A platform-"
"specific default is provided by CMake: ``/usr/local`` on UNIX, and "
"\"<SystemDrive>/``Program Files``/<ProjectName>\" on Windows, where "
"SystemDrive is along the lines of ``C:`` and ProjectName is the name "
"given to the top-most :command:`project` command."
msgstr "Questo argomento specifica la posizione in cui la regola di installazione inserirà i file e deve essere seguito da un path di directory che indica la posizione. Se la directory viene specificata come percorso completo, verrà valutata al momento dell'installazione come path assoluto. Se la directory è specificata come percorso relativo, verrà valutata al momento dell'installazione rispetto al prefisso di installazione. Il prefisso può essere impostato dall'utente tramite la variabile cache :variable:`CMAKE_INSTALL_PREFIX`. CMake fornisce un'impostazione di default specifica per la piattaforma: ``/usr/local`` su UNIX e \"<SystemDrive>/``Program Files``/<ProjectName>\" su Windows, dove SystemDrive è sulla falsariga di ``C:`` e ProjectName è il nome dato al comando :command:`project` più in alto."

#: ../../source/chapter/Install.rst:93
msgid "**PERMISSIONS**"
msgstr "**PERMISSIONS**"

#: ../../source/chapter/Install.rst:85
msgid ""
"This argument specifies file permissions to be set on the installed "
"files. This option is needed only to override the default permissions "
"selected by a particular :command:`install` command signature. Valid "
"permissions are ``OWNER_READ``, ``OWNER_WRITE``, ``OWNER_EXECUTE``, "
"``GROUP_READ``, ``GROUP_WRITE``, ``GROUP_EXECUTE``, ``WORLD_READ``, "
"``WORLD_WRITE``, ``WORLD_EXECUTE``, ``SETUID``, and ``SETGID``. Some "
"platforms do not support all of these permissions; on such platforms "
"those permission names are ignored."
msgstr "Questo argomento specifica le autorizzazioni da impostare sui file installati. Questa opzione è necessaria solo per sovrascrivere le autorizzazioni di default selezionate da una particolare firma del comando :command:`install`. I permessi validi sono ``OWNER_READ``, ``OWNER_WRITE``, ``OWNER_EXECUTE``, ``GROUP_READ``, ``GROUP_WRITE``, ``GROUP_EXECUTE``, ``WORLD_READ``, ``WORLD_WRITE``, ``WORLD_EXECUTE``, ``SETUID`` e ``SETGID``. Alcune piattaforme non supportano tutte queste autorizzazioni; su queste tali nomi di autorizzazione vengono ignorati."

#: ../../source/chapter/Install.rst:106
msgid "**CONFIGURATIONS**"
msgstr "**CONFIGURATIONS**"

#: ../../source/chapter/Install.rst:99
msgid ""
"This argument specifies a list of build configurations for which an "
"installation rule applies (Debug, Release, etc.). For Makefile "
"generators, the build configuration is specified by the "
":variable:`CMAKE_BUILD_TYPE` cache variable. For Visual Studio and Xcode "
"generators, the configuration is selected when the :command:`install` "
"target is built. An installation rule will be evaluated only if the "
"current install configuration matches an entry in the list provided to "
"this argument. Configuration name comparison is case-insensitive."
msgstr "Questo argomento specifica un elenco di configurazioni di build per le quali si applica una regola di installazione (Debug, Release e così via). Per i generatori di Makefile, la configurazione della build è specificata dalla variabile della cache :variable:`CMAKE_BUILD_TYPE`. Per i generatori di Visual Studio e Xcode, la configurazione viene selezionata quando viene creato il target :command:`install`. Una regola di installazione verrà valutata solo se la configurazione dell'installazione corrente corrisponde a una voce nell'elenco fornito a questo argomento. Il confronto dei nomi di configurazione non fa distinzione tra maiuscole e minuscole."

#: ../../source/chapter/Install.rst:126
msgid "**COMPONENT**"
msgstr "**COMPONENT**"

#: ../../source/chapter/Install.rst:112
msgid ""
"This argument specifies the installation component for which the "
"installation rule applies. Some projects divide their installations into "
"multiple components for separate packaging. For example, a project may "
"define a ``Runtime`` component that contains the files needed to run a "
"tool; a ``Development`` component containing the files needed to build "
"extensions to the tool; and a ``Documentation`` component containing the "
"manual pages and other help files. The project may then package each "
"component separately for distribution by installing only one component at"
" a time. By default, all components are installed. Component-specific "
"installation is an advanced feature intended for use by package "
"maintainers. It requires manual invocation of the installation scripts "
"with an argument defining the ``COMPONENT`` variable to name the desired "
"component. Note that component names are not defined by CMake. Each "
"project may define its own set of components."
msgstr "Questo argomento specifica il componente dell'installazione per il quale si applica la regola di installazione. Alcuni progetti suddividono le loro installazioni in più componenti per packaging separati. Ad esempio, un progetto può definire un componente ``Runtime`` che contiene i file necessari per eseguire un tool; un componente ``Development`` contenente i file necessari per creare estensioni per il tool; e un componente ``Documentation`` contenente le pagine del manuale e altri file di aiuto. Il progetto può quindi impacchettare ciascun componente separatamente per la distribuzione installando un solo componente alla volta. Per default, tutti i componenti vengono installati. L'installazione \"component-specific\" è una funzionalità avanzata destinata all'uso da parte dei manutentori dei pacchetti. Richiede l'invocazione manuale degli script di installazione con un argomento che definisce la variabile ``COMPONENT`` per denominare il componente desiderato. Si noti che i nomi dei componenti non sono definiti da CMake. Ogni progetto può definire il proprio insieme di componenti."

#: ../../source/chapter/Install.rst:135
msgid "**OPTIONAL**"
msgstr "**OPTIONAL**"

#: ../../source/chapter/Install.rst:132
msgid ""
"This argument specifies that it is not an error if the input file to be "
"installed does not exist. If the input file exists, it will be installed "
"as requested. If it does not exist, it will be silently not installed."
msgstr "Questo argomento specifica che non è un errore se il file di input da installare non esiste. Se il file di input esiste, verrà installato come richiesto. Se non esiste, verrà tacitamente non installato."

#: ../../source/chapter/Install.rst:138
msgid "Installing Targets"
msgstr "Installazione dei Target"

#: ../../source/chapter/Install.rst:140
msgid ""
"Projects typically install some of the library and executable files "
"created during their build process. The :command:`install` command "
"provides the ``TARGETS`` signature for this purpose."
msgstr "I progetti in genere installano parte della libreria e dei file eseguibili creati durante il processo di build. Il comando :command:`install` fornisce la firma ``TARGETS`` per questo scopo."

#: ../../source/chapter/Install.rst:144
msgid ""
"The ``TARGETS`` keyword is immediately followed by a list of the targets "
"created using :command:`add_executable` or :command:`add_library`, which "
"are to be installed. One or more files corresponding to each target will "
"be installed."
msgstr "La parola chiave ``TARGETS`` viene immediatamente seguita da un elenco dei target creati utilizzando :command:`add_executable` o :command:`add_library` e che devono essere installati. Verranno installati uno o più file corrispondenti a ciascun target."

#: ../../source/chapter/Install.rst:149
msgid ""
"Files installed with this signature may be divided into categories such "
"as ``ARCHIVE``, ``LIBRARY``, or ``RUNTIME``. These categories are "
"designed to group target files by typical installation destination. The "
"corresponding keyword arguments are optional, but if present, specify "
"that other arguments following them apply only to target files of that "
"type. Target files are categorized as follows:"
msgstr "I file installati con questa firma possono essere suddivisi in categorie come ``ARCHIVE``, ``LIBRARY`` o ``RUNTIME``. Tali categorie sono progettate per raggruppare i file target in base alla destinazione di installazione tipica. Gli argomenti delle parole chiave corrispondenti sono facoltativi, ma se presenti, specifica che gli altri argomenti che li seguono si applicano solo ai file target di quel tipo. I file target sono classificati come segue:"

#: ../../source/chapter/Install.rst:157
msgid "**executables -** ``RUNTIME``"
msgstr "**executables -** ``RUNTIME``"

#: ../../source/chapter/Install.rst:157
msgid ""
"Created by :command:`add_executable` (.exe on Windows, no extension on "
"UNIX)"
msgstr "Creato da :command:`add_executable` (.exe su Windows, senza estensione su UNIX)"

#: ../../source/chapter/Install.rst:161
msgid "**loadable modules -** ``LIBRARY``"
msgstr "**loadable modules -** ``LIBRARY``"

#: ../../source/chapter/Install.rst:160
msgid ""
"Created by :command:`add_library` with the ``MODULE`` option (.dll on "
"Windows, .so on UNIX)"
msgstr "Creato da :command:`add_library` con l'opzione ``MODULE`` (.dll su Windows, .so su UNIX)"

#: ../../source/chapter/Install.rst:165
msgid "**shared libraries -** ``LIBRARY``"
msgstr "**shared libraries -** ``LIBRARY``"

#: ../../source/chapter/Install.rst:164
msgid ""
"Created by :command:`add_library` with the ``SHARED`` option on UNIX-like"
" platforms (.so on most UNIX, .dylib on Mac)"
msgstr "Creato da :command:`add_library` con l'opzione ``SHARED`` su piattaforme simili a UNIX (.so sulla maggior parte degli UNIX, .dylib su Mac)"

#: ../../source/chapter/Install.rst:169
msgid "**dynamic-link libraries -** ``RUNTIME``"
msgstr "**dynamic-link libraries -** ``RUNTIME``"

#: ../../source/chapter/Install.rst:168
msgid ""
"Created by :command:`add_library` with the ``SHARED`` option on Windows "
"platforms (.dll)"
msgstr "Creato da :command:`add_library` con l'opzione ``SHARED`` su piattaforme Windows (.dll)"

#: ../../source/chapter/Install.rst:173
msgid "**import libraries -** ``ARCHIVE``"
msgstr "**import libraries -** ``ARCHIVE``"

#: ../../source/chapter/Install.rst:172
msgid ""
"A linkable file created by a dynamic-link library that exports symbols "
"(.lib on most Windows, .dll.a on Cygwin and MinGW)."
msgstr "Un file linkabile creato da una libreria dinamica che esporta simboli (.lib sulla maggior parte di Windows, .dll.a su Cygwin e MinGW)."

#: ../../source/chapter/Install.rst:177
msgid "**static libraries -** ``ARCHIVE``"
msgstr "**static libraries -** ``ARCHIVE``"

#: ../../source/chapter/Install.rst:176
msgid ""
"Created by :command:`add_library` with the ``STATIC`` option (.lib on "
"Windows, .a on UNIX, Cygwin, and MinGW)"
msgstr "Creato da :command:`add_library` con l'opzione ``STATIC`` (.lib su Windows, .a su UNIX, Cygwin e MinGW)"

#: ../../source/chapter/Install.rst:179
msgid ""
"Consider a project that defines an executable, ``myExecutable``, which "
"links to a shared library ``mySharedLib``. It also provides a static "
"library ``myStaticLib`` and a plugin module to the executable called "
"``myPlugin`` that also links to the shared library. The executable, "
"static library, and plugin file may be installed individually using the "
"commands"
msgstr "Si considera un progetto che definisce un eseguibile, ``myExecutable``, che si linka a una libreria shared ``mySharedLib``. Fornisce inoltre una libreria statica ``myStaticLib`` e un modulo plugin per l'eseguibile chiamato ``myPlugin`` che si collega anche alla libreria shared. L'eseguibile, la libreria statica e il file plugin possono essere installati individualmente utilizzando i comandi"

#: ../../source/chapter/Install.rst:192
msgid ""
"The executable will not be able to run from the installed location until "
"the shared library to it links to is also installed. Installation of the "
"library requires a bit more care in order to support all platforms. It "
"must be installed in a location searched by the dynamic linker on each "
"platform. On UNIX-like platforms, the library is typically installed to "
"``lib``, while on Windows it should be placed next to the executable in "
"``bin``. An additional challenge is that the import library associated "
"with the shared library on Windows should be treated like the static "
"library, and installed to ``lib/myproject``. In other words, we have "
"three different kinds of files created with a single target name that "
"must be installed to three different destinations! Fortunately, this "
"problem can be solved using the category keyword arguments. The shared "
"library may be installed using the command:"
msgstr "L'eseguibile non sarà in grado di essere eseguito dalla posizione di installazione fino a quando non sarà installata anche la libreria shared a cui si collega. L'installazione della libreria richiede un po' più di cura per supportare tutte le piattaforme. Deve essere installata in una posizione cercata dal linker dinamico su ogni piattaforma. Su piattaforme UNIX-like, la libreria è generalmente installata in ``lib``, mentre su Windows dovrebbe essere posizionata accanto all'eseguibile in ``bin``. Un'ulteriore sfida è che la libreria di importazione associata alla libreria shared su Windows dovrebbe essere trattata come libreria statica e installata in ``lib/myproject``. In altre parole, abbiamo tre diversi tipi di file creati con un unico nome di target che devono essere installati in tre diverse destinazioni! Fortunatamente, questo problema può essere risolto utilizzando la categoria di argomenti delle parole chiavi. La libreria shared può essere installata utilizzando il comando:"

#: ../../source/chapter/Install.rst:214
msgid ""
"This tells CMake that the ``RUNTIME`` file (.dll) should be installed to "
"``bin``, the ``LIBRARY`` file (.so) should be installed to ``lib``, and "
"the ``ARCHIVE`` (.lib) file should be installed to ``lib/myproject``. On "
"UNIX, the ``LIBRARY`` file will be installed; on Windows, the ``RUNTIME``"
" and ``ARCHIVE`` files will be installed."
msgstr "Questo dice a CMake che il file di ``RUNTIME`` (.dll) deve essere installato in ``bin``, il file ``LIBRARY`` (.so) deve essere installato in ``lib`` e il file ``ARCHIVE`` (.lib) dovrebbe essere installato in ``lib/myproject``. Su UNIX, verrà installato il file ``LIBRARY``; su Windows, verranno installati i file ``RUNTIME`` e ``ARCHIVE``."

#: ../../source/chapter/Install.rst:220
msgid ""
"If the above sample project is to be packaged into separate run time and "
"development components, we must assign the appropriate component to each "
"target file installed. The executable, shared library, and plugin are "
"required in order to run the application, so they belong in a ``Runtime``"
" component. Meanwhile, the import library (corresponding to the shared "
"library on Windows) and the static library are only required to develop "
"extensions to the application, and therefore belong in a ``Development`` "
"component."
msgstr "Se il progetto di esempio precedente deve essere impacchettato in componenti separati di runtime e di sviluppo, dobbiamo assegnare il componente appropriato a ciascun file target installato. L'eseguibile, la libreria shared e il plug-in sono necessari per eseguire l'applicazione, quindi appartengono a un componente ``Runtime``. Nel frattempo, la libreria di importazione (corrispondente alla libreria shared su Windows) e la libreria statica sono necessarie solo per sviluppare estensioni all'applicazione, e quindi appartengono a un componente ``Development``."

#: ../../source/chapter/Install.rst:229
msgid ""
"Component assignments may be specified by adding the ``COMPONENT`` "
"argument to each of the commands above. You may also combine all of the "
"installation rules into a single command invocation, which is equivalent "
"to all of the above commands with components added. The files generated "
"by each target are installed using the rule for their category."
msgstr "Le assegnazioni dei componenti possono essere specificate aggiungendo l'argomento ``COMPONENT`` a ciascuno dei comandi precedenti. È inoltre possibile combinare tutte le regole di installazione in un'unica chiamata di comando, che equivale a tutti i comandi precedenti con l'aggiunta dei componenti. I file generati da ciascun target vengono installati utilizzando la regola per la loro categoria."

#: ../../source/chapter/Install.rst:243
msgid ""
"Either ``NAMELINK_ONLY`` or ``NAMELINK_SKIP`` may be specified as a "
"``LIBRARY`` option. On some platforms, a versioned shared library has a "
"symbolic link such as"
msgstr "Si può specificare ``NAMELINK_ONLY`` o ``NAMELINK_SKIP`` come opzione di ``LIBRARY``. Su alcune piattaforme, una libreria shared versionata ha un link simbolico come"

#: ../../source/chapter/Install.rst:251
msgid ""
"where ``lib<name>.so.1`` is the soname of the library, and "
"``lib<name>.so`` is a \"namelink\" that helps linkers to find the library"
" when given ``-l<name>``. The ``NAMELINK_ONLY`` option results in "
"installation of only the namelink when a library target is installed. The"
" ``NAMELINK_SKIP`` option causes installation of library files other than"
" the namelink when a library target is installed. When neither option is "
"given, both portions are installed. On platforms where versioned shared "
"libraries do not have namelinks, or when a library is not versioned, the "
"``NAMELINK_SKIP`` option installs the library and the ``NAMELINK_ONLY`` "
"option installs nothing. See the :prop_tgt:`VERSION` and "
":prop_tgt:`SOVERSION` target properties for details on creating "
"versioned, shared libraries."
msgstr "dove ``lib<name>.so.1`` è il \"soname\" della libreria, e ``lib<name>.so`` è un \"namelink\" che aiuta i linker a trovare la libreria quando viene dato ``-l<name>``. L'opzione ``NAMELINK_ONLY`` comporta l'installazione del solo namelink quando è installata una libreria target. L'opzione ``NAMELINK_SKIP`` provoca l'installazione di file di libreria diversi dal namelink quando viene installato un target di libreria. Quando non viene fornita nessuna opzione, vengono installate entrambe le parti. Sulle piattaforme in cui le librerie shared con versione non hanno collegamenti ai nomi o quando una libreria non è dotata di versione, l'opzione ``NAMELINK_SKIP`` installa la libreria e l'opzione ``NAMELINK_ONLY`` non installa nulla. Consultare le proprietà dei target :prop_tgt:`VERSION` e :prop_tgt:`SOVERSION` per i dettagli sulla creazione di librerie shared e con una versione."

#: ../../source/chapter/Install.rst:267
msgid ""
"Projects may install files other than those that are created with "
":command:`add_executable` or :command:`add_library`, such as header files"
" or documentation. General-purpose installation of files is specified "
"using the ``FILES`` signature."
msgstr "I progetti possono installare file diversi da quelli creati con :command:`add_executable` o con :command:`add_library`, come file header o documentazione. L'installazione generica dei file viene specificata utilizzando la firma ``FILES``."

#: ../../source/chapter/Install.rst:272
msgid ""
"The ``FILES`` keyword is immediately followed by a list of files to be "
"installed. Relative paths are evaluated with respect to the current "
"source directory. Files will be installed to the given ``DESTINATION`` "
"directory. For example, the command"
msgstr "La parola chiave ``FILES`` è immediatamente seguita da un elenco di file da installare. I path relativi vengono valutati rispetto alla directory dei sorgenti corrente. I file verranno installati nella directory ``DESTINATION`` specificata. Ad esempio, il comando"

#: ../../source/chapter/Install.rst:282
msgid ""
"installs the file ``my-api.h`` from the source tree, and the file ``my-"
"config.h`` from the build tree into the include directory under the "
"installation prefix. By default installed files are given the permissions"
" ``OWNER_WRITE``, ``OWNER_READ``, ``GROUP_READ``, and ``WORLD_READ``, but"
" this may be overridden by specifying the ``PERMISSIONS`` option. "
"Consider cases in which users would want to install a global "
"configuration file on a UNIX system that is readable only by its owner "
"(such as root). We accomplish this with the command"
msgstr "installa il file ``my-api.h`` dall'albero dei sorgenti e il file ``my-config.h`` dall'albero di build nella directory include sotto il prefisso di installazione. Per default, ai file installati vengono assegnate le autorizzazioni ``OWNER_WRITE``, ``OWNER_READ``, ``GROUP_READ`` e ``WORLD_READ``, ma questo potrebbe essere sovrascritto specificando l'opzione ``PERMISSIONS``. Si considerino i casi in cui gli utenti vorrebbero installare un file di configurazione globale su un sistema UNIX leggibile solo dal suo proprietario (come root). Lo si fa con questo comando"

#: ../../source/chapter/Install.rst:296
msgid ""
"which installs the file ``my-rc`` with owner read/write permission into "
"the absolute path ``/etc``."
msgstr "che installa il file ``my-rc`` con i permessi di lettura/scrittura del proprietario nel path assoluto ``/etc``."

#: ../../source/chapter/Install.rst:302
msgid ""
"The ``RENAME`` argument specifies a name for an installed file that may "
"be different from the original file. Renaming is allowed only when a "
"single file is installed by the command. For example, the command"
msgstr "L'argomento ``RENAME`` specifica un nome per un file installato che potrebbe essere diverso dal file originale. La ridenominazione è consentita solo quando un singolo file viene installato dal comando. Ad esempio, il comando"

#: ../../source/chapter/Install.rst:310
msgid ""
"will install the file ``version.h`` from the source directory to "
"``include/my-version.h`` under the installation prefix."
msgstr "installerà il file ``version.h`` dalla directory dei sorgenti in ``include/my-version.h`` sotto il prefisso di installazione."

#: ../../source/chapter/Install.rst:314
msgid "Installing Programs"
msgstr "Installazione dei Programmi"

#: ../../source/chapter/Install.rst:316
msgid ""
"Projects may also install helper programs, such as shell scripts or "
"Python scripts that are not actually compiled as targets. These may be "
"installed with the ``FILES`` signature using the ``PERMISSIONS`` option "
"to add execute permission. However, this case is common enough to justify"
" a simpler interface. CMake provides the ``PROGRAMS`` signature for this "
"purpose."
msgstr "I progetti possono anche installare programmi di supporto, come script di shell o script Python che non sono effettivamente compilati come target. Questi possono essere installati con la firma ``FILES`` utilizzando l'opzione ``PERMISSIONS`` per aggiungere il permesso di esecuzione. Tuttavia, questo caso è abbastanza comune da giustificare un'interfaccia più semplice. CMake fornisce la firma ``PROGRAMS`` per questo scopo."

#: ../../source/chapter/Install.rst:323
msgid ""
"The ``PROGRAMS`` keyword is immediately followed by a list of scripts to "
"be installed. This command is identical to the ``FILES`` signature, "
"except that the default permissions additionally include "
"``OWNER_EXECUTE``, ``GROUP_EXECUTE``, and ``WORLD_EXECUTE``. For example,"
" we may install a Python utility script with the command"
msgstr "La parola chiave ``PROGRAMS`` è immediatamente seguita da un elenco di script da installare. Questo comando è identico alla firma ``FILES``, tranne per il fatto che le autorizzazioni di default includono anche ``OWNER_EXECUTE``, ``GROUP_EXECUTE`` e  ``WORLD_EXECUTE``. Ad esempio, possiamo installare uno script di utilità Python col comando"

#: ../../source/chapter/Install.rst:333
msgid ""
"which installs ``my-util.py`` to the ``bin`` directory under the "
"installation prefix and gives it owner, group, world read and execute "
"permissions, plus owner write."
msgstr "che installa ``my-util.py`` nella directory ``bin`` sotto il prefisso di installazione e gli fornisce i permessi di proprietario, gruppo, lettura ed esecuzione universali, più i permessi di scrittura per il proprietario."

#: ../../source/chapter/Install.rst:341
msgid "Installing Directories"
msgstr "Installazione di Directory"

#: ../../source/chapter/Install.rst:343
msgid ""
"Projects may also provide an entire directory full of resource files, "
"such as icons or html documentation. An entire directory may be installed"
" using the ``DIRECTORY`` signature."
msgstr "I progetti possono anche fornire un'intera directory piena di file di risorse, come icone o documentazione html. È possibile installare un'intera directory utilizzando la firma ``DIRECTORY``."

#: ../../source/chapter/Install.rst:347
msgid ""
"The ``DIRECTORY`` keyword is immediately followed by a list of "
"directories to be installed. Relative paths are evaluated with respect to"
" the current source directory. Each named directory is installed to the "
"destination directory. The last component of each input directory name is"
" appended to the destination directory as that directory is copied. For "
"example, the command"
msgstr "La parola chiave ``DIRECTORY`` è immediatamente seguita da un elenco di directory da installare. I path relativi vengono valutati rispetto alla directory dei sorgenti corrente. Ogni directory denominata viene installata nella directory di destinazione. L'ultimo componente di ogni nome di directory di input viene aggiunto alla directory di destinazione quando tale directory viene copiata. Ad esempio, il comando"

#: ../../source/chapter/Install.rst:358
msgid ""
"will install the ``data/icons`` directory from the source tree into "
"``share/myproject/icons`` under the installation prefix. A trailing slash"
" will leave the last component empty and install the contents of the "
"input directory to the destination. The command"
msgstr "installerà la directory ``data/icons`` dall'albero dei sorgenti in ``share/myproject/icons`` sotto il prefisso di installazione. Una barra finale lascerà vuoto l'ultimo componente e installerà il contenuto della directory di input nella destinazione. Il comando"

#: ../../source/chapter/Install.rst:367
msgid ""
"installs the contents of ``doc/html`` from the source directory into "
"``doc/myproject`` under the installation prefix. If no input directory "
"names are given, as in"
msgstr "installa il contenuto di ``doc/html`` dalla directory di origine in ``doc/myproject`` sotto il prefisso di installazione. Se non vengono forniti nomi di directory di input, come in"

#: ../../source/chapter/Install.rst:375
msgid ""
"the destination directory will be created but nothing will be installed "
"into it."
msgstr "la directory di destinazione verrà creata ma non verrà installato nulla al suo interno."

#: ../../source/chapter/Install.rst:378
msgid ""
"Files installed by the ``DIRECTORY`` signature are given the same default"
" permissions as the ``FILES`` signature. Directories installed by the "
"``DIRECTORY`` signature are given the same default permissions as the "
"``PROGRAMS`` signature. The ``FILE_PERMISSIONS`` and "
"``DIRECTORY_PERMISSIONS`` options may be used to override these defaults."
" Consider a case in which a directory full of example shell scripts is to"
" be installed into a directory that is both owner and group writable. We "
"may use the command"
msgstr "I file installati dalla firma ``DIRECTORY`` hanno le stesse autorizzazioni di default della firma ``FILES``. Le directory installate dalla firma ``DIRECTORY`` hanno le stesse autorizzazioni di default della firma ``PROGRAMS``. Le opzioni ``FILE_PERMISSIONS`` e ``DIRECTORY_PERMISSIONS`` possono essere utilizzate per sovrascrivere queste impostazioni di default. Si consideri un caso in cui una directory piena di script di shell di esempio deve essere installata in una directory che sia scrivibile sia dal proprietario che dal gruppo. Possiamo usare il comando"

#: ../../source/chapter/Install.rst:400
msgid ""
"which installs the directory ``data/scripts`` into "
"``share/myproject/scripts`` and sets the desired permissions. In some "
"cases, a fully-prepared input directory created by the project may have "
"the desired permissions already set. The ``USE_SOURCE_PERMISSIONS`` "
"option tells CMake to use the file and directory permissions from the "
"input directory during installation. If in the previous example the input"
" directory were to have already been prepared with correct permissions, "
"the following command may have been used instead:"
msgstr "che installa la directory ``data/scripts`` in ``share/myproject/scripts`` e imposta i permessi desiderati. In alcuni casi, una directory di input completamente preparata creata dal progetto potrebbe avere già impostate le autorizzazioni desiderate. L'opzione ``USE_SOURCE_PERMISSIONS`` indica a CMake di utilizzare i permessi di file e directory dalla directory di input durante l'installazione. Se nell'esempio precedente la directory di input fosse già stata predisposta con i permessi corretti, potrebbe essere stato utilizzato invece il seguente comando:"

#: ../../source/chapter/Install.rst:415
msgid ""
"If the input directory to be installed is under source management, there "
"may be extra subdirectories in the input that you do not wish to install."
" There may also be specific files that should not be installed or be "
"installed with different permissions, while most files get the defaults. "
"The ``PATTERN`` and ``REGEX`` options may be used for this purpose. A "
"``PATTERN`` option is followed first by a globbing pattern and then by an"
" ``EXCLUDE`` or ``PERMISSIONS`` option. A ``REGEX`` option is followed "
"first by a regular expression and then by ``EXCLUDE`` or ``PERMISSIONS``."
" The ``EXCLUDE`` option skips installation of those files or directories "
"matching the preceding pattern or expression, while the ``PERMISSIONS`` "
"option assigns specific permissions to them."
msgstr "Se la directory di input da installare è sotto la gestione dei sorgenti, potrebbero esserci sottodirectory aggiuntive nell'input che non si desiderano installare. Potrebbero esserci anche file specifici che non devono essere installati o che devono essere installati con autorizzazioni diverse, mentre la maggior parte dei file ottiene i valori di default. Le opzioni ``PATTERN`` e ``REGEX`` possono essere utilizzate per questo scopo. Un'opzione ``PATTERN`` è seguita prima da un \"glob pattern\" e poi da un'opzione ``EXCLUDE`` o ``PERMISSIONS``. Un'opzione ``REGEX`` è seguita prima da un'espressione regolare e poi da ``EXCLUDE`` o ``PERMISSIONS``. L'opzione ``EXCLUDE`` salta l'installazione di quei file o directory che corrispondono al modello o all'espressione precedente, mentre l'opzione ``PERMISSIONS`` assegna loro autorizzazioni specifiche."

#: ../../source/chapter/Install.rst:427
msgid ""
"Each input file and directory is tested against the pattern or regular "
"expression as a full path with forward slashes. A pattern will match only"
" complete file or directory names occurring at the end of the full path, "
"while a regular expression may match any portion. For example, the "
"pattern ``foo*`` will match ``.../foo.txt`` but not ``.../myfoo.txt`` or "
"``.../foo/bar.txt;`` however, the regular expression ``foo`` will match "
"all of them."
msgstr "Ogni file e directory di input viene testato rispetto al modello o all'espressione regolare come path completo con barre. Un pattern corrisponderà solo ai nomi completi di file o directory che si trovano alla fine del path completo, mentre un'espressione regolare può corrispondere a qualsiasi parte. Ad esempio, il pattern ``foo*`` corrisponderà a ``.../foo.txt`` ma non a ``.../myfoo.txt`` né a ``.../foo/bar.txt;``; tuttavia, l'espressione regolare ``foo`` corrisponderà a tutti."

#: ../../source/chapter/Install.rst:435
msgid ""
"Returning to the above example of installing an icons directory, consider"
" the case in which the input directory is managed by git and also "
"contains some extra text files that we do not want to install. The "
"command"
msgstr "Tornando all'esempio precedente di installazione di una directory di icone, si consideri il caso in cui la directory di input è gestita da git e contiene anche alcuni file di testo extra che non vogliamo installare. Il comando"

#: ../../source/chapter/Install.rst:449
msgid ""
"installs the icons directory while ignoring any .git directory or text "
"file contained. The equivalent command using the ``REGEX`` option is"
msgstr "installa la directory delle icone ignorando qualsiasi directory .git o file di testo contenuto. Il comando equivalente che utilizza l'opzione ``REGEX`` è"

#: ../../source/chapter/Install.rst:458
msgid ""
"which uses '/' and '$' to constrain the match in the same way as the "
"patterns. Consider a similar case in which the input directory contains "
"shell scripts and text files that we wish to install with different "
"permissions than the other files. The command"
msgstr "che utilizza '/' e '$' per vincolare la corrispondenza allo stesso modo dei pattern. Si consideri un caso simile in cui la directory di input contiene script di shell e file di testo che desideriamo installare con autorizzazioni diverse rispetto agli altri file. Il comando"

#: ../../source/chapter/Install.rst:472
msgid ""
"will install the contents of ``data/other`` from the source directory to "
"``share/myproject`` while ignoring .git directories and giving specific "
"permissions to ``.txt`` and ``.sh`` files."
msgstr "installerà il contenuto di ``data/other`` dalla directory dei sorgenti a ``share/myproject`` ignorando le directory .git e fornendo autorizzazioni specifiche ai file ``.txt`` e ``.sh``."

#: ../../source/chapter/Install.rst:480
msgid "Installing Scripts"
msgstr "Installazione di Script"

#: ../../source/chapter/Install.rst:482
msgid ""
"Project installations may need to perform tasks other than just placing "
"files in the installation tree. Third-party packages may provide their "
"own mechanisms for registering new plugins that must be invoked during "
"project installation. The ``SCRIPT`` signature is provided for this "
"purpose."
msgstr "Potrebbe essere necessario che le installazioni del progetto eseguano attività diverse dal semplice inserimento di file nell'albero di installazione. I pacchetti di terze parti possono fornire i propri meccanismi per la registrazione di nuovi plug-in che devono essere richiamati durante l'installazione del progetto. La firma ``SCRIPT`` viene fornita a questo scopo."

#: ../../source/chapter/Install.rst:488
msgid ""
"The ``SCRIPT`` keyword is immediately followed by the name of a CMake "
"script. CMake will execute the script during installation. If the file "
"name given is a relative path, it will be evaluated with respect to the "
"current source directory. A simple use case is printing a message during "
"installation. We first write a ``message.cmake`` file containing the code"
msgstr "La parola chiave ``SCRIPT`` è immediatamente seguita dal nome di uno script CMake. CMake eseguirà lo script durante l'installazione. Se il nome del file fornito è un path relativo, verrà valutato rispetto alla directory dei sorgenti corrente. Un semplice caso d'uso è la stampa di un messaggio durante l'installazione. Per prima cosa scriviamo un file ``message.cmake`` contenente il codice"

#: ../../source/chapter/Install.rst:499
msgid "and then reference this script using the command:"
msgstr "e poi fare riferimento a questo script col comando:"

#: ../../source/chapter/Install.rst:505
msgid ""
"Custom installation scripts are not executed during the main CMakeLists "
"file processing; they are executed during the installation process "
"itself. Variables and macros defined in the code containing the ``install"
" (SCRIPT)`` call will not be accessible from the script. However, there "
"are a few variables defined during the script execution that may be used "
"to get information about the installation. The variable "
":variable:`CMAKE_INSTALL_PREFIX` is set to the actual installation "
"prefix. This may be different from the corresponding cache variable "
"value, because the installation scripts may be executed by a packaging "
"tool that uses a different prefix. An environment variable "
"``ENV{DESTDIR}`` may be set by the user or packaging tool. Its value is "
"prepended to the installation prefix and to absolute installation paths "
"to determine the location where files are installed. In order to "
"reference an install location on disk, custom script may use "
"``$ENV{DESTDIR}${CMAKE_INSTALL_PREFIX}`` as the top portion of the path. "
"The variable ``CMAKE_INSTALL_CONFIG_NAME`` is set to the name of the "
"build configuration currently being installed (Debug, Release, etc.). "
"During component-specific installation, the variable "
"``CMAKE_INSTALL_COMPONENT`` is set to the name of the current component."
msgstr "Gli script di installazione personalizzati non vengono eseguiti durante l'elaborazione del file CMakeLists principale; vengono eseguiti durante il processo di installazione stesso. Le variabili e le macro definite nel codice contenente la chiamata ``install (SCRIPT)`` non saranno accessibili dallo script. Tuttavia, ci sono alcune variabili definite durante l'esecuzione dello script utilizzabili per ottenere informazioni sull'installazione. La variabile :variable:`CMAKE_INSTALL_PREFIX` è impostata sul prefisso di installazione effettivo. Questa può essere diversa dal valore della variabile di cache corrispondente, poiché gli script di installazione possono essere eseguiti da uno strumento di pacchettizzazione che utilizza un prefisso diverso. Una variabile di ambiente ``ENV{DESTDIR}`` può essere impostata dall'utente o dal tool di pacchettizzazione. Il suo valore viene anteposto al prefisso di installazione e ai percorsi di installazione assoluti per determinare la posizione in cui sono installati i file. Per fare riferimento a un path di installazione su disco, lo script custom può utilizzare ``$ENV{DESTDIR}${CMAKE_INSTALL_PREFIX}`` come parte superiore del path. La variabile ``CMAKE_INSTALL_CONFIG_NAME`` è impostata sul nome della configurazione di build attualmente installata (Debug, Release, ecc.). Durante l'installazione specifica del componente, la variabile ``CMAKE_INSTALL_COMPONENT`` è impostata sul nome del componente corrente."

#: ../../source/chapter/Install.rst:527
msgid "Installing Code"
msgstr "Installazione del Codice"

#: ../../source/chapter/Install.rst:529
msgid ""
"Custom installation scripts, as simple as the message above, are more "
"easily created with the script code placed inline in the call to the "
":command:`install` command. The ``CODE`` signature is provided for this "
"purpose."
msgstr "Gli script di installazione personalizzati, semplici come il messaggio precedente, vengono creati più facilmente con il codice dello script inserito in linea nella chiamata al comando :command:`install`. La firma ``CODE`` viene fornita a questo scopo."

#: ../../source/chapter/Install.rst:534
msgid ""
"The ``CODE`` keyword is immediately followed by a string containing the "
"code to place in the installation script. An install-time message may be "
"created using the command"
msgstr "La parola chiave ``CODE`` è immediatamente seguita da una stringa contenente il codice da inserire nello script di installazione. È possibile creare un messaggio al momento dell'installazione utilizzando il comando"

#: ../../source/chapter/Install.rst:542
msgid ""
"which has the same effect as the ``message.cmake`` script but contains "
"the code inline."
msgstr "che ha lo stesso effetto dello script ``message.cmake`` ma contiene il codice in linea."

#: ../../source/chapter/Install.rst:549
msgid "Installing Prerequisite Shared Libraries"
msgstr "Installazione di Librerie Shared Prerequisite"

#: ../../source/chapter/Install.rst:551
msgid ""
"Executables are frequently built using shared libraries as building "
"blocks. When you install such an executable, you must also install its "
"prerequisite shared libraries, called \"prerequisites\" because the "
"executable requires their presence in order to load and run properly. The"
" three main sources of shared libraries are the operating system itself, "
"the build products of your own project, and third party libraries "
"belonging to an external project. The ones from the operating system may "
"be relied upon to be present without installing anything: they are on the"
" base platform where your executable runs. The build products in your own"
" project presumably have :command:`add_library` build rules in the "
"CMakeLists files, and so it should be straightforward to create CMake "
"install rules for them. It is the third party libraries that frequently "
"become a high maintenance item when there are more than a handful of "
"them, or when the set of them fluctuates from version-to-version of the "
"third party project. Libraries may be added, code may be reorganized, and"
" the third party shared libraries themselves may actually have additional"
" prerequisites that are not obvious at first glance."
msgstr "Gli eseguibili vengono spesso creati utilizzando librerie shared come elementi costitutivi. Quando si installa un eseguibile di questo tipo, è necessario installare anche le sue librerie shared prerequisite, chiamate \"prerequisiti\" perché l'eseguibile richiede la loro presenza per essere caricato ed eseguito correttamente. Le tre principali sorgenti delle librerie shared sono il sistema operativo stesso, i prodotti della build del proprio progetto e le librerie di terze parti appartenenti a un progetto esterno. Si può fare affidamento su quelli del sistema operativo per essere presenti senza installare nulla: sono sulla piattaforma di base in cui viene eseguito l'eseguibile. I prodotti della build nel progetto presumibilmente hanno la regola di build :command:`add_library` nei file CMakeLists, quindi dovrebbe essere semplice creare regole di installazione di CMake per loro. Sono le librerie di terze parti che spesso diventano un elemento di manutenzione elevata quando ce ne sono parecchie o quando si passa da una versione all'altra del progetto di terze parti. Le librerie si possono aggiungere, il codice può essere riorganizzato e le stesse librerie shared di terze parti potrebbero effettivamente avere prerequisiti aggiuntivi che non sono ovvi a prima vista."

#: ../../source/chapter/Install.rst:575
msgid ""
"CMake provides a module, :module:`BundleUtilities` to make it easier to "
"deal with required shared libraries. This module provides the "
"``fixup_bundle`` function to copy and fix prerequisite shared libraries "
"using well-defined locations relative to the executable. For Mac bundle "
"applications, it embeds the libraries inside the bundle, fixing them with"
" ``install_name_tool`` to make a self-contained unit. On Windows, it "
"copies the libraries into the same directory with the executable since "
"executables will search in their own directories for their required DLLs."
msgstr "CMake fornisce un modulo, :module:`BundleUtilities` per semplificare la gestione delle librerie shared richieste. Questo modulo fornisce la funzione ``fixup_bundle`` per copiare e correggere librerie shared prerequisite utilizzando posizioni ben definite relative all'eseguibile. Per le applicazioni bundle Mac, si racchiudono le librerie all'interno del bundle, correggendole con ``install_name_tool`` per creare un'unità autonoma. Su Windows, si copiano le librerie nella stessa directory con l'eseguibile poiché gli eseguibili cercheranno nelle proprie directory le DLL richieste."

#: ../../source/chapter/Install.rst:584
msgid ""
"The ``fixup_bundle`` function helps you create relocatable install trees."
" Mac users appreciate self-contained bundle applications: you can drag "
"them anywhere, double click them, and they still work. They do not rely "
"on anything being installed in a certain location other than the "
"operating system itself. Similarly, Windows users without administrative "
"privileges appreciate a relocatable install tree where an executable and "
"all required DLLs are installed in the same directory, so that it works "
"no matter where you install it. You can even move things around after "
"installing them and it will still work."
msgstr "La funzione ``fixup_bundle`` aiuta a creare alberi di installazione rilocabili. Gli utenti Mac apprezzano le applicazioni bundle autonome: si possono trascinare ovunque, fare doppio clic su di esse e funzionano ancora. Non si basano su nulla di installato in una determinata posizione diversa dal sistema operativo stesso. Allo stesso modo, gli utenti Windows senza privilegi amministrativi apprezzano un albero di installazione rilocabile in cui un eseguibile e tutte le DLL richieste sono installate nella stessa directory, in modo che funzioni indipendentemente da dove lo si installa. Si possono persino spostare le cose dopo averle installate e funzionerà comunque."

#: ../../source/chapter/Install.rst:594
msgid ""
"To use ``fixup_bundle``, first install one of your executable targets. "
"Then, configure a CMake script that can be called at install time. Inside"
" the configured CMake script, simply :command:`include` "
":module:`BundleUtilities` and call the ``fixup_bundle`` function with "
"appropriate arguments."
msgstr "Per utilizzare ``fixup_bundle``, si installa prima uno dei target eseguibili. Poi, si configura uno script CMake richiamabile al momento dell'installazione. All'interno dello script configurato di CMake, semplicemente si :command:`include` :module:`BundleUtilities` e si chiama la funzione ``fixup_bundle`` con gli argomenti appropriati."

#: ../../source/chapter/Install.rst:600
msgid "In CMakeLists.txt"
msgstr "In CMakeLists.txt"

#: ../../source/chapter/Install.rst:624
msgid "In FixBundle.cmake.in:"
msgstr "In FixBundle.cmake.in:"

#: ../../source/chapter/Install.rst:649
msgid ""
"You are responsible for verifying that you have permission to copy and "
"distribute the prerequisite shared libraries for your executable. Some "
"libraries may have restrictive software licenses that prohibit making "
"copies a la ``fixup_bundle``."
msgstr "Si è responsabili di verificare di disporre dell'autorizzazione per copiare e distribuire le librerie shared prerequisite per l'eseguibile. Alcune librerie potrebbero avere licenze software restrittive che vietano di fare copie alla ``fixup_bundle``."

#: ../../source/chapter/Key Concepts.rst:2
msgid "Key Concepts"
msgstr "Concetti Chiave"

#: ../../source/chapter/Key Concepts.rst:4
msgid ""
"This chapter provides an introduction to CMake's key concepts. As you "
"start working with CMake, you will run into a variety of concepts such as"
" targets, generators, and commands. Understanding these concepts will "
"provide you with the working knowledge you need to create effective "
"CMakeLists files. Many CMake objects such as targets, directories and "
"source files have properties associated with them. A property is a key-"
"value pair attached to a specific object. The most generic way to access "
"properties is through the :command:`set_property` and "
":command:`get_property` commands. These commands allow you to set or get "
"a property from any object in CMake that has properties. See the :manual"
":`cmake-properties <cmake-properties(7)>` manual for a list of supported "
"properties. From the command line a full list of properties supported in"
"  CMake can be obtained by running :manual:`cmake <cmake(1)>` with the "
"``--help-property-list`` option."
msgstr "Questo capitolo introduce i concetti chiave di CMake. Quando si inizia a lavorare con CMake, ci si imbatte in una varietà di concetti come target, generatori e comandi. La comprensione di questi concetti fornirà le conoscenze operative necessarie per creare file CMakeLists efficaci. Molti oggetti CMake come target, directory e file sorgenti hanno delle proprietà associate. Una proprietà è una coppia chiave-valore associata a un oggetto specifico. Il modo più generico per accedere alle proprietà è tramite i comandi :command:`set_property` e :command:`get_property`. Questi comandi consentono di impostare o ottenere una proprietà da qualsiasi oggetto in CMake che ne dispone. Consultare il manuale :manual:`cmake-properties <cmake-properties(7)>` per un elenco delle proprietà supportate. Dalla riga di comando è possibile ottenere un elenco completo delle proprietà supportate in CMake eseguendo :manual:`cmake <cmake(1)>` con l'opzione ``--help-property-list``."

#: ../../source/chapter/Key Concepts.rst:23
msgid "Targets"
msgstr "Target"

#: ../../source/chapter/Key Concepts.rst:25
msgid ""
"Probably the most important item is targets. Targets represent "
"executables, libraries, and utilities built by CMake. Every "
":command:`add_library`, :command:`add_executable`, and "
":command:`add_custom_target` command creates a target. For example, the "
"following command will create a target named \"foo\" that is a static "
"library, with ``foo1.c`` and ``foo2.c`` as source files."
msgstr "Probabilmente l'elemento più importante sono i target. I target rappresentano eseguibili, librerie e utilità create da CMake. Ogni comando :command:`add_library`, :command:`add_executable` e :command:`add_custom_target` crea un target. Ad esempio, il seguente comando creerà un target, denominato \"foo\", che è una libreria statica, con ``foo1.c`` e ``foo2.c`` come file sorgente."

#: ../../source/chapter/Key Concepts.rst:40
msgid ""
"The name \"foo\" is now available for use as a library name everywhere "
"else in the project, and CMake will know how to expand the name into the "
"library when needed. Libraries can be declared as a particular type such "
"as ``STATIC``, ``SHARED``, ``MODULE``, or left undeclared. ``STATIC`` "
"indicates that the library must be built as a static library. Likewise, "
"``SHARED`` indicates it must be built as a shared library. ``MODULE`` "
"indicates that the library must be created so that it can be dynamically-"
"loaded into an executable. Module libraries are implemented as shared "
"libraries on many platforms, but not all.  Therefore, CMake does not "
"allow other targets to link to modules. If none of these options are "
"specified, it indicates that the library could be built as either shared "
"or static. In that case, CMake uses the setting of the variable "
":variable:`BUILD_SHARED_LIBS` to determine if the library should be "
"``SHARED`` or ``STATIC``. If it is not set, then CMake defaults to "
"building static libraries."
msgstr "Il nome \"foo\" è ora disponibile per l'uso, come nome di libreria, ovunque nel progetto e CMake saprà come espandere il nome nella libreria quando necessario. Le librerie possono essere dichiarate come un tipo particolare come ``STATIC``, ``SHARED``, ``MODULE``, o senza dichiarazione. ``STATIC`` indica che la libreria deve essere creata come libreria statica. Allo stesso modo, ``SHARED`` indica che deve essere creata come libreria condivisa. ``MODULE`` indica che la libreria deve essere creata in modo che possa essere caricata dinamicamente in un eseguibile. Le librerie dei moduli vengono implementate come librerie condivise su molte piattaforme, ma non tutte.  Pertanto, CMake non consente ad altri target di collegarsi ai moduli. Se nessuna di queste opzioni è specificata, significa che la libreria può essere creata come condivisa o statica. In tal caso, CMake utilizza l'impostazione della variabile :variable:`BUILD_SHARED_LIBS` per determinare se la libreria deve essere ``SHARED`` o ``STATIC``. Se non è impostata, per default CMake crea librerie statiche."

#: ../../source/chapter/Key Concepts.rst:60
msgid ""
"Likewise, executables have some options. By default, an executable will "
"be a traditional console application that has a main entry point. One may"
" specify a ``WIN32`` option to request a WinMain entry point on Windows "
"systems, while retaining main on non-Windows systems."
msgstr "Allo stesso modo, gli eseguibili hanno alcune opzioni. Per default, un eseguibile sarà un'applicazione console tradizionale con un punto di ingresso principale. È possibile specificare un'opzione ``WIN32`` per richiedere un punto di ingresso WinMain su sistemi Windows, mantenendo \"main\" su sistemi non Windows."

#: ../../source/chapter/Key Concepts.rst:68
msgid ""
"In addition to storing their type, targets also keep track of general "
"properties. These properties can be set and retrieved using the "
":command:`set_target_properties` and :command:`get_target_property` "
"commands, or the more general :command:`set_property` and "
":command:`get_property` commands. One useful property is "
":prop_tgt:`LINK_FLAGS`, which is used to specify additional link flags "
"for a specific target. Targets store a list of libraries that they link "
"against, which are set using the :command:`target_link_libraries` "
"command. Names passed into this command can be libraries, full paths to "
"libraries, or the name of a library from an :command:`add_library` "
"command. Targets also store the link directories to use when linking, and"
" custom commands to execute after building."
msgstr "Oltre a memorizzarne il tipo, i target tengono traccia anche delle proprietà generali. Tali proprietà possono essere impostate e recuperate usando i comandi :command:`set_target_properties` e :command:`get_target_property`, o i comandi più generali :command:`set_property` e :command:`get_property`. Una proprietà utile è :prop_tgt:`LINK_FLAGS`, che viene utilizzata per specificare flag di link aggiuntivi per un target specifico. I target memorizzano un elenco di librerie a cui si collegano, che vengono impostate utilizzando il comando :command:`target_link_libraries`. I nomi passati a questo comando possono essere librerie, path completi alle librerie o il nome di una libreria da un comando :command:`add_library`. I target memorizzano anche le directory dei collegamento da utilizzare durante il link e i comandi personalizzati da eseguire dopo il build."

#: ../../source/chapter/Key Concepts.rst:81
msgid "Usage Requirements"
msgstr "Requisiti d'Uso"

#: ../../source/chapter/Key Concepts.rst:83
msgid ""
"CMake will also propagate \"usage requirements\" from linked library "
"targets. Usage requirements affect compilation of sources in the "
"<target>. They are specified by properties defined on linked targets."
msgstr "CMake propagherà anche i \"requisiti di utilizzo\" dai target della libreria linkata. I requisiti di utilizzo influenzano la compilazione dei sorgenti nel <target>. Sono specificati dalle proprietà definite sui target collegati."

#: ../../source/chapter/Key Concepts.rst:88
msgid ""
"For example, to specify include directories that are required when "
"linking to a library you would can do the following:"
msgstr "Ad esempio, per specificare le directory di inclusione richieste durante il collegamento a una libreria, è possibile eseguire le seguenti operazioni:"

#: ../../source/chapter/Key Concepts.rst:99
msgid ""
"Now anything that links to the target foo will automatically have foo's "
"binary and source as include directories. The order of the include "
"directories brought in through \"usage requirements\" will match the "
"order of the targets in the :command:`target_link_libraries` call."
msgstr "Ora tutto ciò che si collega al target foo avrà automaticamente il binario e il sorgente di foo come directory di inclusione. L'ordine delle directory di inclusione introdotte tramite i \"requisiti di utilizzo\" corrisponderà all'ordine dei target nella chiamata :command:`target_link_libraries`."

#: ../../source/chapter/Key Concepts.rst:104
msgid ""
"For each library or executable CMake creates, it tracks of all the "
"libraries on which that target depends using the "
":command:`target_link_libraries` command. For example:"
msgstr "Per ogni libreria o eseguibile creato da CMake, si tiene traccia di tutte le librerie da cui dipende quel target utilizzando il comando :command:`target_link_libraries`. Per esempio:"

#: ../../source/chapter/Key Concepts.rst:116
msgid ""
"will link the libraries \"foo\" and \"bar\" into the executable "
"\"foobar\" even though only \"foo\" was explicitly specified for it."
msgstr "linkerà le librerie \"foo\" e \"bar\" nell'eseguibile \"foobar\" anche se solo \"foo\" è stato esplicitamente specificato."

#: ../../source/chapter/Key Concepts.rst:120
msgid "Specifying Optimized or Debug Libraries with a Target"
msgstr "Specifica delle Librerie Ottimizzate o di Debug con un Target"

#: ../../source/chapter/Key Concepts.rst:122
msgid ""
"On Windows platforms, users are often required to link debug libraries "
"with debug libraries, and optimized libraries with optimized libraries. "
"CMake helps satisfy this requirement with the "
":command:`target_link_libraries` command, which accepts an optional flag "
"labeled as ``debug`` or ``optimized``. If a library is preceded with "
"either ``debug`` or ``optimized``, then that library will only be linked "
"in with the appropriate configuration type. For example"
msgstr "Sulle piattaforme Windows, agli utenti viene spesso richiesto di linkare librerie di debug con librerie di debug e librerie ottimizzate con librerie ottimizzate. CMake aiuta a soddisfare questo requisito con il comando :command:`target_link_libraries`, che accetta un flag opzionale etichettato come ``debug`` o ``optimized``. Se una libreria è preceduta da ``debug`` o ``optimized``, questa sarà collegata solo col tipo di configurazione appropriato. Per esempio"

#: ../../source/chapter/Key Concepts.rst:138
msgid ""
"In this case, foo will be linked against libdebug if a debug build was "
"selected, or against libopt if an optimized build was selected."
msgstr "In questo caso, foo sarà collegato a libdebug se è stata selezionata una build di debug o a libopt se è stata selezionata una build ottimizzata."

#: ../../source/chapter/Key Concepts.rst:142
msgid "Object Libraries"
msgstr "Librerie di Oggetti"

#: ../../source/chapter/Key Concepts.rst:144
msgid ""
"Large projects often organize their source files into groups, perhaps in "
"separate subdirectories, that each need different include directories and"
" preprocessor definitions. For this use case CMake has developed the "
"concept of Object Libraries."
msgstr "I progetti di grandi dimensioni spesso organizzano i propri file sorgenti in gruppi, magari in sottodirectory separate, ciascuna delle quali necessita di diverse directory di inclusione e definizioni del preprocessore. Per questo caso d'uso CMake ha sviluppato il concetto di Object Libraries (librerie di oggetti)."

#: ../../source/chapter/Key Concepts.rst:149
msgid ""
"An Object Library is a collection of source files compiled into an object"
" file which is not linked into a library file or made into an archive. "
"Instead other targets created by :command:`add_library` or "
":command:`add_executable` may reference the objects using an expression "
"of the form ``$<TARGET_OBJECTS:name>`` as a source, where \"name\" is the"
" target created by the :command:`add_library` call. For example:"
msgstr "Una Object Library è una raccolta di sorgenti compilati in un file oggetto che non è collegato a un file di libreria o trasformato in un archivio. Invece altri target creati da :command:`add_library` o da :command:`add_executable` possono fare riferimento agli oggetti utilizzando un'espressione della forma ``$<TARGET_OBJECTS:name>`` come sorgente, dove \"name\" è il target creato dalla chiamata :command:`add_library`. Per esempio:"

#: ../../source/chapter/Key Concepts.rst:162
msgid ""
"will include A and B object files in a library called Combined. Object "
"libraries may contain only sources (and headers) that compile to object "
"files."
msgstr "includerà i file oggetto A e B in una libreria chiamata Combined. Le librerie di oggetti possono contenere solo sorgenti (e header) che vengono compilati in file oggetto."

#: ../../source/chapter/Key Concepts.rst:171
msgid "Source Files"
msgstr "File Sorgenti"

#: ../../source/chapter/Key Concepts.rst:173
msgid ""
"The source file structure is in many ways similar to a target. It stores "
"the filename, extension, and a number of general properties related to a "
"source file. Like targets, you can set and get properties using "
":command:`set_source_files_properties` and "
":command:`get_source_file_property`, or the more generic versions."
msgstr "La struttura del file sorgenti è per molti versi simile a un target. Memorizza il nome del file, l'estensione e una serie di proprietà generali relative a un file sorgente. Come per i target, si possono impostare e ottenere proprietà usando :command:`set_source_files_properties` e :command:`get_source_file_property`, o le versioni più generiche."

#: ../../source/chapter/Key Concepts.rst:180
msgid "Directories, Tests, and Properties"
msgstr "Directory, Test e Proprietà"

#: ../../source/chapter/Key Concepts.rst:182
msgid ""
"In addition to targets and source files, you may find yourself "
"occasionally working with other objects such as directories and tests. "
"Normally such interactions take the shape of setting or getting "
"properties (e.g. :command:`set_directory_properties` or "
":command:`set_tests_properties`) from these objects."
msgstr "Oltre ai target e ai sorgenti, ci si potrebbe trovare a lavorare occasionalmente con altri oggetti come directory e test. Normalmente tali interazioni assumono la forma impostazioni o interrogazioni delle proprietà (ad esempio :command:`set_directory_properties` o :command:`set_tests_properties`) da questi oggetti."

#: ../../source/chapter/Modules.rst:2
msgid "Modules"
msgstr "Moduli"

#: ../../source/chapter/Modules.rst:8
msgid "Using Modules"
msgstr "Utilizzo dei Moduli"

#: ../../source/chapter/Modules.rst:10
msgid ""
"Code reuse is a valuable technique in software development and CMake has "
"been designed to support it. Allowing CMakeLists files to make use of "
"reusable modules enables the entire community to share reusable sections "
"of code. For CMake, these sections are called :manual:`cmake-modules "
"<cmake-modules(7)>` and can be found in the Modules subdirectory of your "
"installation."
msgstr "Il riutilizzo del codice è una tecnica preziosa nello sviluppo del software e CMake è stato progettato per supportarlo. Consentire ai file CMakeLists di utilizzare moduli riutilizzabili consente all'intera comunità di condividere sezioni di codice riutilizzabili. Per CMake, queste sezioni sono chiamate :manual:`cmake-modules <cmake-modules(7)>` e si trovano nella sottodirectory Modules dell'installazione."

#: ../../source/chapter/Modules.rst:17
msgid ""
"A module's location can be specified using the full path to the module "
"file, or by letting CMake find the module by itself. CMake will look for "
"modules in the directories specified by :variable:`CMAKE_MODULE_PATH`; if"
" it cannot find it there, it will look in the Modules subdirectory. This "
"way projects can override modules that CMake provides and customize them "
"for their needs. Modules can be broken into a few main categories:"
msgstr "La posizione di un modulo può essere specificata utilizzando il path completo del file del modulo o lasciando che CMake lo trovi da solo. CMake cercherà i moduli nelle directory specificate da :variable:`CMAKE_MODULE_PATH`; se non riesce a trovarlo lì, cercherà nella sottodirectory Modules. In questo modo i progetti possono sovrascrivere i moduli forniti da CMake e personalizzarli in base alle proprie esigenze. I moduli possono essere suddivisi in alcune categorie principali:"

#: ../../source/chapter/Modules.rst:29
msgid "Find Modules"
msgstr "Moduli Find"

#: ../../source/chapter/Modules.rst:31
msgid ""
"These modules support the :command:`find_package` command to determine "
"the location of software elements, such as header files or libraries, "
"that belong to a given package.  Do not include them directly.  Use the "
":command:`find_package` command.  Each module comes with documentation "
"describing the package it finds and the variables in which it provides "
"results."
msgstr "Questi moduli supportano il comando :command:`find_package` per determinare la posizione degli elementi software, come i file header o le librerie, che appartengono a un determinato pacchetto.  Non si devono includere direttamente.  Si usa il comando :command:`find_package`.  Ogni modulo viene fornito con una documentazione che descrive il pacchetto che trova e le variabili in cui fornisce i risultati."

#: ../../source/chapter/Modules.rst:42
msgid "Utility Modules"
msgstr "Moduli Utility"

#: ../../source/chapter/Modules.rst:44
msgid ""
"Utility modules are simply sections of CMake commands put into a file; "
"they can then be included into other CMakeLists files using the "
":command:`include` command. For example, the following commands will "
"include the :module:`CheckTypeSize` module from CMake and then use the "
"macro it defines."
msgstr "I moduli utility sono semplicemente sezioni di comandi CMake inseriti in un file; possono quindi essere inclusi in altri file CMakeLists utilizzando il comando :command:`include`. Ad esempio, i seguenti comandi includeranno il modulo :module:`CheckTypeSize` di CMake e poi utilizzeranno la macro che definisce."

#: ../../source/chapter/Modules.rst:54
msgid ""
"These modules test the system to provide information about the target "
"platform or compiler, such as the size of a float or support for ANSI C++"
" streams. Many of these modules have names prefixed with ``Test`` or "
"``Check``, such as :module:`TestBigEndian` and :module:`CheckTypeSize`. "
"Some of them try to compile code in order to determine the correct "
"result. In these cases, the source code is typically named the same as "
"the module, but with a ``.c`` or ``.cxx`` extension. Utility modules also"
" provide useful macros and functions implemented in the CMake language "
"and intended for specific, common use cases.  See documentation of each "
"module for details."
msgstr "Questi moduli testano il sistema per fornire informazioni sulla piattaforma o sul compilatore target, ad esempio la dimensione di un float o il supporto per gli stream ANSI C++. Molti di questi moduli hanno nomi preceduti da ``Test`` o ``Check``, come :module:`TestBigEndian` e :module:`CheckTypeSize`. Alcuni di loro cercano di compilare il codice per determinare il risultato corretto. In questi casi, il codice sorgente è tipicamente denominato come il modulo, ma con un'estensione ``.c`` o ``.cxx``. I moduli di utility forniscono anche utili macro e funzioni implementate nel linguaggio CMake e destinate a casi d'uso specifici e comuni.  Consultare la documentazione di ciascun modulo per i dettagli."

#: ../../source/chapter/Packaging CPack.rst:5 With
msgid "Packaging With CPack"
msgstr "Il Packaging Con CPack"

#: ../../source/chapter/Packaging CPack.rst:7 With
msgid ""
"CPack is a powerful, easy to use, cross-platform software packaging tool "
"distributed with CMake. It uses the generators concept from CMake to "
"abstract package generation on specific platforms. It can be used with or"
" without CMake, but it may depend on some software being installed on the"
" system. Using a simple configuration file, or using a CMake module, the "
"author of a project can package a complex project into a simple "
"installer. This chapter will describe how to apply CPack to a CMake "
"project."
msgstr "CPack è uno strumento di packaging software potente, facile da usare e multipiattaforma distribuito con CMake. Utilizza il concetto di generatori di CMake per astrarre la generazione di pacchetti su piattaforme specifiche. Può essere utilizzato con o senza CMake, ma potrebbe dipendere da alcuni software installati sul sistema. Utilizzando un semplice file di configurazione o utilizzando un modulo CMake, l'autore di un progetto può impacchettare un progetto complesso in un semplice programma di installazione. Questo capitolo descriverà come applicare CPack a un progetto CMake."

#: ../../source/chapter/Packaging CPack.rst:16 With
msgid "CPack Basics"
msgstr "Nozioni di base su CPack"

#: ../../source/chapter/Packaging CPack.rst:27 With
msgid ""
"Users of your software may not always want to, or be able to, build the "
"software in order to install it. The software may be closed source, or it"
" may take a long time to compile, or in the case of an end user "
"application, the users may not have the skill or the tools to build the "
"application. For these cases, what is needed is a way to build the "
"software on one machine, and then move the install tree to a different "
"machine. The most basic way to do this is to use the DESTDIR environment "
"variable to install the software into a temporary location, then to tar "
"or zip up that directory and move it to another machine. However, the "
"DESTDIR approach falls short on Windows, simply because path names "
"typically start with a drive letter (C:/) and you cannot simply prefix "
"one full path with another and get a valid path name. Another more "
"powerful approach is to use CPack, included in CMake."
msgstr "Gli utenti del software potrebbero non sempre volere o essere in grado di creare il software per installarlo. Il software potrebbe essere a codice chiuso o la compilazione potrebbe richiedere molto tempo oppure, nel caso di un'applicazione per l'utente finale, gli utenti potrebbero non disporre delle competenze o degli strumenti per creare l'applicazione. In questi casi, è necessario un modo per creare il software su una macchina e quindi spostare l'albero di installazione su un'altra macchina. Il modo più semplice per farlo è utilizzare la variabile d'ambiente DESTDIR per installare il software in una posizione temporanea, poi tarare o comprimere quella directory e spostarla su un'altra macchina. Tuttavia, l'approccio DESTDIR non è all'altezza su Windows, semplicemente perché i path in genere iniziano con una lettera di unità (C:/) e non è possibile aggiungere semplicemente un prefisso a un path completo con un altro e ottenere un nome di path valido. Un altro approccio più potente consiste nell'utilizzare CPack, incluso in CMake."

#: ../../source/chapter/Packaging CPack.rst:42 With
msgid ""
"CPack is a tool included with CMake, it can be used to create installers "
"and packages for projects. CPack can create two basic types of packages, "
"source and binary. CPack works in much the same way as CMake does for "
"building software. It does not aim to replace native packaging tools, "
"rather it provides a single interface to a variety of tools. Currently "
"CPack supports the creation of Windows installers using NullSoft "
"installer NSIS or WiX, Mac OS X PackageMaker tool, OS X Drag and Drop, OS"
" X X11 Drag and Drop, Cygwin Setup packages, Debian packages, RPMs, "
".tar.gz, .sh (self extracting .tar.gz files), and .zip compressed files. "
"The implementation of CPack works in a similar way to CMake. For each "
"type of packaging tool supported, there is a CPack generator written in "
"C++ that is used to run the native tool and create the package. For "
"simple tar based packages, CPack includes a library version of tar and "
"does not require tar to be installed on the system. For many of the other"
" installers, native tools must be present for CPack to function."
msgstr "CPack è un tool incluso con CMake, può essere utilizzato per creare programmi di installazione e pacchetti per progetti. CPack può creare due tipi base di pacchetti, sorgente e binario. CPack funziona più o meno allo stesso modo di CMake per la creazione di software. Non mira a sostituire i tool di packaging nativi, piuttosto fornisce un'unica interfaccia a una varietà di strumenti. Attualmente CPack supporta la creazione di programmi di installazione Windows utilizzando il programma di installazione NullSoft NSIS o WiX, il tool Mac OS X PackageMaker, OS X Drag and Drop, OS X X11 Drag and Drop, pacchetti Cygwin Setup, pacchetti Debian, RPM, .tar.gz, .sh (file .tar.gz autoestraenti) e file compressi .zip. L'implementazione di CPack funziona in modo simile a CMake. Per ogni tipo di strumento di creazione pacchetti supportato, esiste un generatore CPack scritto in C++ utilizzato per eseguire il tool nativo e creare il pacchetto. Per semplici pacchetti basati su tar, CPack include una versione di libreria di tar e non richiede l'installazione di tar sul sistema. Per molti degli altri programmi di installazione, gli strumenti nativi devono essere presenti affinché CPack funzioni."

#: ../../source/chapter/Packaging CPack.rst:64 With
msgid ""
"With source packages, CPack makes a copy of the source tree and creates a"
" zip or tar file. For binary packages, the use of CPack is tied to the "
"install commands working correctly for a project. When setting up install"
" commands, the first step is to make sure the files go into the correct "
"directory structure with the correct permissions. The next step is to "
"make sure the software is relocatable and can run in an installed tree. "
"This may require changing the software itself, and there are many "
"techniques to do that for different environments that go beyond the scope"
" of this book. Basically, executables should be able to find data or "
"other files using relative paths to the location of where it is "
"installed. CPack installs the software into a temporary directory, and "
"copies the install tree into the format of the native packaging tool. "
"Once the install commands have been added to a project, enabling CPack in"
" the simplest case is done by including the CPack.cmake file into the "
"project."
msgstr "Con i pacchetti dei sorgenti, CPack crea una copia dell'albero dei sorgenti e crea un file zip o tar. Per i pacchetti binari, l'uso di CPack è legato ai comandi di installazione che funzionano correttamente per un progetto. Quando si impostano i comandi di installazione, il primo passo consiste nell'assicurarsi che i file vadano nella struttura di directory corretta con le autorizzazioni corrette. Il passaggio successivo consiste nell'assicurarsi che il software sia riposizionabile e possa essere eseguito in un albero installato. Ciò potrebbe richiedere la modifica del software stesso e ci sono molte tecniche per farlo per ambienti diversi che vanno oltre lo scopo di questo libro. Fondamentalmente, gli eseguibili dovrebbero essere in grado di trovare dati o altri file utilizzando path relativi alla posizione in cui sono installati. CPack installa il software in una directory temporanea e copia l'albero di installazione nel formato del tool di packaging nativo. Una volta che i comandi di installazione sono stati aggiunti a un progetto, l'abilitazione di CPack nel caso più semplice viene eseguita includendo il file CPack.cmake nel progetto."

#: ../../source/chapter/Packaging CPack.rst:82 With
msgid "Simple Example"
msgstr "Un Esempio Semplice"

#: ../../source/chapter/Packaging CPack.rst:84 With
msgid "The most basic CPack project would look like this"
msgstr "Il progetto CPack più semplice sarebbe simile a questo"

#: ../../source/chapter/Packaging CPack.rst:100 With
msgid ""
"In the CoolStuff project, an executable is created and installed into the"
" directory bin. Then the CPack file is included by the project. At this "
"point project CoolStuff will have CPack enabled. To run CPack for a "
"CoolStuff, you would first build the project as you would any other CMake"
" project. CPack adds several targets to the generated project. These "
"targets in Makefiles are package and package_source, and PACKAGE in "
"Visual Studio and Xcode. For example, to build a source and binary "
"package for CoolStuff using a Makefile generator you would run the "
"following commands::"
msgstr "Nel progetto CoolStuff, un eseguibile viene creato e installato nella directory bin. Quindi il file CPack viene incluso dal progetto. A questo punto il progetto CoolStuff avrà CPack abilitato. Per eseguire CPack per CoolStuff, si deve prima creare il progetto come si farebbe con qualsiasi altro progetto CMake. CPack aggiunge diversi target al progetto generato. Questi target nei Makefile sono package e package_source e PACKAGE in Visual Studio e Xcode. Ad esempio, per creare un pacchetto sorgente e binario per CoolStuff utilizzando un generatore di Makefile, si eseguiranno i seguenti comandi::"

#: ../../source/chapter/Packaging CPack.rst:117 With
msgid ""
"This would create a source zip file called "
"``CoolStuff-0.1.1-Source.zip``, a NSIS installer called "
"``CoolStuff-0.1.1-win32.exe``, and a binary zip file "
"``CoolStuff-0.1.1-win32.zip``. The same thing could be done using the "
"CPack command line."
msgstr "Questo creerebbe un file zip di sorgenti chiamato ``CoolStuff-0.1.1-Source.zip``, in installer NSIS chiamato ``CoolStuff-0.1.1-win32.exe``, e un file zip binario ``CoolStuff-0.1.1-win32.zip``. La stessa cosa potrebbe essere fatta usando la riga di comando CPack."

#: ../../source/chapter/Packaging CPack.rst:130 With
msgid "What Happens When CPack.cmake Is Included?"
msgstr "Cosa Succede Quando Viene Incluso CPack.cmake?"

#: ../../source/chapter/Packaging CPack.rst:135 With
msgid ""
"When the ``include(CPack)`` command is executed, the ``CPack.cmake`` file"
" is included into the project. By default this will use the "
":command:`configure_file` command to create ``CPackConfig.cmake`` and "
"``CPackSourceConfig.cmake`` in the binary tree of the project. These "
"files contain a series of set commands that set variables for use when "
"CPack is run during the packaging step. The names of the files that are "
"configured by the ``CPack.cmake`` file can be customized with these two "
"variables; ``CPACK_OUTPUT_CONFIG_FILE`` which defaults to "
"``CPackConfig.cmake`` and ``CPACK_SOURCE_OUTPUT_CONFIG_FILE`` which "
"defaults to ``CPackSourceConfig.cmake``."
msgstr "Quando viene eseguito il comando ``include(CPack)``, viene incluso il file ``CPack.cmake`` nel progetto. Per default userà il comando :command:`configure_file` per creare ``CPackConfig.cmake`` e ``CPackSourceConfig.cmake`` nell'albero binario del progetto. Questi file contengono una serie di comandi set che impostano le variabili da utilizzare quando CPack viene eseguito durante la fase di impacchettamento. I nomi dei file configurati dal file ``CPack.cmake`` possono essere personalizzati con queste due variabili; ``CPACK_OUTPUT_CONFIG_FILE`` il cui valore predefinito è ``CPackConfig.cmake`` e ``CPACK_SOURCE_OUTPUT_CONFIG_FILE`` il cui valore predefinito è ``CPackSourceConfig.cmake``."

#: ../../source/chapter/Packaging CPack.rst:146 With
msgid ""
"The source for these files can be found in the "
"``Templates/CPackConfig.cmake.in``. This file contains some comments, and"
" a single variable that is set by ``CPack.cmake``. The file contains this"
" line of CMake code::"
msgstr "Il sorgente di questi file si trova in ``Templates/CPackConfig.cmake.in``. Questo file contiene alcuni commenti e una singola variabile impostata da ``CPack.cmake``. Il file contiene questa riga di codice CMake::"

#: ../../source/chapter/Packaging CPack.rst:153 With
msgid ""
"If the project contains the file ``CPackConfig.cmake.in`` in the top "
"level of the source tree, that file will be used instead of the file in "
"the Templates directory. If the project contains the file "
"``CPackSourceConfig.cmake.in``, then that file will be used for the "
"creation of ``CPackSourceConfig.cmake``."
msgstr "Se il progetto contiene il file ``CPackConfig.cmake.in`` nel livello superiore dell'albero dei sorgenti, tale file verrà utilizzato al posto di quello nella directory Templates. Se il progetto contiene il file ``CPackSourceConfig.cmake.in``, quel file verrà utilizzato per la creazione di ``CPackSourceConfig.cmake``."

#: ../../source/chapter/Packaging CPack.rst:159 With
msgid ""
"The configuration files created by ``CPack.cmake`` will contain all the "
"variables that begin with \"CPACK\\_\\\" in the current project. This is "
"done using the command"
msgstr "I file di configurazione creati da ``CPack.cmake`` conterranno tutte le variabili che iniziano con \"CPACK\\_\\\" nel progetto corrente. Questo viene fatto usando il comando"

#: ../../source/chapter/Packaging CPack.rst:170 With
msgid ""
"The above command gets all variables defined for the current CMake "
"project. Some CMake code then looks for all variables starting with "
"\"CPACK\\_\\\", and each variable found is configured into the two "
"configuration files as CMake code. For example, if you had a variable set"
" like this in your CMake project"
msgstr "Il comando precedente ottiene tutte le variabili definite per il progetto CMake corrente. Parte del codice CMake cerca quindi tutte le variabili che iniziano con \"CPACK\\_\\\" e ogni variabile trovata viene configurata nei due file di configurazione come codice CMake. Ad esempio, se avessimo una variabile impostata come questa nel progetto CMake"

#: ../../source/chapter/Packaging CPack.rst:183 With
msgid ""
"``CPackConfig.cmake`` and ``CPackSourceConfig.cmake`` would have the same"
" thing in them:"
msgstr "``CPackConfig.cmake`` e ``CPackSourceConfig.cmake`` avrebbero la stessa cosa al loro interno:"

#: ../../source/chapter/Packaging CPack.rst:193 With
msgid ""
"It is important to keep in mind that CPack is run after CMake on the "
"project. CPack uses the same parser as CMake, but will not have the same "
"variable values as the CMake project. It will only have the variables "
"that start with CPACK\\_\\, and these variables will be configured into a"
" configuration file by CMake. This can cause some errors and confusion if"
" the values of the variables use escape characters. Since they are "
"getting parsed twice by the CMake language, they will need double the "
"level of escaping. For example, if you had the following in your CMake "
"project:"
msgstr "È importante tenere presente che CPack viene eseguito dopo CMake sul progetto. CPack utilizza lo stesso parser di CMake, ma non avrà gli stessi valori di variabile del progetto CMake. Avrà solo le variabili che iniziano con CPACK\\_\\, e queste variabili saranno configurate in un file da CMake. Ciò può causare alcuni errori e confusione se i valori delle variabili utilizzano caratteri di escape. Poiché vengono analizzati due volte dal linguaggio CMake, avranno bisogno del doppio del livello di escape. Ad esempio, se avessimo quanto segue nel progetto CMake:"

#: ../../source/chapter/Packaging CPack.rst:207 With
msgid "The resulting CPack files would have this:"
msgstr "I file CPack risultanti avrebbero questo:"

#: ../../source/chapter/Packaging CPack.rst:213 With
msgid ""
"That would not be exactly what you would want or expect. In fact, it just"
" wouldn't work. To get around this problem, there are two solutions. The "
"first is to add an additional level of escapes to the original set "
"command like this:"
msgstr "Non sarebbe esattamente quello voluto o che ci si aspetterebbe. In effetti, semplicemente non funzionerebbe. Per aggirare questo problema, ci sono due soluzioni. La prima è aggiungere un ulteriore livello di escape al comando set originale in questo modo:"

#: ../../source/chapter/Packaging CPack.rst:222 With
msgid ""
"This would result in the correct ``set`` command which would look like "
"this:"
msgstr "Ciò risulterebbe nel comando ``set`` corretto che sarebbe simile a questo:"

#: ../../source/chapter/Packaging CPack.rst:229 With
msgid ""
"The second solution to the escaping problem is to use a CPack project "
"config file, explained in the next section."
msgstr "La seconda soluzione al problema dell'escape è utilizzare un file di configurazione del progetto CPack, spiegato nella sezione successiva."

#: ../../source/chapter/Packaging CPack.rst:233 With
msgid "Adding Custom CPack Options"
msgstr "Aggiunta di Opzioni CPack Custom"

#: ../../source/chapter/Packaging CPack.rst:235 With
msgid ""
"To avoid the escaping problem a project specific CPack configure file can"
" be specified. This file will be loaded by CPack after "
"``CPackConfig.cmake`` or ``CPackSourceConfig.cmake`` is loaded, and "
":variable:`CPACK_GENERATOR` will be set to the CPack generator being run."
" Variables set in this file only require one level of CMake escapes. This"
" file can be configured or not, and contains regular CMake code. In the "
"example above, you could move ``CPACK_FOOBAR`` into a file "
"``MyCPackOptions.cmake.in`` and configure that file into the build tree "
"of the project. Then set the project configuration file path like this:"
msgstr "Per evitare il problema dell'escape, è possibile specificare un file di configurazione CPack specifico per il progetto. Questo file verrà caricato da CPack dopo il caricamento di ``CPackConfig.cmake`` o di ``CPackSourceConfig.cmake`` e :variable:`CPACK_GENERATOR` verrà impostata sul generatore CPack in funzione. Le variabili impostate in questo file richiedono solo un livello di escape CMake. Questo file può essere configurato o meno e contiene il normale codice CMake. Nell'esempio sopra, si può spostare ``CPACK_FOOBAR`` in un file ``MyCPackOptions.cmake.in`` e configurarlo nell'albero di build del progetto. Poi impostare il path del file di configurazione del progetto in questo modo:"

#: ../../source/chapter/Packaging CPack.rst:254 With
msgid "Where ``MyCPackOptions.cmake.in`` contained:"
msgstr "Dove ``MyCPackOptions.cmake.in`` contiene:"

#: ../../source/chapter/Packaging CPack.rst:260 With
msgid ""
"The :variable:`CPACK_PROJECT_CONFIG_FILE` variable should contain the "
"full path to the CPack config file for the project, as seen in the above "
"example. This has the added advantage that the CMake code can contain if "
"statements based on the :variable:`CPACK_GENERATOR` value, so that "
"packager specific values can be set for a project. For example, the CMake"
" project sets the icon for the installer in this file:"
msgstr "La variabile :variable:`CPACK_PROJECT_CONFIG_FILE` dovrebbe contenere il path completo del file di configurazione CPack per il progetto, come mostrato nell'esempio precedente. Ciò ha l'ulteriore vantaggio che il codice CMake può contenere istruzioni if basate sul valore di :variable:`CPACK_GENERATOR`, in modo che i valori specifici del packager possano essere impostati per un progetto. Ad esempio, il progetto CMake imposta l'icona per il programma di installazione in questo file:"

#: ../../source/chapter/Packaging CPack.rst:275 With
msgid ""
"Note that the path has forward slashes except for the last part which has"
" an escaped \\ as the path separator. As of the writing of this book, "
"NSIS needed the last part of the path to have a Windows style slash. If "
"you do not do this, you may get the following error::"
msgstr "Si noti che il path ha barre ad eccezione dell'ultima parte che ha un carattere di escape \\ come separatore di path. Al momento della stesura di questo libro, NSIS aveva bisogno che l'ultima parte del path avesse una barra in stile Windows. Se non lo si fa, si potrebbe ricevere il seguente errore::"

#: ../../source/chapter/Packaging CPack.rst:285 With
msgid "Options Added by CPack"
msgstr "Opzioni Aggiunte da CPack"

#: ../../source/chapter/Packaging CPack.rst:290 With
msgid ""
"In addition to creating the two configuration files, ``CPack.cmake`` will"
" add some advanced options to your project. The options added depend on "
"the environment and OS that CMake is running on, and control the default "
"packages that are created by CPack. These options are of the form "
"``CPACK_<CPack Generator Name>``, where generator names available on each"
" platform can be found in the following table:"
msgstr "Oltre a creare i due file di configurazione, ``CPack.cmake`` aggiungerà alcune opzioni avanzate al progetto. Le opzioni aggiunte dipendono dall'ambiente e dal sistema operativo su cui è in esecuzione CMake e controllano i pacchetti di default creati da CPack. Queste opzioni sono nel formato ``CPACK_<CPack Generator Name>``, dove i nomi dei generatori disponibili su ogni piattaforma possono essere trovati nella seguente tabella:"

#: ../../source/chapter/Packaging CPack.rst:298 With
msgid "Windows"
msgstr "Windows"

#: ../../source/chapter/Packaging CPack.rst:298 With
msgid "Cygwin"
msgstr "Cygwin"

#: ../../source/chapter/Packaging CPack.rst:298 With
msgid "Linux/UNIX"
msgstr "Linux/UNIX"

#: ../../source/chapter/Packaging CPack.rst:298 With
msgid "Mac OS X"
msgstr "Mac OS X"

#: ../../source/chapter/Packaging CPack.rst:300 With
msgid "NSIS"
msgstr "NSIS"

#: ../../source/chapter/Packaging CPack.rst:300 With
msgid "CYGWIN_BINARY"
msgstr "CYGWIN_BINARY"

#: ../../source/chapter/Packaging CPack.rst:300 With
msgid "DEB"
msgstr "DEB"

#: ../../source/chapter/Packaging CPack.rst:300 With
msgid "PACKAGEMAKER"
msgstr "PACKAGEMAKER"

#: ../../source/chapter/Packaging CPack.rst:302 With
msgid "ZIP"
msgstr "ZIP"

#: ../../source/chapter/Packaging CPack.rst:302 With
msgid "SOURCE_CYGWIN"
msgstr "SOURCE_CYGWIN"

#: ../../source/chapter/Packaging CPack.rst:302 With
msgid "RPM"
msgstr "RPM"

#: ../../source/chapter/Packaging CPack.rst:302 With
msgid "DRAGANDROP"
msgstr "DRAGANDROP"

#: ../../source/chapter/Packaging CPack.rst:304 With
msgid "SOURCE_ZIP"
msgstr "SOURCE_ZIP"

#: ../../source/chapter/Packaging CPack.rst:304 With
msgid "STGZ"
msgstr "STGZ"

#: ../../source/chapter/Packaging CPack.rst:304 With
msgid "BUNDLE"
msgstr "BUNDLE"

#: ../../source/chapter/Packaging CPack.rst:306 With
msgid "TBZ2"
msgstr "TBZ2"

#: ../../source/chapter/Packaging CPack.rst:306 With
msgid "OSXX11"
msgstr "OSXX11"

#: ../../source/chapter/Packaging CPack.rst:308 With
msgid "TGZ"
msgstr "TGZ"

#: ../../source/chapter/Packaging CPack.rst:310 With
msgid "TZ"
msgstr "TZ"

#: ../../source/chapter/Packaging CPack.rst:312 With
msgid "SOURCE_TGZ"
msgstr "SOURCE_TGZ"

#: ../../source/chapter/Packaging CPack.rst:314 With
msgid "SOURCE_TZ"
msgstr "SOURCE_TZ"

#: ../../source/chapter/Packaging CPack.rst:317 With
msgid ""
"Turning these options on or off affects the packages that are created "
"when running CPack with no options. If the option is off in the "
"CMakeCache.txt file for the project, you can still build that package "
"type by specifying the -G option to the CPack command line."
msgstr "L'attivazione o la disattivazione di queste opzioni influisce sui pacchetti creati durante l'esecuzione di CPack senza opzioni. Se l'opzione è disattivata nel file CMakeCache.txt per il progetto, si può comunque creare quel tipo di pacchetto specificando l'opzione -G nella riga di comando CPack."

#: ../../source/chapter/Packaging CPack.rst:326 With
msgid "CPack Source Packages"
msgstr "Package dei Sorgenti CPack"

#: ../../source/chapter/Packaging CPack.rst:328 With
msgid ""
"Source packages in CPack simply copy the entire source tree for a project"
" into a package file, and no install rules are used as they are in the "
"case of binary packages. Out of source builds should be used to avoid "
"having extra binary stuff polluting the source package. If you have files"
" or directories in your source tree that are not wanted in the source "
"package, you can use the variable :variable:`CPACK_SOURCE_IGNORE_FILES` "
"to exclude things from the package. This variable contains a list of "
"regular expressions. Any file or directory that matches a regular "
"expression in that list will be excluded from the sources. The default "
"setting is as follows::"
msgstr "I pacchetti di sorgenti in CPack copiano semplicemente l'intero albero dei sorgenti per un progetto in un file e non vengono utilizzate regole di installazione come nel caso dei pacchetti binari. Si dovrebbero effettuare build al di fuori dei sorgenti per evitare che materiale binario extra inquini il pacchetto sorgente. Se ci sono file o directory nell'albero dei sorgenti che non sono desiderati nel pacchetto dei sorgenti, si può usare la variabile :variable:`CPACK_SOURCE_IGNORE_FILES` per escludere delle cose dal pacchetto. Questa variabile contiene un elenco di espressioni regolari. Qualsiasi file o directory che corrisponda a un'espressione regolare in questo elenco verrà escluso dalle fonti. L'impostazione di default è la seguente::"

#: ../../source/chapter/Packaging CPack.rst:341 With
msgid ""
"There are many levels of escapes used in the default value as this "
"variable is parsed by CMake once and CPack again. It is important to "
"realize that the source tree will not use any install commands, it will "
"simply copy the entire source tree minus the files it is told to ignore "
"into the package. To avoid the multiple levels of escape, the file "
"referenced by :variable:`CPACK_PROJECT_CONFIG_FILE` should be used to set"
" this variable. The expression is a regular expression and not a wild "
"card statement, see Chapter 4 for more information about CMake regular "
"expressions."
msgstr "Ci sono molti livelli di escape utilizzati nel valore di default poiché questa variabile viene analizzata da CMake una volta e da CPack di nuovo. È importante rendersi conto che l'albero dei sorgenti non utilizzerà alcun comando di installazione, copierà semplicemente l'intero albero dei sorgenti meno i file che gli vengono detti di ignorare nel pacchetto. Per evitare i molteplici livelli di escape, il file a cui fa riferimento :variable:`CPACK_PROJECT_CONFIG_FILE` dovrebbe essere utilizzato per impostare questa variabile. L'espressione è un'espressione regolare e non un'istruzione con caratteri jolly, vedere il Capitolo 4 per ulteriori informazioni sulle espressioni regolari di CMake."

#: ../../source/chapter/Packaging CPack.rst:352 With
msgid "CPack Installer Commands"
msgstr "Comandi CPack dell'Installer"

#: ../../source/chapter/Packaging CPack.rst:354 With
msgid ""
"Since binary packages require CPack to interact with the install rules of"
" the project being packaged, this section will cover some of the options "
"CPack provides to interact with the install rules of a project. CPack can"
" work with CMake's install scripts or with external install commands."
msgstr "Poiché i pacchetti binari richiedono che CPack interagisca con le regole di installazione del progetto da impacchettare, questa sezione coprirà alcune delle opzioni fornite da CPack per interagire con le regole di installazione di un progetto. CPack può funzionare con gli script di installazione di CMake o con comandi di installazione esterni."

#: ../../source/chapter/Packaging CPack.rst:361 With
msgid "CPack and CMake install commands"
msgstr "Comandi Install CPack e CMake"

#: ../../source/chapter/Packaging CPack.rst:363 With
msgid ""
"In most CMake projects, using the CMake install rules will be sufficient "
"to create the desired package. By default CPack will run the install rule"
" for the current project. However, if you have a more complicated "
"project, you can specify sub-projects and install directories with the "
"variable :variable:`CPACK_INSTALL_CMAKE_PROJECTS`. This variable should "
"hold quadruplets of install directory, install project name, install "
"component, and install subdirectory. For example, if you had a project "
"with a sub project called MySub that was compiled into a directory called"
" SubProject, and you wanted to install all of its components, you would "
"have this:"
msgstr "Nella maggior parte dei progetti CMake, l'utilizzo delle regole di installazione di CMake sarà sufficiente per creare il pacchetto desiderato. Per default CPack eseguirà la regola di installazione per il progetto corrente. Tuttavia, con un progetto più complicato, si possono specificare sottoprogetti e directory di installazione con la variabile :variable:`CPACK_INSTALL_CMAKE_PROJECTS`. Questa variabile dovrebbe contenere quadruple di directory di installazione, nome del progetto di installazione, la componente dell'installazione e le sottodirectory di installazione. Ad esempio, per un progetto con un sottoprogetto chiamato MySub compilato in una directory chiamata SubProject e per installare tutti i suoi componenti, si avrebbe:"

#: ../../source/chapter/Packaging CPack.rst:383 With
msgid "CPack and DESTDIR"
msgstr "CPack e DESTDIR"

#: ../../source/chapter/Packaging CPack.rst:385 With
msgid ""
"By default CPack does not use the :envvar:`DESTDIR` option during the "
"installation phase. Instead it sets the :variable:`CMAKE_INSTALL_PREFIX` "
"to the full path of the temporary directory being used by CPack to stage "
"the install package. This can be changed by setting "
":variable:`CPACK_SET_DESTDIR` to on. If the :variable:`CPACK_SET_DESTDIR`"
" option is on, CPack will use the project's cache value for "
"``CPACK_INSTALL_PREFIX``, and set :envvar:`DESTDIR` to the temporary "
"staging area. This allows absolute paths to be installed under the "
"temporary directory. Relative paths are installed into "
"``DESTDIR/${project's CMAKE_INSTALL_PREFIX}`` where :envvar:`DESTDIR` is "
"set to the temporary staging area."
msgstr "Per default CPack non usa l'opzione :envvar:`DESTDIR` durante la fase di installazione. Imposta invece :variable:`CMAKE_INSTALL_PREFIX` sul path completo della directory temporanea utilizzata da CPack per preparare il pacchetto di installazione. Questo si può cambiare impostando :variable:`CPACK_SET_DESTDIR` su on. Se l'opzione :variable:`CPACK_SET_DESTDIR` è on, CPack utilizzerà il valore della cache del progetto per ``CPACK_INSTALL_PREFIX`` e imposta :envvar:`DESTDIR` sul valore temporaneo dell'area di staging. Ciò consente l'installazione di path assoluti nella directory temporanea. I path relativi vengono installati in ``DESTDIR/${project's CMAKE_INSTALL_PREFIX}`` dove :envvar:`DESTDIR` è impostata sull'area di staging temporanea."

#: ../../source/chapter/Packaging CPack.rst:397 With
msgid ""
"As noted earlier, the :envvar:`DESTDIR` approach does not work when the "
"install rules reference files by Windows full paths beginning with drive "
"letters (C:/)."
msgstr "Come notato in precedenza, l'approccio :envvar:`DESTDIR` non funziona quando le regole di installazione fanno riferimento ai file tramite path completi di Windows che iniziano con lettere di unità (C:/)."

#: ../../source/chapter/Packaging CPack.rst:401 With
msgid ""
"When doing a non-:envvar:`DESTDIR` install for packaging, which is the "
"default, any absolute paths are installed into absolute directories, and "
"not into the package. Therefore, projects that do not use the "
":envvar:`DESTDIR` option, must not use any absolute paths in install "
"rules. Conversely, projects that use absolute paths, must use the "
":envvar:`DESTDIR` option."
msgstr "Quando si esegue un'installazione diversa da :envvar:`DESTDIR` per il pacchetto, che è il default, tutti i path assoluti vengono installati nelle directory assolute e non nel pacchetto. Pertanto, i progetti che non utilizzano l'opzione :envvar:`DESTDIR` non devono utilizzare path assoluti nelle regole di installazione. Al contrario, i progetti che utilizzano path assoluti devono utilizzare l'opzione :envvar:`DESTDIR`."

#: ../../source/chapter/Packaging CPack.rst:408 With
msgid ""
"One other variable can be used to control the root path projects are "
"installed into, the :variable:`CPACK_PACKAGING_INSTALL_PREFIX`. By "
"default many of the generators install into the directory /usr. That "
"variable can be used to change that to any directory, including just /."
msgstr "Un'altra variabile può essere utilizzata per controllare il path di root in cui sono installati i progetti, la :variable:`CPACK_PACKAGING_INSTALL_PREFIX`. Per default molti dei generatori installano nella directory /usr. Tale variabile può essere utilizzata per cambiarla in qualsiasi directory, incluso solo /."

#: ../../source/chapter/Packaging CPack.rst:414 With
msgid "CPack and other installed directories"
msgstr "CPack e altre directory installate"

#: ../../source/chapter/Packaging CPack.rst:416 With
msgid ""
"It is possible to run other install rules if the project is not CMake "
"based. This can be done by using the variables "
":variable:`CPACK_INSTALL_COMMANDS`, and "
":variable:`CPACK_INSTALLED_DIRECTORIES`. "
":variable:`CPACK_INSTALL_COMMANDS` are commands that will be run during "
"the installation phase of the packaging. "
":variable:`CPACK_INSTALLED_DIRECTORIES` should contain pairs of directory"
" and subdirectory. The subdirectory can be '.' to be installed in the "
"top-level directory of the installation. The files in each directory will"
" be copied to the corresponding subdirectory of the CPack staging "
"directory and packaged with the rest of the files."
msgstr "È possibile eseguire altre regole di installazione se il progetto non è basato su CMake. Questo può essere fatto usando le variabili :variable:`CPACK_INSTALL_COMMANDS` e :variable:`CPACK_INSTALLED_DIRECTORIES`. :variable:`CPACK_INSTALL_COMMANDS` sono comandi che verranno eseguiti durante la fase di installazione del pacchetto. :variable:`CPACK_INSTALLED_DIRECTORIES` dovrebbe contenere coppie di directory e sottodirectory. La sottodirectory può essere '.' da installare nella directory di primo livello dell'installazione. I file in ciascuna directory verranno copiati nella sottodirectory corrispondente della directory di staging di CPack e impacchettati con il resto dei file."

#: ../../source/chapter/Packaging CPack.rst:431 With
msgid "CPack for Windows Installer NSIS"
msgstr "CPack per Windows Installer NSIS"

#: ../../source/chapter/Packaging CPack.rst:433 With
msgid ""
"To create Windows style wizard based installer programs, CPack uses NSIS "
"(NullSoft Scriptable Install System). More information about NSIS can be "
"found at the NSIS home page: http://nsis.sourceforge.net/ NSIS is a "
"powerful tool with a scripting language used to create professional "
"Windows installers. To create Windows installers with CPack, you will "
"need NSIS installed on your machine."
msgstr "Per creare programmi di installazione basati su procedure guidate in stile Windows, CPack utilizza NSIS (NullSoft Scriptable Install System). Ulteriori informazioni su NSIS sono disponibili nella home page di NSIS: http://nsis.sourceforge.net/ NSIS è un potente strumento con un linguaggio di scripting utilizzato per creare programmi di installazione professionali di Windows. Per creare programmi di installazione di Windows con CPack, c'è bisogno che NSIS sia installato sul computer."

#: ../../source/chapter/Packaging CPack.rst:440 With
msgid ""
"CPack uses configured template files to control NSIS. There are two files"
" configured by CPack during the creation of a NSIS installer. Both files "
"are found in the CMake Modules directory. ``Modules/NSIS.template.in`` is"
" the template for the NSIS script, and "
"``Modules/NSIS.InstallOptions.ini.in`` is the template for the modern "
"user interface or MUI used by NSIS. The install options file contains the"
" information about the pages used in the install wizard. This section "
"will describe how to configure CPack to create an NSIS install wizard."
msgstr "CPack utilizza file template configurati per controllare NSIS. Ci sono due file configurati da CPack durante la creazione di un programma di installazione NSIS. Entrambi i file si trovano nella directory Modules di CMake. ``Modules/NSIS.template.in`` è il template per lo script NSIS e ``Modules/NSIS.InstallOptions.ini.in`` è il template per la moderna interfaccia utente o MUI utilizzata da NSIS. Il file delle opzioni di installazione contiene le informazioni sulle pagine utilizzate nella procedura guidata (wizard) di installazione. Questa sezione descriverà come configurare CPack per creare una procedura guidata di installazione NSIS."

#: ../../source/chapter/Packaging CPack.rst:451 With
msgid "CPack Variables Used by CMake for NSIS"
msgstr "Variabili CPack Usate da CMake per NSIS"

#: ../../source/chapter/Packaging CPack.rst:453 With
msgid ""
"This section contains screen captures from the CMake NSIS install wizard."
" For each part of the installer that can be changed or controlled from "
"CPack, the variables and values used are given."
msgstr "Questa sezione contiene schermate acquisite dalla procedura guidata di installazione di CMake NSIS. Per ogni parte dell'installer modificabile o controllabile da CPack, vengono fornite le variabili e i valori utilizzati."

#: ../../source/chapter/Packaging CPack.rst:457 With
msgid ""
"The first thing that a user will see of the installer in Windows is the "
"icon for the installer executable itself. By default the installer will "
"have the Null Soft Installer icon, as seen in Figure :num:`figure-"
"IconforinstallerinWindowsExplorer` for the 20071023 CMake installer. This"
" icon can be changed by setting the variable ``CPACK_NSIS_MUI_ICON``. The"
" installer for 20071025 in the same figure shows the CMake icon being "
"used for the installer."
msgstr "La prima cosa che un utente vedrà del programma di installazione in Windows è l'icona dell'eseguibile del programma di installazione stesso. Per default l'installer avrà l'icona Null Soft Installer, come mostrato nella Figura :num:`figure-IconforinstallerinWindowsExplorer` per il programma di installazione CMake 20071023. Questa icona può essere modificata impostando la variabile ``CPACK_NSIS_MUI_ICON``. L'installer per 20071025 nella stessa figura mostra l'icona CMake utilizzata per l'installer.staller."

#: ../../source/chapter/Packaging CPack.rst:469 With
msgid "Icon for installer in Windows Explorer"
msgstr "Icona per l'installer in Windows Explorer"

#: ../../source/chapter/Packaging CPack.rst:471 With
msgid ""
"The last thing a users will see of the installer in Windows is the icon "
"for the uninstall executable, as seen in Figure :num:`figure-"
"UninstallIconforNSISinstaller`.  This option can be set with the "
"``CPACK_NSIS_MUI_UNIICON`` variable. Both the install and uninstall icons"
" must be the same size and format, a valid windows .ico file usable by "
"Windows Explorer. The icons are set like this::"
msgstr "L'ultima cosa che gli utenti vedranno del programma di installazione in Windows è l'icona dell'eseguibile di disinstallazione, come mostrato in Figura :num:`figure-UninstallIconforNSISinstaller`.  Questa opzione può essere impostata con la variabile ``CPACK_NSIS_MUI_UNIICON``. Entrambe le icone di installazione e disinstallazione devono avere le stesse dimensioni e lo stesso formato, un file Windows .ico valido utilizzabile da Windows Explorer. Le icone vengono impostate in questo modo::"

#: ../../source/chapter/Packaging CPack.rst:488 With
msgid "Uninstall Icon for NSIS installer"
msgstr "Icona Uninstall per l'installer NSIS"

#: ../../source/chapter/Packaging CPack.rst:490 With
msgid ""
"On Windows, programs can also be removed using the Add or Remove Programs"
" tool from the control panel as seen in Figure :num:`figure-"
"AddorRemoveProgramsEntry`. The icon for this should be embedded in one of"
" the installed executables. This can be set like this:"
msgstr "Su Windows, i programmi possono anche essere rimossi utilizzando il tool \"Add or Remove Programs\"  (Aggiungi o rimuovi programmi) dal pannello di controllo, come mostrato in Figura :num:`figure-AddorRemoveProgramsEntry`. L'icona per questo dovrebbe essere inclusa in uno degli eseguibili installati. Questo può essere impostato in questo modo:"

#: ../../source/chapter/Packaging CPack.rst:505 With
msgid "Add or Remove Programs Entry"
msgstr "La Voce \"Add or Remove Programs\""

#: ../../source/chapter/Packaging CPack.rst:511 With
msgid "First Screen of Install Wizard"
msgstr "Prima Schermata dell'Installazione Guidata"

#: ../../source/chapter/Packaging CPack.rst:513 With
msgid ""
"When running the installer, the first screen of the wizard will look like"
" Figure :num:`figure-FirstScreenofInstallWizard`. In this screen you can "
"control the name of the project that shows up in two places on the "
"screen. The name used for the project is controlled by the variable "
":variable:`CPACK_PACKAGE_INSTALL_DIRECTORY` or "
":variable:`CPACK_NSIS_PACKAGE_NAME`. In this example, it was set to "
"\"CMake 2.5\" like this:"
msgstr "Quando si esegue il programma di installazione, la prima schermata della procedura guidata sarà simile alla Figura :num:`figure-FirstScreenofInstallWizard`. In questa schermata si può controllare il nome del progetto che appare in due punti sullo schermo. Il nome utilizzato per il progetto è controllato dalla variabile :variable:`CPACK_PACKAGE_INSTALL_DIRECTORY` o da :variable:`CPACK_NSIS_PACKAGE_NAME`. In questo esempio, è stato impostato su \"CMake 2.5\" in questo modo:"

#: ../../source/chapter/Packaging CPack.rst:526 With
msgid "or this:"
msgstr "o in questo:"

#: ../../source/chapter/Packaging CPack.rst:537 With
msgid "Second Screen of Install Wizard"
msgstr "Seconda Schermata dell'Installazione Guidata"

#: ../../source/chapter/Packaging CPack.rst:539 With
msgid ""
"The second page of the install wizard can be seen in Figure :num:`figure-"
"SecondScreenofInstallWizard`. This screen contains the license agreement "
"and there are several things that can be configured on this page. The "
"banner bitmap to the left of the \"License Agreement\" label is "
"controlled by the variable ``CPACK_PACKAGE_ICON`` like this:"
msgstr "La seconda pagina della procedura guidata di installazione può essere visualizzata in Figura :num:`figure-SecondScreenofInstallWizard`. Questa schermata contiene il contratto di licenza e ci sono diverse cose che possono essere configurate. La bitmap del banner a sinistra dell'etichetta \"License Agreement\" (Contratto di licenza) è controllata dalla variabile ``CPACK_PACKAGE_ICON`` in questo modo:"

#: ../../source/chapter/Packaging CPack.rst:550 With
msgid ""
":variable:`CPACK_PACKAGE_INSTALL_DIRECTORY` is used again on this page "
"everywhere you see the text \"CMake 2.5\". The text of the license "
"agreement is set to the contents of the file specified in the "
":variable:`CPACK_RESOURCE_FILE_LICENSE` variable. CMake does the "
"following:"
msgstr ":variable:`CPACK_PACKAGE_INSTALL_DIRECTORY` viene nuovamente utilizzata in questa pagina ovunque si veda il testo \"CMake 2.5\". Il testo del contratto di licenza è impostato sul contenuto del file specificato nella variabile :variable:`CPACK_RESOURCE_FILE_LICENSE` variable. CMake fa quanto segue:"

#: ../../source/chapter/Packaging CPack.rst:565 With
msgid "Third page of installer wizard"
msgstr "Terza pagina della procedura guidata di installazione"

#: ../../source/chapter/Packaging CPack.rst:567 With
msgid ""
"The third page of the installer can be seen in Figure :num:`figure-"
"Thirdpageofinstallerwizard`. This page will only show up if "
":variable:`CPACK_NSIS_MODIFY_PATH` is set to on. If you check the Create "
"\"name\" Desktop Icon button, and you put executable names in the "
"variable :variable:`CPACK_CREATE_DESKTOP_LINKS`, then a desktop icon for "
"those executables will be created. For example, to create a desktop icon "
"for the cmake-gui program of CMake, the following is done:"
msgstr "La terza pagina del programma di installazione è visibile nella Figura :num:`figure-Thirdpageofinstallerwizard`. Questa pagina verrà visualizzata solo se :variable:`CPACK_NSIS_MODIFY_PATH` è impostata su on. Se si seleziona il pulsante Create \"name\" Desktop Icon e si inseriscono i nomi degli eseguibili nella variabile :variable:`CPACK_CREATE_DESKTOP_LINKS`, verrà creata un'icona sul desktop per quegli eseguibili. Ad esempio, per creare un'icona sul desktop per il programma cmake-gui di CMake, si esegue quanto segue:"

#: ../../source/chapter/Packaging CPack.rst:579 With
msgid ""
"Multiple desktop links can be created if your application contains more "
"than one executable. The link will be created to the Start Menu entry, so"
" :variable:`CPACK_PACKAGE_EXECUTABLES`, which is described later in this "
"section, must also contain the application in order for a desktop link to"
" be created."
msgstr "È possibile creare più collegamenti sul desktop se l'applicazione contiene più di un eseguibile. Il collegamento verrà creato alla voce del menù Start, quindi :variable:`CPACK_PACKAGE_EXECUTABLES`, descritto più avanti in questa sezione, deve contenere anche l'applicazione per poter creare un collegamento sul desktop."

#: ../../source/chapter/Packaging CPack.rst:589 With
msgid "Fourth page of installer wizard"
msgstr "Quarta pagina della procedura guidata di installazione"

#: ../../source/chapter/Packaging CPack.rst:591 With
msgid ""
"The fourth page of the installer seen in Figure :num:`figure-"
"Fourthpageofinstallerwizard` uses the variable "
":variable:`CPACK_PACKAGE_INSTALL_DIRECTORY` to specify the default "
"destination folder in Program Files. The following CMake code was used to"
" set that default:"
msgstr "La quarta pagina del programma di installazione visualizzata in Figura :num:`figure-Fourthpageofinstallerwizard` utilizza la variabile :variable:`CPACK_PACKAGE_INSTALL_DIRECTORY` per specificare la cartella di destinazione di default in Program Files. Il seguente codice CMake è stato utilizzato per impostare tale default:"

#: ../../source/chapter/Packaging CPack.rst:602 With
msgid ""
"The remaining pages of the installer wizard do not use any additional "
"CPack variables, and are not included in this section. Another important "
"option that can be set by the NSIS CPack generator is the registry key "
"used. There are several CPack variables that control the default key "
"used. The key is defined in the NSIS.template.in file as follows::"
msgstr "Le restanti pagine della procedura guidata di installazione non utilizzano variabili CPack aggiuntive e non sono incluse in questa sezione. Un'altra opzione importante che può essere impostata dal generatore NSIS CPack è la chiave di registro utilizzata. Esistono diverse variabili CPack che controllano la chiave di default utilizzata. La chiave è definita nel file NSIS.template.in questo modo::"

#: ../../source/chapter/Packaging CPack.rst:612 With
msgid ""
"Where the ``CPACK_PACKAGE_VENDOR`` value defaults to Humanity, and "
"``CPACK_PACKAGE_INSTALL_REGISTRY_KEY`` defaults to "
"``${CPACK_PACKAGE_NAME} ${CPACK_PACKAGE_VERSION}``"
msgstr "Dove il default di ``CPACK_PACKAGE_VENDOR`` è Humanity e quello di ``CPACK_PACKAGE_INSTALL_REGISTRY_KEY`` è ``${CPACK_PACKAGE_NAME} ${CPACK_PACKAGE_VERSION}``"

#: ../../source/chapter/Packaging CPack.rst:616 With
msgid "So for CMake 2.5.20071025 the registry key would look like this::"
msgstr "Quindi per CMake 2.5.20071025 la chiave di registro sarebbe simile a questa::"

#: ../../source/chapter/Packaging CPack.rst:621 With
msgid "Creating Windows Short Cuts in the Start Menu"
msgstr "Creazione di scorciatoie di Windows nel Menù Start"

#: ../../source/chapter/Packaging CPack.rst:623 With
msgid ""
"There are two variables that control the short cuts that are created in "
"the Windows Start menu by NSIS. The variables contain lists of pairs, and"
" must have an even number of elements to work correctly. The first is "
"``CPACK_PACKAGE_EXECUTABLES``, it should contain the name of the "
"executable file followed by the name of the shortcut text. For example in"
" the case of CMake, the executable is called cmake-gui, but the shortcut "
"is named \"CMake\". CMake does the following to create that shortcut:"
msgstr "Esistono due variabili che controllano le scorciatoie create nel menù Start di Windows da NSIS. Le variabili contengono elenchi di coppie e devono avere un numero pari di elementi per funzionare correttamente. Il primo è ``CPACK_PACKAGE_EXECUTABLES``, dovrebbe contenere il nome del file eseguibile seguito dal nome del testo del collegamento. Ad esempio, nel caso di CMake, l'eseguibile si chiama cmake-gui, ma il collegamento si chiama \"CMake\". CMake fa quanto segue per creare quel collegamento:"

#: ../../source/chapter/Packaging CPack.rst:636 With
msgid ""
"The second is ``CPACK_NSIS_MENU_LINKS``. This variable contains arbitrary"
" links into the install tree, or to external web pages. The first of the "
"pair is always the existing source file or location, and the second is "
"the name that will show up in the Start menu. To add a link to the help "
"file for cmake-gui and a link to the CMake web page add the following:"
msgstr "Il secondo è ``CPACK_NSIS_MENU_LINKS``. Questa variabile contiene collegamenti arbitrari all'albero di installazione o a pagine web esterne. Il primo della coppia è sempre il file o la posizione di origine esistente e il secondo è il nome che verrà visualizzato nel menù Start. Per aggiungere un collegamento al file della guida per cmake-gui e un collegamento alla pagina Web di CMake, aggiungere quanto segue:"

#: ../../source/chapter/Packaging CPack.rst:650 With
msgid "Advanced NSIS CPack Options"
msgstr "Opzioni Avanzate di NSIS CPack"

#: ../../source/chapter/Packaging CPack.rst:652 With
msgid ""
"In addition to the variables already discussed, CPack provides a few "
"additional variables that are directly configured into the NSIS script "
"file. These can be used to add NSIS script fragments to the final NSIS "
"script used to create the installer. They are as follows:"
msgstr "Oltre alle variabili già discusse, CPack fornisce alcune variabili aggiuntive configurate direttamente nel file di script NSIS. Queste sono utilizzabili per aggiungere frammenti di script NSIS allo script NSIS finale utilizzato per creare il programma di installazione. Sono le seguenti:"

#: ../../source/chapter/Packaging CPack.rst:658 With
msgid "**CPACK_NSIS_EXTRA_INSTALL_COMMANDS**"
msgstr "**CPACK_NSIS_EXTRA_INSTALL_COMMANDS**"

#: ../../source/chapter/Packaging CPack.rst:658 With
msgid "Extra commands used during install."
msgstr "Comandi aggiuntivi utilizzati durante l'installazione."

#: ../../source/chapter/Packaging CPack.rst:661 With
msgid "**CPACK_NSIS_EXTRA_UNINSTALL_COMMANDS**"
msgstr "**CPACK_NSIS_EXTRA_UNINSTALL_COMMANDS**"

#: ../../source/chapter/Packaging CPack.rst:661 With
msgid "Extra commands used during uninstall."
msgstr "Comandi aggiuntivi utilizzati durante la disinstallazione."

#: ../../source/chapter/Packaging CPack.rst:664 With
msgid "**CPACK_NSIS_CREATE_ICONS_EXTRA**"
msgstr "**CPACK_NSIS_CREATE_ICONS_EXTRA**"

#: ../../source/chapter/Packaging CPack.rst:664 With
msgid "Extra NSIS commands in the icon section of the script."
msgstr "Comandi NSIS aggiuntivi nella sezione delle icone dello script."

#: ../../source/chapter/Packaging CPack.rst:667 With
msgid "**CPACK_NSIS_DELETE_ICONS_EXTRA**"
msgstr "**CPACK_NSIS_DELETE_ICONS_EXTRA**"

#: ../../source/chapter/Packaging CPack.rst:667 With
msgid "Extra NSIS commands in the delete icons section of the script."
msgstr "Comandi NSIS aggiuntivi nella sezione di cancellazione delle icone dello script."

#: ../../source/chapter/Packaging CPack.rst:669 With
msgid ""
"When using these variables the NSIS documentation should be referenced, "
"and the author should look at the ``NSIS.template.in`` file for the exact"
" placement of the variables."
msgstr "Quando si usano queste variabili si dovrebbe fare riferimento alla documentazione NSIS e l'autore dovrebbe guardare il file ``NSIS.template.in`` per l'esatto posizionamento delle variabili."

#: ../../source/chapter/Packaging CPack.rst:674 With
msgid "Setting File Extension Associations With NSIS"
msgstr "Impostazioni delle Associazioni delle Estensioni dei File Con NSIS"

#: ../../source/chapter/Packaging CPack.rst:676 With
msgid ""
"One example of a useful thing that can be done with the extra install "
"commands is to create associations from file extensions to the installed "
"application. For example, if you had an application CoolStuff that could "
"open files with the extension ``.cool``, you would set the following "
"extra install and uninstall commands:"
msgstr "Un esempio di una cosa utile che può essere fatta con i comandi di installazione extra è creare associazioni dalle estensioni di file all'applicazione installata. Ad esempio, avendo un'applicazione CoolStuff in grado di aprire file con estensione ``.cool``, si devono impostare i seguenti comandi aggiuntivi di installazione e disinstallazione:"

#: ../../source/chapter/Packaging CPack.rst:705 With
msgid ""
"This creates a Windows file association to all files ending in ``.cool``,"
" so that when a user double clicks on a ``.cool`` file, ``coolstuff.exe``"
" is run with the full path to the file as an argument. This also sets up "
"an association for editing the file from the windows right-click menu to "
"the same ``coolstuff.exe`` program. The Windows explorer icon for the "
"file is set to the icon found in the ``coolstuff.exe`` executable. When "
"it is uninstalled, the registry keys are removed. Since the double quotes"
" and Windows path separators must be escaped, it is best to put this code"
" into the ``CPACK_PROJECT_CONFIG_FILE`` for the project."
msgstr "Questo crea un'associazione di file Windows a tutti i file che terminano con ``.cool``, in modo che quando un utente fa doppio clic su un file ``.cool``, ``coolstuff.exe`` viene eseguito con il path completo del file come argomento. Questo imposta anche un'associazione per modificare il file dal menù di scelta rapida di Windows allo stesso programma ``coolstuff.exe``. L'icona di Windows Explorer per il file è impostata sull'icona trovata nell'eseguibile ``coolstuff.exe``. Quando viene disinstallato, le chiavi di registro vengono rimosse. Poiché le virgolette doppie e i separatori di path di Windows devono essere 'escaped', è meglio inserire questo codice in ``CPACK_PROJECT_CONFIG_FILE`` per il progetto."

#: ../../source/chapter/Packaging CPack.rst:731 With
msgid "Installing Microsoft Run Time Libraries"
msgstr "Installazione delle Microsoft Run Time Libraries"

#: ../../source/chapter/Packaging CPack.rst:733 With
msgid ""
"Although not strictly an NSIS CPack command, if you are creating "
"applications on Windows with the Microsoft compiler you will most likely "
"want to distribute the run time libraries from Microsoft alongside your "
"project. In CMake, all you need to do is the following:"
msgstr "Sebbene non sia strettamente un comando NSIS CPack, se si creano applicazioni su Windows con il compilatore Microsoft, molto probabilmente si dovranno distribuire le librerie di runtime da Microsoft insieme al progetto. In CMake, tutto ciò che si deve fare è quanto segue:"

#: ../../source/chapter/Packaging CPack.rst:743 With
msgid ""
"This will add the compiler run time libraries as install files that will "
"go into the bin directory of your application. If you do not want the "
"libraries to go into the bin directory, you would do this:"
msgstr "Questo aggiungerà le librerie di runtime del compilatore come file di installazione che andranno nella directory bin dell'applicazione. Se non si vuole che le librerie vadano nella directory bin, si deve fare questo:"

#: ../../source/chapter/Packaging CPack.rst:754 With
msgid ""
"It is important to note that the run time libraries must be right next to"
" the executables of your package in order for Windows to find them. With "
"Visual Studio 2005 and 2008, side by side manifest files are also "
"required to be installed with your application when distributing the run "
"time libraries. If you want to package a debug version of your software "
"you will need to set ``CMAKE_INSTALL_DEBUG_LIBRARIES`` to ON prior to the"
" include. Be aware, however, that the license terms may prohibit you from"
" re-distributing the debug libraries. Double check the licensing terms "
"for the version of Visual Studio you're using before deciding to set "
"``CMAKE_INSTALL_DEBUG_LIBRARIES`` to ON."
msgstr "È importante notare che le librerie di runtime devono trovarsi proprio accanto agli eseguibili del pacchetto affinché Windows possa trovarle. Con Visual Studio 2005 e 2008, è necessario installare anche i file manifest affiancati con l'applicazione durante la distribuzione delle librerie di runtime. Volendo impacchettare una versione di debug del software, si dovrà impostare ``CMAKE_INSTALL_DEBUG_LIBRARIES`` su ON prima dell'inclusione. Da tenere presente, tuttavia, che i termini della licenza potrebbero proibire di ridistribuire le librerie di debug. Ricontrollare i termini di licenza per la versione di Visual Studio utilizzata prima di decidere di impostare ``CMAKE_INSTALL_DEBUG_LIBRARIES`` su ON. ON."

#: ../../source/chapter/Packaging CPack.rst:770 With
msgid "CPack Component Install Support"
msgstr "Supporto per l'Installazione dei Componenti CPack"

#: ../../source/chapter/Packaging CPack.rst:772 With
msgid ""
"By default, CPack's installers consider all of the files installed by a "
"project as a single, monolithic unit: either the whole set of files is "
"installed, or none of the files are installed. However, with many "
"projects it makes sense for the installation to be subdivided into "
"distinct, user-selectable components. Some users may want to install only"
" the command-line tools for a project, while other users might want the "
"GUI or the header files."
msgstr "Per default, i programmi di installazione di CPack considerano tutti i file installati da un progetto come una singola unità monolitica: o viene installato l'intero set di file o non viene installato alcun file. Tuttavia, con molti progetti ha senso suddividere l'installazione in componenti distinti e selezionabili dall'utente. Alcuni utenti potrebbero voler installare solo i tool a riga di comando per un progetto, mentre altri utenti potrebbero desiderare la GUI o i file header."

#: ../../source/chapter/Packaging CPack.rst:780 With
msgid ""
"This section describes how to configure CPack to generate component-based"
" installers that allow users to select the set of project components that"
" they wish to install. As an example, a simple installer will be created "
"for a library that has three components: a library binary, a sample "
"application, and a C++ header file. When finished the resulting "
"installers for Windows and Mac OS X look like the ones in Figure :num"
":`figure-MacandWindowsComponentInstallers`."
msgstr "Questa sezione descrive come configurare CPack per generare programmi di installazione basati su componenti che consentano agli utenti di selezionare il set di componenti del progetto che desiderano installare. Ad esempio, verrà creato un semplice programma di installazione per una libreria che ha tre componenti: un binario di libreria, un'applicazione di esempio e un file header C++. Al termine, i programmi di installazione risultanti per Windows e Mac OS X sono simili a quelli in Figura :num:`figure-MacandWindowsComponentInstallers`."

#: ../../source/chapter/Packaging CPack.rst:792 With
msgid "Mac and Windows Component Installers"
msgstr "Installer di componenti per Mac e Windows"

#: ../../source/chapter/Packaging CPack.rst:794 With
msgid ""
"The simple example we will be working with is as follows; it has a "
"library and an executable. CPack commands that have already been covered "
"are used."
msgstr "Il semplice esempio con cui lavoreremo è il seguente; ha una libreria e un eseguibile. Vengono utilizzati i comandi CPack già trattati."

#: ../../source/chapter/Packaging CPack.rst:826 With
msgid "Specifying Components"
msgstr "Specifica dei Componenti"

#: ../../source/chapter/Packaging CPack.rst:828 With
msgid ""
"The first step in building a component-based installation is to identify "
"the set of installable components. In this example, three components will"
" be created: the library binary, the application, and the header file. "
"This decision is arbitrary and project-specific, but be sure to identify "
"the components that correspond to units of functionality important to "
"your user, rather than basing the components on the internal structure of"
" your program."
msgstr "Il primo passo nella creazione di un'installazione basata su componenti consiste nell'identificare l'insieme di componenti installabili. In questo esempio verranno creati tre componenti: il file binario della libreria, l'applicazione e il file header. Questa decisione è arbitraria e specifica del progetto, ma si devono identificare i componenti che corrispondono alle unità di funzionalità importanti per l'utente, piuttosto che basare i componenti sulla struttura interna del programma."

#: ../../source/chapter/Packaging CPack.rst:836 With
msgid ""
"For each of these components, we need to identify which component each of"
" the installed files belong in. For each :command:`install` command in "
"CMakeLists.txt, add an appropriate ``COMPONENT`` argument stating which "
"component the installed files will be associated with:"
msgstr "Per ciascuno di questi componenti, dobbiamo identificare a quale componente appartiene ciascuno dei file installati. Per ogni comando :command:`install` in CMakeLists.txt, si aggiunge un argomento ``COMPONENT`` appropriato che indichi a quale componente saranno associati i file installati:"

#: ../../source/chapter/Packaging CPack.rst:855 With
msgid ""
"Note that the ``COMPONENT`` argument to the :command:`install` command is"
" not new; it has been a part of CMake's :command:`install` are using any "
"of the older installation commands (:command:`install_targets`, "
":command:`install_files`, etc.), you will need to convert them to "
":command:`install` commands in order to use components."
msgstr "Si noti che l'argomento ``COMPONENT`` del comando :command:`install` non è nuovo; ha fatto parte di CMake :command:`install` utilizza uno qualsiasi dei comandi di installazione precedenti (:command:`install_targets`, :command:`install_files`, ecc.), si dovranno convertirli in comandi :command:`install` per poter utilizzare i componenti."

#: ../../source/chapter/Packaging CPack.rst:861 With
msgid ""
"The next step is to notify CPack of the names of all of the components in"
" your project by calling the ``cpack_add_component`` function for each "
"component of the package:"
msgstr "Il passo successivo consiste nel notificare a CPack i nomi di tutti i componenti del progetto chiamando la funzione ``cpack_add_component`` per ciascun componente del pacchetto:"

#: ../../source/chapter/Packaging CPack.rst:871 With
msgid ""
"At this point you can build a component-based installer with CPack that "
"will allow one to independently install the applications, libraries, and "
"headers of MyLib. The Windows and Mac OS X installers will look like the "
"ones shown in Figure :num:`figure-"
"WindowsandMacOSXComponentInstallerFirstPage`."
msgstr "A questo punto si può creare un programma di installazione basato su componenti con CPack che consentirà di installare in modo indipendente le applicazioni, le librerie e gli header di MyLib. I programmi di installazione di Windows e Mac OS X saranno simili a quelli mostrati in Figura :num:`figure-WindowsandMacOSXComponentInstallerFirstPage`."

#: ../../source/chapter/Packaging CPack.rst:881 With
msgid "Windows and Mac OS X Component Installer First Page"
msgstr "Prima pagina del programma di installazione dei componenti di Windows e Mac OS X"

#: ../../source/chapter/Packaging CPack.rst:884 With
msgid "Naming Components"
msgstr "Denominazione dei Componenti"

#: ../../source/chapter/Packaging CPack.rst:886 With
msgid ""
"At this point, you may have noted that the names of the actual components"
" in the installer are not very descriptive: they just say "
"\"applications,\" \"libraries,\" or \"headers,\" as specified in the "
"component names. These names can be improved by using the DISPLAY_NAME "
"option in the ``cpack_add_component function``:"
msgstr "A questo punto, si può notare che i nomi dei componenti effettivi nel programma di installazione non sono molto descrittivi: dicono semplicemente \"applicazioni\", \"librerie\" o \"header\", come specificato nei nomi dei componenti. Questi nomi possono essere migliorati utilizzando l'opzione DISPLAY_NAME in ``cpack_add_component function``:"

#: ../../source/chapter/Packaging CPack.rst:899 With
msgid ""
"Any macro prefixed with ``CPACK_COMPONENT_${COMPNAME}``, where "
"``${COMPNAME}`` is the uppercase name of a component, is used to set a "
"particular property of that component in the installer. Here, we set the "
"``DISPLAY_NAME`` property of each of our components so that we get human-"
"readable names. These names will be listed in the selection box rather "
"than the internal component names \"applications,\" \"libraries,\" "
"\"headers,\""
msgstr "Qualsiasi macro con prefisso ``CPACK_COMPONENT_${COMPNAME}``, dove ``${COMPNAME}`` è il nome maiuscolo di un componente, è utilizzato per impostare una particolare proprietà di quel componente nel programma di installazione. Qui, impostiamo la proprietà ``DISPLAY_NAME`` di ciascuno dei nostri componenti in modo da ottenere nomi leggibili. Questi nomi verranno elencati nella casella di selezione anziché i nomi dei componenti interni \"applications\", \"libraries\", \"headers\","

#: ../../source/chapter/Packaging CPack.rst:911 With
msgid "Windows and Mac OS X Installers with named components"
msgstr "Programmi di installazione per Windows e Mac OS X con i nomi dei componenti"

#: ../../source/chapter/Packaging CPack.rst:914 With
msgid "Adding Component Descriptions"
msgstr "Aggiungere le Descrizioni dei Componenti"

#: ../../source/chapter/Packaging CPack.rst:916 With
msgid ""
"There are several other properties associated with components, including "
"the ability to make a component hidden, required, or disabled by default,"
" that provide additional descriptive information. Of particular note is "
"the ``DESCRIPTION`` property, which provides some descriptive text for "
"the component. This descriptive text will show up in a separate "
"\"description\" box in the installer, and will be updated either when the"
" user's mouse hovers over the name of the corresponding component "
"(Windows), or when the user clicks on a component (Mac OS X). We will add"
" a description for each of our components below:"
msgstr "Esistono diverse altre proprietà associate ai componenti, inclusa la possibilità di rendere un componente nascosto, richiesto o disabilitato per default, che forniscono ulteriori informazioni descrittive. Di particolare rilievo è la proprietà ``DESCRIPTION``, che fornisce del testo descrittivo per il componente. Questo testo descrittivo verrà visualizzato in una casella \"description\" separata nel programma di installazione e verrà aggiornato quando il mouse dell'utente passa sopra il nome del componente corrispondente (Windows) o quando l'utente fa clic su un componente (Mac OS X ). Di seguito aggiungeremo una descrizione per ciascuno dei nostri componenti:"

#: ../../source/chapter/Packaging CPack.rst:941 With
msgid ""
"Generally, descriptions should provide enough information for the user to"
" make a decision on whether to install the component, but should not "
"themselves be more than a few lines long (the \"Description\" box in the "
"installers tends to be small). Figure :num:`figure-"
"ComponentInstallerswithdescriptions` shows the description display for "
"both the Windows and Mac OS X installers."
msgstr "Generalmente, le descrizioni dovrebbero fornire all'utente informazioni sufficienti per decidere se installare il componente, ma non dovrebbero esse stesse essere più lunghe di qualche riga (la casella \"Descrizione\" nei programmi di installazione tende ad essere piccola). La Figura :num:`figure-ComponentInstallerswithdescriptions` mostra la visualizzazione della descrizione per i programmi di installazione di Windows e Mac OS X."

#: ../../source/chapter/Packaging CPack.rst:952 With
msgid "Component Installers with descriptions"
msgstr "Installer di componenti con descrizioni"

#: ../../source/chapter/Packaging CPack.rst:955 With
msgid "Component Interdependencies"
msgstr "Interdipendenze dei Componenti"

#: ../../source/chapter/Packaging CPack.rst:957 With
msgid ""
"With most projects the various components are not completely independent."
" For example, an application component may depend on the shared libraries"
" in another component to execute properly, such that installing the "
"application component without the corresponding shared libraries would "
"result in an unusable installation. CPack allows you to express the "
"dependencies between components, so that a component will only be "
"installed if all of the other components it depends on are also "
"installed."
msgstr "Nella maggior parte dei progetti i vari componenti non sono completamente indipendenti. Ad esempio, un componente dell'applicazione può dipendere dalle librerie shared in un altro componente per essere eseguito correttamente, in modo tale che l'installazione del componente dell'applicazione senza le corrispondenti librerie condivise risulterebbe in un'installazione inutilizzabile. CPack consente di esprimere le dipendenze tra i componenti, in modo che un componente venga installato solo se sono installati anche tutti gli altri componenti da cui dipende."

#: ../../source/chapter/Packaging CPack.rst:966 With
msgid ""
"To illustrate component dependencies we will place a simple restriction "
"on our component-based installer. Since we do not provide source code in "
"our installer, the C++ header files we distribute can only actually be "
"used if the user also installs the library binary to link their program "
"against. Thus, the \"headers\" component depends on the availability of "
"the \"libraries\" component. We can express this notion by setting the "
"``DEPENDS`` property for the ``HEADERS`` component as such:"
msgstr "Per illustrare le dipendenze dei componenti inseriremo una semplice restrizione sul nostro programma di installazione basato sui componenti. Poiché non forniamo il codice sorgente nel nostro programma di installazione, i file header C++ che distribuiamo possono essere effettivamente utilizzati solo se l'utente installa anche la libreria binaria per linkare il proprio programma. Pertanto, il componente \"headers\" dipende dalla disponibilità del componente \"libraries\". Possiamo esprimere questa nozione impostando la proprietà ``DEPENDS`` per il componente ``HEADERS`` come:"

#: ../../source/chapter/Packaging CPack.rst:983 With
msgid ""
"The ``DEPENDS`` property for a component is actually a list, as such a "
"component can depend on several other components. By expressing all of "
"the component dependencies in this manner you can ensure that users will "
"not be able to select an incomplete set of components at installation "
"time."
msgstr "La proprietà ``DEPENDS`` per un componente è in realtà un elenco, in quanto tale componente può dipendere da molti altri componenti. Esprimendo tutte le dipendenze dei componenti in questo modo, è possibile garantire che gli utenti non siano in grado di selezionare un insieme incompleto di componenti al momento dell'installazione."

#: ../../source/chapter/Packaging CPack.rst:990 With
msgid "Grouping Components"
msgstr "Raggruppamento di Componenti"

#: ../../source/chapter/Packaging CPack.rst:992 With
msgid ""
"When the number of components in your project grows large, you may need "
"to provide additional organization for the list of components. To help "
"with this organization, CPack includes the notion of component groups. A "
"component group is simply a way to provide a name for a group of related "
"components. Within the user interface a component group has its own name,"
" and underneath that group are the names of all of the components in that"
" group. Users will have the option to (de-)select the installation of all"
" components in the group with a single click, or expand the group to "
"select individual components."
msgstr "Quando il numero di componenti nel progetto aumenta, potrebbe essere necessario fornire un'organizzazione aggiuntiva per l'elenco dei componenti. Per aiutare con questa organizzazione, CPack include la nozione di gruppi di componenti. Un gruppo di componenti è semplicemente un modo per fornire un nome a un gruppo di componenti correlati. All'interno dell'interfaccia utente un gruppo di componenti ha il proprio nome e sotto quel gruppo ci sono i nomi di tutti i componenti in quel gruppo. Gli utenti avranno la possibilità di (de)selezionare l'installazione di tutti i componenti nel gruppo con un solo clic o di espandere il gruppo per selezionare singoli componenti."

#: ../../source/chapter/Packaging CPack.rst:1002 With
msgid ""
"We will expand our example by categorizing its three components, "
"\"applications,\" \"libraries,\" and \"headers,\" into \"Runtime\" and "
"\"Development\" groups. We can place a component into a group by using "
"the ``GROUP`` option to the ``cpack_add_component`` function as follows:"
msgstr "Amplieremo il nostro esempio categorizzando i suoi tre componenti, \"applications\", \"libraries\" e \"headers\", nei gruppi \"Runtime\" e \"Development\". Possiamo inserire un componente in un gruppo utilizzando l'opzione ``GROUP`` della funzione ``cpack_add_component`` come segue:"

#: ../../source/chapter/Packaging CPack.rst:1027 With
msgid ""
"Like components, component groups have various properties that can be "
"customized, including the ``DISPLAY_NAME`` and ``DESCRIPTION``. For "
"example, the following code adds an expanded description to the "
"\"Development\" group:"
msgstr "Come i componenti, i gruppi di componenti hanno varie proprietà che possono essere personalizzate, tra cui ``DISPLAY_NAME`` e ``DESCRIPTION``. Ad esempio, il codice seguente aggiunge una descrizione espansa al gruppo \"Development\":"

#: ../../source/chapter/Packaging CPack.rst:1039 With
msgid ""
"Once you have customized the component groups to your liking, rebuild the"
" binary installer to see the new organization: the MyLib application will"
" show up under the new \"Runtime\" group, while the MyLib library and C++"
" header will show up under the new \"Development\" group. One can easily "
"turn on/off all of the components within a group using the installer's "
"GUI. This can be seen in Figure :num:`figure-ComponentGrouping`."
msgstr "Dopo aver personalizzato i gruppi di componenti a proprio piacimento, ricostruire l'installer binario per vedere la nuova organizzazione: l'applicazione MyLib verrà visualizzata sotto il nuovo gruppo \"Runtime\", mentre la libreria MyLib e l'intestazione C++ verranno visualizzate sotto il nuovo gruppo \"Development\". È possibile attivare/disattivare facilmente tutti i componenti all'interno di un gruppo utilizzando la GUI dell'installatore. Questo può essere visto in Figura :num:`figure-ComponentGrouping`."

#: ../../source/chapter/Packaging CPack.rst:1051 With
msgid "Component Grouping"
msgstr "Raggruppamento dei componenti"

#: ../../source/chapter/Packaging CPack.rst:1054 With
msgid "Installation Types (NSIS Only)"
msgstr "Tipi di Installazione (solo NSIS)"

#: ../../source/chapter/Packaging CPack.rst:1056 With
msgid ""
"When a project contains a large number of components, it is common for a "
"Windows installer to provide pre-selected sets of components based on "
"specific user needs. For example, a user wanting to develop software "
"against a library will want one set of components, while an end user "
"might use an entirely different set. CPack supports this notion of pre-"
"selected component sets via installation types. An installation type is "
"simply a set of components. When the user selects an installation type, "
"exactly that set of components is selected. Then the user is permitted to"
" further customize their installation as desired. Currently this is only "
"supported by the NSIS generator."
msgstr "Quando un progetto contiene un numero elevato di componenti, è normale che un programma di installazione di Windows fornisca set di componenti preselezionati in base alle esigenze specifiche dell'utente. Ad esempio, un utente che desidera sviluppare software per una libreria vorrà un set di componenti, mentre un utente finale potrebbe utilizzare un set completamente diverso. CPack supporta questa nozione di set di componenti preselezionati tramite i tipi di installazione. Un tipo di installazione è semplicemente un insieme di componenti. Quando l'utente seleziona un tipo di installazione, viene selezionato esattamente quel set di componenti. Quindi l'utente può personalizzare ulteriormente la propria installazione come desiderato. Attualmente questo è supportato solo dal generatore NSIS."

#: ../../source/chapter/Packaging CPack.rst:1067 With
msgid ""
"For our simple example, we will create two installation types: a \"Full\""
" installation type that contains all of the components, and a "
"\"Developer\" installation type that includes only the libraries and "
"headers. To do this we use the function ``cpack_add_install_type`` to add"
" the types."
msgstr "Per il nostro semplice esempio, creeremo due tipi di installazione: un tipo di installazione \"Full\" che contiene tutti i componenti e un tipo di installazione \"Developer\" che include solo le librerie e gli header. Per fare questo usiamo la funzione ``cpack_add_install_type`` per aggiungere i tipi."

#: ../../source/chapter/Packaging CPack.rst:1078 With
msgid ""
"Next, we set the ``INSTALL_TYPES`` property of each component to state "
"which installation types will include that component. This is done with "
"the INSTALL_TYPES option to the ``cpack_add_component`` function."
msgstr "Successivamente, impostiamo la proprietà ``INSTALL_TYPES`` di ogni componente per indicare quali tipi di installazione includeranno quel componente. Questo viene fatto con l'opzione INSTALL_TYPES della funzione ``cpack_add_component``."

#: ../../source/chapter/Packaging CPack.rst:1102 With
msgid ""
"Components can be listed under any number of installation types. If you "
"rebuild the Windows installer, the components page will contain a combo "
"box that allows you to select the installation type, and therefore its "
"corresponding set of components as shown in Figure :num:`figure-"
"NSISInstallationTypes`."
msgstr "I componenti possono essere elencati in qualsiasi numero di tipi di installazione. Se si re-builda il programma di installazione di Windows, la pagina dei componenti conterrà una \"combo box\" che consente di selezionare il tipo di installazione, e quindi il set di componenti corrispondente, come mostrato nella Figura :num:`figure-NSISInstallationTypes`."

#: ../../source/chapter/Packaging CPack.rst:1112 With
msgid "NSIS Installation Types"
msgstr "Tipi di installazioni NSIS"

#: ../../source/chapter/Packaging CPack.rst:1115 With
msgid "Variables that control CPack components"
msgstr "Variabili che controllano i componenti CPack"

#: ../../source/chapter/Packaging CPack.rst:1117 With
msgid ""
"The functions ``cpack_add_install_type``, ``cpack_add_component_group``, "
"and ``cpack_add_component`` just set ``CPACK_`` variables. Those "
"variables are described in the following list:"
msgstr "Le funzioni ``cpack_add_install_type``, ``cpack_add_component_group`` e ``cpack_add_component`` impostano semplicemente le variabili ``CPACK_``. Tali variabili sono descritte nel seguente elenco:"

#: ../../source/chapter/Packaging CPack.rst:1127 With
msgid "**CPACK_COMPONENTS_ALL**"
msgstr "**CPACK_COMPONENTS_ALL**"

#: ../../source/chapter/Packaging CPack.rst:1123 With
msgid ""
"This is a list containing the names of all components that should be "
"installed by CPack. The presence of this macro indicates that CPack "
"should build a component-based installer. Files associated with any "
"components not listed here or any installation commands not associated "
"with any component will not be installed."
msgstr "Questo è un elenco contenente i nomi di tutti i componenti che dovrebbero essere installati da CPack. La presenza di questa macro indica che CPack dovrebbe creare un programma di installazione basato su componenti. I file associati a componenti non elencati qui o comandi di installazione non associati a componenti non verranno installati."

#: ../../source/chapter/Packaging CPack.rst:1132 With
msgid "**CPACK_COMPONENT_${COMPNAME}_DISPLAY_NAME**"
msgstr "**CPACK_COMPONENT_${COMPNAME}_DISPLAY_NAME**"

#: ../../source/chapter/Packaging CPack.rst:1130 With
msgid ""
"The displayed name of the component ${COMPNAME}, used in graphical "
"installers to display the component name. This value can be any string."
msgstr "Il nome visualizzato del componente ${COMPNAME}, utilizzato nei programmi di installazione grafici per visualizzare il nome del componente. Questo valore può essere qualsiasi stringa."

#: ../../source/chapter/Packaging CPack.rst:1138 With
msgid "**CPACK_COMPONENT_${COMPNAME}_DESCRIPTION**"
msgstr "**CPACK_COMPONENT_${COMPNAME}_DESCRIPTION**"

#: ../../source/chapter/Packaging CPack.rst:1135 With
msgid ""
"An extended description of the component ${COMPNAME}, used in graphical "
"installers to give the user additional information about the component. "
"Descriptions can span multiple lines using \"\\n\" as the line separator."
msgstr "Una descrizione estesa del componente ${COMPNAME}, utilizzata negli installer grafici per fornire all'utente ulteriori informazioni sul componente. Le descrizioni possono estendersi su più righe utilizzando \"\\n\" come separatore di riga."

#: ../../source/chapter/Packaging CPack.rst:1143 With
msgid "**CPACK_COMPONENT_${COMPNAME}_HIDDEN**"
msgstr "**CPACK_COMPONENT_${COMPNAME}_HIDDEN**"

#: ../../source/chapter/Packaging CPack.rst:1141 With
msgid ""
"A flag that indicates that this component will be hidden in the graphical"
" installer, and therefore cannot be selected or installed. Only available"
" with NSIS."
msgstr "Un flag che indica che questo componente sarà nascosto nel programma di installazione grafico e quindi non potrà essere selezionato o installato. Disponibile solo con NSIS."

#: ../../source/chapter/Packaging CPack.rst:1148 With
msgid "**CPACK_COMPONENT_${COMPNAME}_REQUIRED**"
msgstr "**CPACK_COMPONENT_${COMPNAME}_REQUIRED**"

#: ../../source/chapter/Packaging CPack.rst:1146 With
msgid ""
"A flag that indicates that this component is required, and therefore will"
" always be installed. It will be visible in the graphical installer but "
"it cannot be unselected."
msgstr "Un flag che indica che questo componente è obbligatorio e quindi sarà sempre installato. Sarà visibile nell'installer grafico ma non può essere deselezionato."

#: ../../source/chapter/Packaging CPack.rst:1153 With
msgid "**CPACK_COMPONENT_${COMPNAME}_DISABLED**"
msgstr "**CPACK_COMPONENT_${COMPNAME}_DISABLED**"

#: ../../source/chapter/Packaging CPack.rst:1151 With
msgid ""
"A flag that indicates that this component should be disabled (unselected)"
" by default. The user is free to select this component for installation."
msgstr "Un flag che indica che questo componente deve essere disabilitato (deselezionato) per default. L'utente è libero di selezionare questo componente per l'installazione."

#: ../../source/chapter/Packaging CPack.rst:1158 With
msgid "**CPACK_COMPONENT_${COMPNAME}_DEPENDS**"
msgstr "**CPACK_COMPONENT_${COMPNAME}_DEPENDS**"

#: ../../source/chapter/Packaging CPack.rst:1156 With
msgid ""
"Lists the components on which this component depends. If this component "
"is selected, then each of the components listed must also be selected."
msgstr "Elenca i componenti da cui dipende questo componente. Se questo componente è selezionato, è necessario selezionare anche ciascuno dei componenti elencati."

#: ../../source/chapter/Packaging CPack.rst:1163 With
msgid "**CPACK_COMPONENT_${COMPNAME}_GROUP**"
msgstr "**CPACK_COMPONENT_${COMPNAME}_GROUP**"

#: ../../source/chapter/Packaging CPack.rst:1161 With
msgid ""
"Names a component group that this component is a part of. If not "
"provided, the component will be a standalone component, not part of any "
"component group."
msgstr "Denomina un gruppo di componenti di cui fa parte questo componente. Se non fornito, il componente sarà un componente autonomo, non farà parte di alcun gruppo di componenti."

#: ../../source/chapter/Packaging CPack.rst:1168 With
msgid "**CPACK_COMPONENT_${COMPNAME}_INSTALL_TYPES**"
msgstr "**CPACK_COMPONENT_${COMPNAME}_INSTALL_TYPES**"

#: ../../source/chapter/Packaging CPack.rst:1166 With
msgid ""
"Lists the installation types that this component is a part of. When one "
"of these installations types is selected, this component will "
"automatically be selected. Only available with NSIS."
msgstr "Elenca i tipi di installazione di cui fa parte questo componente. Quando viene selezionato uno di questi tipi di installazione, questo componente verrà selezionato automaticamente. Disponibile solo con NSIS."

#: ../../source/chapter/Packaging CPack.rst:1173 With
msgid "**CPACK_COMPONENT_GROUP_${GROUPNAME}_DISPLAY_NAME**"
msgstr "**CPACK_COMPONENT_GROUP_${GROUPNAME}_DISPLAY_NAME**"

#: ../../source/chapter/Packaging CPack.rst:1171 With
msgid ""
"The displayed name of the component group ${GROUPNAME}, used in graphical"
" installers to display the component group name. This value can be any "
"string."
msgstr "Il nome visualizzato del gruppo di componenti ${GROUPNAME}, utilizzato nei programmi di installazione grafici per visualizzare il nome del gruppo di componenti. Questo valore può essere qualsiasi stringa."

#: ../../source/chapter/Packaging CPack.rst:1179 With
msgid "**CPACK_COMPONENT_GROUP_${GROUPNAME}_DESCRIPTION**"
msgstr "**CPACK_COMPONENT_GROUP_${GROUPNAME}_DESCRIPTION**"

#: ../../source/chapter/Packaging CPack.rst:1176 With
msgid ""
"An extended description of the component group ${GROUPNAME}, used in "
"graphical installers to give the user additional information about the "
"components contained within this group. Descriptions can span multiple "
"lines using \"\\n\" as the line separator."
msgstr "Una descrizione estesa del gruppo di componenti ${GROUPNAME}, utilizzata negli installatori grafici per fornire all'utente informazioni aggiuntive sui componenti contenuti in questo gruppo. Le descrizioni possono estendersi su più righe utilizzando \"\\n\" come separatore di riga."

#: ../../source/chapter/Packaging CPack.rst:1183 With
msgid "**CPACK_COMPONENT_GROUP_${GROUPNAME}_BOLD_TITLE**"
msgstr "**CPACK_COMPONENT_GROUP_${GROUPNAME}_BOLD_TITLE**"

#: ../../source/chapter/Packaging CPack.rst:1182 With
msgid ""
"A flag indicating whether the group title should be in bold. Only "
"available with NSIS."
msgstr "Un flag che indica se il titolo del gruppo deve essere in grassetto. Disponibile solo con NSIS."

#: ../../source/chapter/Packaging CPack.rst:1188 With
msgid "**CPACK_COMPONENT_GROUP_${GROUPNAME}_EXPANDED**"
msgstr "**CPACK_COMPONENT_GROUP_${GROUPNAME}_EXPANDED**"

#: ../../source/chapter/Packaging CPack.rst:1186 With
msgid ""
"A flag indicating whether the group should start out \"expanded\", "
"showing its components. Otherwise only the group name itself will be "
"shown until the user clicks on the group. Only available with NSIS."
msgstr "Un flag che indica se il gruppo deve iniziare \"espanso\", mostrandone i componenti. Altrimenti verrà mostrato solo il nome del gruppo stesso finché l'utente non fa clic sul gruppo. Disponibile solo con NSIS."

#: ../../source/chapter/Packaging CPack.rst:1192 With
msgid "**CPACK_INSTALL_TYPE_${INSTNAME}_DISPLAY_NAME**"
msgstr "**CPACK_INSTALL_TYPE_${INSTNAME}_DISPLAY_NAME**"

#: ../../source/chapter/Packaging CPack.rst:1191 With
msgid "The displayed name of the installation type. This value can be any string."
msgstr "Il nome visualizzato del tipo di installazione. Questo valore può essere qualsiasi stringa."

#: ../../source/chapter/Packaging CPack.rst:1198 With
msgid "CPack for Cygwin Setup"
msgstr "CPack per l'installazione di Cygwin"

#: ../../source/chapter/Packaging CPack.rst:1200 With
msgid ""
"Cygwin (http://www.cygwin.com/) is a Linux-like environment for Windows "
"that consists of a run time DLL and a collection of tools. To add tools "
"to the official cygwin, the cygwin setup program is used. The setup tool "
"has very specific layouts for the source and binary trees that are to be "
"included. CPack can create the source and binary tar files and correctly "
"bzip them so that they can be uploaded to the cygwin mirror sites. You "
"must of course have your package accepted by the cygwin community before "
"that is done. Since the layout of the package is more restrictive than "
"other packaging tools, you may have to change some of the install options"
" for your project."
msgstr "Cygwin (http://www.cygwin.com/) è un ambiente simile a Linux per Windows che consiste in una DLL di runtime e una raccolta di tool. Per aggiungere tool al cygwin ufficiale, viene utilizzato il programma di installazione di cygwin. Lo strumento di installazione ha layout molto specifici per gli alberi sorgenti e binari che devono essere inclusi. CPack può creare i file tar sorgenti e binari e comprimerli correttamente in modo che possano essere caricati sui siti mirror di cygwin. Ovviamente si deve far accettare il pacchetto dalla comunità cygwin prima che ciò avvenga. Poiché il layout del pacchetto è più restrittivo rispetto ad altri strumenti di creazione di pacchetti, potrebbe essere necessario modificare alcune delle opzioni di installazione per il progetto."

#: ../../source/chapter/Packaging CPack.rst:1211 With
msgid ""
"The cygwin setup program requires that all files be installed into "
"``/usr/bin``, ``/usr/share/package-version``, ``/usr/share/man`` and "
"``/usr/share/doc/package-version``. The cygwin CPack generator will "
"automatically add the ``/usr`` to the install directory for the project. "
"The project must install things into ``share`` and ``bin``, and CPack "
"will add the ``/usr`` prefix automatically."
msgstr "Il programma di installazione di Cygwin richiede che tutti i file siano installati in ``/usr/bin``, ``/usr/share/package-version``, ``/usr/share/man`` e ``/usr/share/doc/package-version``. Il generatore cygwin CPack aggiungerà automaticamente ``/usr`` alla directory di installazione per il progetto. Il progetto deve installare cose in ``share`` e ``bin``, e CPack aggiungerà automaticamente il prefisso ``/usr``."

#: ../../source/chapter/Packaging CPack.rst:1218 With
msgid ""
"Cygwin also requires that you provide a shell script that can be used to "
"create the package from the sources. Any cygwin specific patches that are"
" required for the package must also be provided in a diff file. CMake's "
"configure_file command can be used to create both of these files for a "
"project. Since CMake is a cygwin package, the CMake code used to "
"configure CMake for the cygwin CPack generators is as follows"
msgstr "Cygwin richiede inoltre di fornire uno script di shell che utilizzabile per creare il pacchetto dai sorgenti. Eventuali patch specifiche di cygwin necessarie per il pacchetto devono essere fornite in un ulteriore file diff. Il comando configure_file di CMake può essere utilizzato per creare entrambi questi file per un progetto. Poiché CMake è un pacchetto cygwin, il codice CMake utilizzato per configurare CMake per i generatori cygwin CPack è il seguente"

#: ../../source/chapter/Packaging CPack.rst:1269 With
msgid "``Utilities/Release/Cygwin/CMakeLists.txt``:"
msgstr "``Utilities/Release/Cygwin/CMakeLists.txt``:"

#: ../../source/chapter/Packaging CPack.rst:1297 With
msgid ""
"The file ``Utilities/Release/Cygwin/cygwin-package.sh.in`` can be found "
"in the CMake source tree. It is a shell script that can be used to re-"
"create the cygwin package from source. For other projects, there is a "
"template install script that can be found in ``Templates/cygwin-"
"package.sh.in``. This script should be able to configure and package any "
"cygwin based CPack project, and it is required for all official cygwin "
"packages."
msgstr "Il file ``Utilities/Release/Cygwin/cygwin-package.sh.in`` si trova nell'albero dei sorgenti di CMake. È uno script di shell utilizzabile per ricreare il pacchetto cygwin dal sorgente. Per altri progetti, esiste uno script template di installazione che si trova in ``Templates/cygwin-package.sh.in``. Questo script dovrebbe essere in grado di configurare e impacchettare qualsiasi progetto CPack basato su Cygwin ed è richiesto per tutti i pacchetti Cygwin ufficiali."

#: ../../source/chapter/Packaging CPack.rst:1305 With
msgid ""
"Another important file for cygwin binaries is ``share/doc/Cygwin/package-"
"version.README``. This file should contain the information required by "
"cygwin about the project. In the case of CMake, the file is configured so"
" that it can contain the correct version information. For example, part "
"of that file for CMake looks like this::"
msgstr "Un altro file importante per i binari di Cygwin è ``share/doc/Cygwin/package-version.README``. Questo file dovrebbe contenere le informazioni richieste da cygwin sul progetto. Nel caso di CMake, il file è configurato in modo da poter contenere le informazioni sulla versione corretta. Ad esempio, parte di quel file per CMake ha questo aspetto::"

#: ../../source/chapter/Packaging CPack.rst:1326 With
msgid "CPack for Mac OS X PackageMaker"
msgstr "CPack per Mac OS X PackageMaker"

#: ../../source/chapter/Packaging CPack.rst:1328 With
msgid ""
"On the Apple Mac OS X operating system, CPack provides the ability to use"
" the system PackageMaker tool. This section will show the CMake "
"application install screens users will see when installing the CMake "
"package on OS X. The CPack variables set to change the text in the "
"installer will be given for each screen of the installer."
msgstr "Sul sistema operativo Apple Mac OS X, CPack offre la possibilità di utilizzare il tool di sistema PackageMaker. Questa sezione mostrerà le schermate di installazione dell'applicazione CMake che gli utenti vedranno durante l'installazione del pacchetto CMake su OS X. Le variabili CPack impostate per modificare il testo nel programma di installazione verranno fornite per ciascuna schermata del programma di installazione."

#: ../../source/chapter/Packaging CPack.rst:1338 With
msgid "Mac Package inside .dmg"
msgstr "Pacchetto Mac all'interno di .dmg"

#: ../../source/chapter/Packaging CPack.rst:1340 With
msgid ""
"In Figure :num:`figure-MacPackageinsidedmg`, the ``.pkg`` file found "
"inside the ``.dmg`` disk image created by the CPack package maker for Mac"
" OS X is seen. The name of this file is controlled by the "
"``CPACK_PACKAGE_FILE_NAME`` variable. If this is not set, CPack will use "
"a default name based on the package name and version settings."
msgstr "La Figura :num:`figure-MacPackageinsidedmg` mostra il file ``.pkg`` che si trova nell'immagine del disco ``.dmg`` creata dal creatore di pacchetti CPack per Mac OS X. Il nome di questo file è controllato dalla variabile ``CPACK_PACKAGE_FILE_NAME``. Se questo non è impostato, CPack utilizzerà un nome di default basato sul nome del pacchetto e sulle impostazioni della versione."

#: ../../source/chapter/Packaging CPack.rst:1350 With
msgid "Introduction Screen Mac PackageMaker"
msgstr "Schermata introduttiva Mac PackageMaker"

#: ../../source/chapter/Packaging CPack.rst:1352 With
msgid ""
"When the ``.pkg`` file is run, the package wizard starts with the screen "
"seen in Figure :num:`figure-IntroductionScreenMacPackageMaker`. The text "
"in this window is controlled by the file pointed to by the "
"``CPACK_RESOURCE_FILE_WELCOME`` variable."
msgstr "Quando viene eseguito il file ``.pkg``, la procedura guidata del pacchetto si avvia con la schermata visualizzata in Figura :num:`figure-IntroductionScreenMacPackageMaker`. Il testo in questa finestra è controllato dal file indicato dalla variabile ``CPACK_RESOURCE_FILE_WELCOME``."

#: ../../source/chapter/Packaging CPack.rst:1362 With
msgid "Readme section of Mac package wizard"
msgstr "La sezione Readme della procedura guidata per i pacchetti Mac"

#: ../../source/chapter/Packaging CPack.rst:1364 With
msgid ""
"The figure above shows the read me section of the package wizard. The "
"text for this window is customized by using the "
"``CPACK_RESOURCE_FILE_README`` variable. It should contain a path to the "
"file containing the text that should be displayed on this screen."
msgstr "La figura sopra mostra la sezione Readme della procedura guidata del pacchetto. Il testo di questa finestra è personalizzato utilizzando la variabile ``CPACK_RESOURCE_FILE_README``. Dovrebbe contenere un path al file contenente il testo che dovrebbe essere visualizzato su questa schermata."

#: ../../source/chapter/Packaging CPack.rst:1373 With
msgid "License screen Mac packager"
msgstr "Schermata della licenza Mac packager"

#: ../../source/chapter/Packaging CPack.rst:1375 With
msgid ""
"This figure contains the license text for the package. Users must accept "
"the license for the installation process to continue. The text for the "
"license comes from the file pointed to by the "
"``CPACK_RESOURCE_FILE_LICENSE`` variable."
msgstr "Questa figura contiene il testo della licenza per il pacchetto. Gli utenti devono accettare la licenza affinché il processo di installazione continui. Il testo della licenza proviene dal file indicato dalla variabile ``CPACK_RESOURCE_FILE_LICENSE``."

#: ../../source/chapter/Packaging CPack.rst:1380 With
msgid ""
"The other screens in the installation process are not customizable from "
"CPack. To change more advanced features of this installer, there are two "
"CPack templates that you can modify, ``Modules/CPack.Info.plist.in`` and "
"``Modules/CPack.Description.plist.in``. These files can be replaced by "
"using the ``CMAKE_MODULE_PATH`` variable to point to a directory in your "
"project containing a modified copy of either or both."
msgstr "Le altre schermate nel processo di installazione non sono personalizzabili da CPack. Per modificare le funzionalità più avanzate di questo programma di installazione, ci sono due modelli CPack modificabili, ``Modules/CPack.Info.plist.in`` e ``Modules/CPack.Description.plist.in``. Questi file possono essere sostituiti utilizzando la variabile ``CMAKE_MODULE_PATH`` per puntare a una directory nel progetto contenente una copia modificata di uno o entrambi."

#: ../../source/chapter/Packaging CPack.rst:1392 With
msgid "CPack for Mac OS X Drag and Drop"
msgstr "CPack per Mac OS X \"Drag and Drop\""

#: ../../source/chapter/Packaging CPack.rst:1394 With
msgid ""
"CPack also supports the creation of a Drag and Drop installer for the "
"Mac. In this case a .dmg disk image is created. The image contains both a"
" symbolic link to the /Applications directory and a copy of the project's"
" install tree. In this case it is best to use a Mac application bundle or"
" a single folder containing your relocatable installation as the only "
"install target for the project. The variable "
"``CPACK_PACKAGE_EXECUTABLES`` is used to point to the application bundle "
"for the project."
msgstr "CPack supporta anche la creazione di un programma di installazione Drag and Drop per Mac. In questo caso viene creata un'immagine .dmg. L'immagine contiene sia un link simbolico alla directory /Applications sia una copia dell'albero di installazione del progetto. In questo caso è meglio utilizzare un pacchetto di applicazioni Mac o una singola cartella contenente l'installazione rilocabile come unica destinazione di installazione per il progetto. La variabile ``CPACK_PACKAGE_EXECUTABLES`` viene utilizzata per puntare al bundle dell'applicazione per il progetto."

#: ../../source/chapter/Packaging CPack.rst:1407 With
msgid "Drag and Drop License dialog"
msgstr "Finestra di dialogo della licenza Drag and Drop"

#: ../../source/chapter/Packaging CPack.rst:1413 With
msgid "Resulting Drag and Drop folders"
msgstr "Cartelle Drag and Drop risultanti"

#: ../../source/chapter/Packaging CPack.rst:1416 With
msgid "CPack for Mac OS X X11 Applications"
msgstr "CPack per applicazioni Mac OS X X11"

#: ../../source/chapter/Packaging CPack.rst:1418 With
msgid ""
"CPack also includes an OS X X11 package maker generator. This can be used"
" to package X11 based applications, as well as make them act more like "
"native OS X applications by wrapping them with a script that will allow "
"users to run them as they would any native OS X application. Much like "
"the OS X PackageMaker generator, the OS X X11 generator creates a disk "
"image ``.dmg`` file. In this example, an X11 application called "
"KWPolygonalObjectViewerExample is packaged with the OS X X11 CPack "
"generator."
msgstr "CPack include anche un generatore di creatori di pacchetti OS X X11. Questo può essere utilizzato per impacchettare applicazioni basate su X11, oltre a farle agire più come applicazioni OS X native racchiudendole con uno script che consentirà agli utenti di eseguirle come farebbero con qualsiasi applicazione OS X nativa. Proprio come il generatore OS X PackageMaker, il generatore OS X X11 crea un file immagine ``.dmg``. In questo esempio, un'applicazione X11 chiamata KWPolygonalObjectViewerExample è inclusa nel pacchetto con il generatore OS X X11 CPack."

#: ../../source/chapter/Packaging CPack.rst:1431 With
msgid "Mac OS X X11 package disk image"
msgstr "Immagine del disco del pacchetto Mac OS X X11"

#: ../../source/chapter/Packaging CPack.rst:1433 With
msgid ""
"This figure shows the disk image created. In this case the "
"``CPACK_PACKAGE_NAME`` was set to KWPolygonalObjectViewerExample, and the"
" version information was left with the CPack default of 0.1.1. The "
"variable ``CPACK_PACKAGE_EXECUTABLES`` was set to the pair "
"KWPolygonalObjectViewerExample and KWPolygonalObjectViewerExample, the "
"installed X11 application is called KWPolygonalObjectViewerExample."
msgstr "Questa figura mostra l'immagine del disco creata. In questo caso ``CPACK_PACKAGE_NAME`` è stato impostato su KWPolygonalObjectViewerExample e le informazioni sulla versione sono state lasciate con il default di CPack di 0.1.1. La variabile ``CPACK_PACKAGE_EXECUTABLES`` è stata impostata sulla coppia KWPolygonalObjectViewerExample e KWPolygonalObjectViewerExample, l'applicazione X11 installata si chiama KWPolygonalObjectViewerExample."

#: ../../source/chapter/Packaging CPack.rst:1444 With
msgid "Opening OS X X11 disk image"
msgstr "Apertura dell'immagine disco OS X X11"

#: ../../source/chapter/Packaging CPack.rst:1446 With
msgid ""
"The above figure shows what a user would see after clicking on the "
"``.dmg`` file created by CPack. Mac OS X is mounting this disk image as a"
" disk"
msgstr "La figura sopra mostra ciò che un utente vedrebbe dopo aver fatto clic sul file ``.dmg`` creato da CPack. Mac OS X sta montando questa immagine come disco"

#: ../../source/chapter/Packaging CPack.rst:1454 With
msgid "Mounted .dmg disk image"
msgstr "L'immagine .dmg montata"

#: ../../source/chapter/Packaging CPack.rst:1456 With
msgid ""
"This figure shows the mounted disk image. It will contain a symbolic link"
" to the /Applications directory for the system, and it will contain an "
"application bundle for each executable found in "
"``CPACK_PACKAGE_EXECUTABLES``. The users can then drag and drop the "
"applications into the Applications folder as seen in the figure below."
msgstr "Questa figura mostra l'immagine del disco montata. Conterrà un link simbolico alla directory /Applications per il sistema e conterrà un pacchetto di applicazioni per ogni eseguibile trovato in ``CPACK_PACKAGE_EXECUTABLES``. Gli utenti possono quindi trascinare e rilasciare le applicazioni nella cartella Applications come mostrato nella figura seguente."

#: ../../source/chapter/Packaging CPack.rst:1466 With
msgid "Drag and drop application to Applications"
msgstr "Drag and drop dell'applicazione in Applications"

#: ../../source/chapter/Packaging CPack.rst:1468 With
msgid ""
"CPack actually provides a C++ based executable that can run an X11 "
"application via the Apple scripting language. The application bundle "
"installed will run that forwarding application when the user double "
"clicks on KWPolygonalObjectViewerExample. This script will make sure that"
" the X11 server is started. The script that is run can be found in "
"``CMake/Modules/CPack.RuntimeScript.in``. The source for the script "
"launcher C++ program can be found in "
"``Source/CPack/OSXScriptLauncher.cxx``."
msgstr "CPack fornisce effettivamente un eseguibile basato su C++ che può eseguire un'applicazione X11 tramite il linguaggio di scripting Apple. Il bundle dell'applicazione installato eseguirà l'applicazione di inoltro quando l'utente fa doppio clic su KWPolygonalObjectViewerExample. Questo script farà in modo che il server X11 sia avviato. Lo script che viene eseguito si trova in ``CMake/Modules/CPack.RuntimeScript.in``. Il sorgente per il programma C++ di avvio degli script si trova in ``Source/CPack/OSXScriptLauncher.cxx``."

#: ../../source/chapter/Packaging CPack.rst:1481 With
msgid "CPack for Debian Packages"
msgstr "CPack per i pacchetti Debian"

#: ../../source/chapter/Packaging CPack.rst:1483 With
msgid ""
"A Debian package ``.deb`` is simply an \"ar\" archive. CPack includes the"
" code for the BSD style ar that is required by Debian packages. The "
"Debian packager uses the standard set of CPack variables to initialize a "
"set of Debian specific variables. These can be overridden in the "
"``CPACK_PROJECT_CONFIG_FILE``; the name of the generator is \"DEB\". The "
"variables used by the DEB generator are as follows:"
msgstr "Un pacchetto Debian ``.deb`` è semplicemente un archivio \"ar\". CPack include il codice per l'ar in stile BSD richiesto dai pacchetti Debian. Il packager Debian usa l'insieme standard di variabili CPack per inizializzare un insieme di variabili specifiche di Debian. Questi possono essere sovrascritte in ``CPACK_PROJECT_CONFIG_FILE``; il nome del generatore è \"DEB\". Le variabili utilizzate dal generatore DEB sono le seguenti:"

#: ../../source/chapter/Packaging CPack.rst:1490 With
msgid "**CPACK_DEBIAN_PACKAGE_NAME**"
msgstr "**CPACK_DEBIAN_PACKAGE_NAME**"

#: ../../source/chapter/Packaging CPack.rst:1492 With
msgid "defaults to lower case of ``CPACK_PACKAGE_NAME``."
msgstr "il default è il minuscolo di ``CPACK_PACKAGE_NAME``."

#: ../../source/chapter/Packaging CPack.rst:1494 With
msgid "**CPACK_DEBIAN_PACKAGE_ARCHITECTURE**"
msgstr "**CPACK_DEBIAN_PACKAGE_ARCHITECTURE**"

#: ../../source/chapter/Packaging CPack.rst:1496 With
msgid "defaults to ``i386``."
msgstr "il default è ``i386``."

#: ../../source/chapter/Packaging CPack.rst:1498 With
msgid "**CPACK_DEBIAN_PACKAGE_DEPENDS**"
msgstr "**CPACK_DEBIAN_PACKAGE_DEPENDS**"

#: ../../source/chapter/Packaging CPack.rst:1500 With
msgid ""
"This must be set to other packages that this package depends on, and if "
"empty a warning is emitted."
msgstr "Questo deve essere impostato su altri pacchetti da cui dipende questo pacchetto e, se vuoto, viene emesso un warning."

#: ../../source/chapter/Packaging CPack.rst:1503 With
msgid "**CPACK_DEBIAN_PACKAGE_MAINTAINER**"
msgstr "**CPACK_DEBIAN_PACKAGE_MAINTAINER**"

#: ../../source/chapter/Packaging CPack.rst:1505 With
msgid "defaults to value of ``CPACK_PACKAGE_CONTACT``"
msgstr "il default è il valore di ``CPACK_PACKAGE_CONTACT``"

#: ../../source/chapter/Packaging CPack.rst:1507 With
msgid "**CPACK_DEBIAN_PACKAGE_DESCRIPTION**"
msgstr "**CPACK_DEBIAN_PACKAGE_DESCRIPTION**"

#: ../../source/chapter/Packaging CPack.rst:1509 CPack.rst:1534 With
msgid "defaults to value of ``CPACK_PACKAGE_DESCRIPTION_SUMMARY``"
msgstr "il default è il valore di ``CPACK_PACKAGE_DESCRIPTION_SUMMARY``"

#: ../../source/chapter/Packaging CPack.rst:1511 With
msgid "**CPACK_DEBIAN_PACKAGE_SECTION**"
msgstr "**CPACK_DEBIAN_PACKAGE_SECTION**"

#: ../../source/chapter/Packaging CPack.rst:1513 With
msgid "defaults to ``devl``"
msgstr "il default è ``devl``"

#: ../../source/chapter/Packaging CPack.rst:1515 With
msgid "**CPACK_DEBIAN_PACKAGE_PRIORITY**"
msgstr "**CPACK_DEBIAN_PACKAGE_PRIORITY**"

#: ../../source/chapter/Packaging CPack.rst:1517 With
msgid "defaults to ``optional``"
msgstr "il default è ``optional``"

#: ../../source/chapter/Packaging CPack.rst:1523 With
msgid "CPack for RPM"
msgstr "CPack per RPM"

#: ../../source/chapter/Packaging CPack.rst:1525 With
msgid ""
"CPack has support for creating Linux RPM files. The name of the generator"
" as set in ``CPACK_GENERATOR`` is \"RPM\". The RPM package capability "
"requires that rpmbuild is installed on the machine and is in PATH. The "
"RPM packager uses the standard set of CPack variables to initialize RPM "
"specific variables. The RPM specific variables are as follows:"
msgstr "CPack ha il supporto per la creazione di file RPM Linux. Il nome del generatore come impostato in ``CPACK_GENERATOR`` è \"RPM\". La funzionalità del pacchetto RPM richiede che rpmbuild sia installato sulla macchina e si trovi in PATH. Il packager RPM utilizza il set standard di variabili CPack per inizializzare variabili specifiche di RPM. Le variabili specifiche RPM sono le seguenti:"

#: ../../source/chapter/Packaging CPack.rst:1532 With
msgid "**CPACK_RPM_PACKAGE_SUMMARY**"
msgstr "**CPACK_RPM_PACKAGE_SUMMARY**"

#: ../../source/chapter/Packaging CPack.rst:1536 With
msgid "**CPACK_RPM_PACKAGE_NAME**"
msgstr "**CPACK_RPM_PACKAGE_NAME**"

#: ../../source/chapter/Packaging CPack.rst:1538 With
msgid "defaults to lower case of ``CPACK_PACKAGE_NAME``"
msgstr "il default è il minuscolo di ``CPACK_PACKAGE_NAME``"

#: ../../source/chapter/Packaging CPack.rst:1540 With
msgid "**CPACK_RPM_PACKAGE_VERSION**"
msgstr "**CPACK_RPM_PACKAGE_VERSION**"

#: ../../source/chapter/Packaging CPack.rst:1542 With
msgid "defaults to value of ``CPACK_PACKAGE_VERSION``."
msgstr "il default è il valore di ``CPACK_PACKAGE_VERSION``."

#: ../../source/chapter/Packaging CPack.rst:1544 With
msgid "**CPACK_RPM_PACKAGE_ARCHITECTURE**"
msgstr "**CPACK_RPM_PACKAGE_ARCHITECTURE**"

#: ../../source/chapter/Packaging CPack.rst:1546 With
msgid "defaults to ``i386``"
msgstr "il default è ``i386``."

#: ../../source/chapter/Packaging CPack.rst:1548 With
msgid "**CPACK_RPM_PACKAGE_RELEASE**"
msgstr "**CPACK_RPM_PACKAGE_RELEASE**"

#: ../../source/chapter/Packaging CPack.rst:1550 With
msgid ""
"defaults to ``1``. This is the version of the RPM file, not the version "
"of the software being packaged."
msgstr "il default è ``1``. Questa è la versione del file RPM, non quella del software che impacchettato."

#: ../../source/chapter/Packaging CPack.rst:1553 With
msgid "**CPACK_RPM_PACKAGE_GROUP**"
msgstr "**CPACK_RPM_PACKAGE_GROUP**"

#: ../../source/chapter/Packaging CPack.rst:1555 With
msgid "defaults to ``none``."
msgstr "il default è ``none``."

#: ../../source/chapter/Packaging CPack.rst:1557 With
msgid "**CPACK_RPM_PACKAGE_VENDOR**"
msgstr "**CPACK_RPM_PACKAGE_VENDOR**"

#: ../../source/chapter/Packaging CPack.rst:1559 With
msgid "defaults to value of ``CPACK_PACKAGE_VENDOR``"
msgstr "il default è il valore di ``CPACK_PACKAGE_VENDOR``"

#: ../../source/chapter/Packaging CPack.rst:1562 With
msgid "CPack Files"
msgstr "I File CPack"

#: ../../source/chapter/Packaging CPack.rst:1564 With
msgid ""
"There are a number of files that are used by CPack that can be useful for"
" learning more about how CPack works and what options you can set. These "
"files can also be used as the starting point for other generators for "
"CPack. These files can mostly be found in the Modules and Templates "
"directories of CMake and typically start with the prefix CPack. As of "
"version 2.8.8, you may also refer to ``cpack --help-variable-list`` and "
"``cpack --help-variable`` for the full set of documented ``CPACK_*`` "
"variables."
msgstr "Esistono numerosi file utilizzati da CPack che possono essere utili per saperne di più su come funziona CPack e quali opzioni è possibile impostare. Questi file possono essere utilizzati anche come punto di partenza per altri generatori per CPack. Questi file si trovano principalmente nelle directory Modules e Templates di CMake e in genere iniziano con il prefisso CPack. A partire dalla versione 2.8.8, si può anche fare riferimento a ``cpack --help-variable-list`` e a ``cpack --help-variable`` per il set completo di variabili ``CPACK_*`` documentate."

#: ../../source/chapter/Policies.rst:2
msgid "Policies"
msgstr "Policy"

#: ../../source/chapter/Policies.rst:4
msgid ""
"Occasionally a new feature or change is made to CMake that is not fully "
"backwards compatible with older versions. This can create problems when "
"someone tries to use an old CMakeLists file with a new version of CMake. "
"To help both end users and developers through such issues, we have "
"introduced :manual:`cmake-policies <cmake-policies(7)>`. Policies are a "
"mechanism for helping improve backwards compatibility and tracking "
"compatibility issues between different versions of CMake."
msgstr "Occasionalmente viene apportata una nuova funzionalità o modifica a CMake che non è completamente compatibile con le versioni precedenti. Ciò può creare problemi quando qualcuno tenta di utilizzare un vecchio file CMakeLists con una nuova versione di CMake. Per aiutare sia gli utenti finali che gli sviluppatori a risolvere questi problemi, abbiamo introdotto :manual:`cmake-policies <cmake-policies(7)>`. Le Policy sono un meccanismo per aiutare a migliorare la compatibilità con le versioni precedenti e tenere traccia dei problemi di compatibilità tra le diverse versioni di CMake."

#: ../../source/chapter/Policies.rst:13
msgid "Design Goals"
msgstr "Obiettivi del Progetto"

#: ../../source/chapter/Policies.rst:15
msgid "There were four main design goals for the CMake policy mechanism:"
msgstr "C'erano quattro obiettivi di progettazione principali per il meccanismo delle Policy CMake:"

#: ../../source/chapter/Policies.rst:17
msgid ""
"Existing projects should build with newer versions of CMake than that "
"used by the project authors."
msgstr "I progetti esistenti devono essere compilati con versioni più recenti di CMake rispetto a quella utilizzata dagli autori del progetto."

#: ../../source/chapter/Policies.rst:20
msgid "Users should not need to edit code to get the projects to build."
msgstr "Gli utenti non dovrebbero aver bisogno di modificare il codice per ottenere la compilazione dei progetti."

#: ../../source/chapter/Policies.rst:21
msgid "Warnings may be issued but the projects should build."
msgstr "Possono essere emessi avvertimenti ma i progetti dovrebbero essere buildati."

#: ../../source/chapter/Policies.rst:23
msgid ""
"Correctness of new interfaces or bug fixes in old interfaces should not "
"be inhibited by compatibility requirements. Any reduction in correctness "
"of the latest interface is not fair on new projects."
msgstr "La correttezza delle nuove interfacce o la correzione dei bug nelle vecchie interfacce non dovrebbe essere inibita dai requisiti di compatibilità. Qualsiasi riduzione della correttezza dell'ultima interfaccia non è giusta per i nuovi progetti."

#: ../../source/chapter/Policies.rst:27
msgid ""
"Every change made to CMake that may require changes to a project's "
"CMakeLists files should be documented."
msgstr "Ogni modifica apportata a CMake che potrebbe richiedere modifiche ai file CMakeLists di un progetto deve essere documentata."

#: ../../source/chapter/Policies.rst:30
msgid ""
"Each change should also have a unique identifier that can be referenced "
"with warning and error messages."
msgstr "Ogni modifica deve inoltre avere un identificatore univoco a cui è possibile fare riferimento con warning e messaggi di errore."

#: ../../source/chapter/Policies.rst:32
msgid ""
"The new behavior is enabled only when the project has somehow indicated "
"it is supported."
msgstr "Il nuovo comportamento è abilitato solo quando il progetto ha in qualche modo indicato di essere supportato."

#: ../../source/chapter/Policies.rst:35
msgid ""
"We must be able to eventually remove code that implements compatibility "
"with ancient CMake versions."
msgstr "Dobbiamo essere in grado di rimuovere eventualmente il codice che implementa la compatibilità con le versioni vecchie di CMake."

#: ../../source/chapter/Policies.rst:38
msgid ""
"Such removal is necessary to keep the code clean and to allow for "
"internal refactoring."
msgstr "Tale rimozione è necessaria per mantenere il codice pulito e per consentire il refactoring interno."

#: ../../source/chapter/Policies.rst:40
msgid ""
"After such removal, attempts at building projects written for ancient "
"versions must fail with an informative message."
msgstr "Dopo tale rimozione, i tentativi di build dei progetti scritti per versioni vecchie devono fallire con un messaggio."

#: ../../source/chapter/Policies.rst:43
msgid ""
"All policies in CMake are assigned a name in the form CMPNNNN where NNNN "
"is an integer value. Policies typically support both an old behavior that"
" preserves compatibility with earlier versions of CMake, and a new "
"behavior that is considered correct and preferred for use by new "
"projects. Every policy has documentation detailing the motivation for the"
" change, and the old and new behaviors."
msgstr "A tutte le policy in CMake viene assegnato un nome nel formato CMPNNNN dove NNNN è un valore intero. Le policy in genere supportano sia un vecchio comportamento che mantiene la compatibilità con le versioni precedenti di CMake, sia un nuovo comportamento considerato corretto e preferito per l'uso da parte di nuovi progetti. Ogni policy ha una documentazione che dettaglia la motivazione delle modifiche e i comportamenti vecchi e nuovi."

#: ../../source/chapter/Policies.rst:54
msgid "Setting Policies"
msgstr "Impostazione delle Policy"

#: ../../source/chapter/Policies.rst:56
msgid ""
"Projects may configure the setting of each policy to request old or new "
"behaviors. When CMake encounters user code that may be affected by a "
"particular policy, it checks to see whether the project has set the "
"policy. If the policy has been set (to ``OLD`` or ``NEW``) then CMake "
"follows the behavior specified. If the policy has not been set then the "
"old behavior is used, but a warning is issued telling the project author "
"to set the policy."
msgstr "I progetti possono configurare l'impostazione di ciascuna policy per richiedere comportamenti vecchi o nuovi. Quando CMake rileva il codice utente che potrebbe essere interessato da una particolare policy, verifica se il progetto l'ha impostata. Se la policy è stata impostata (su ``OLD`` o ``NEW``), CMake segue il comportamento specificato. Se la policy non è stata impostata, viene utilizzato il vecchio comportamento, ma viene emesso un warning che indica all'autore del progetto di impostare il la policy."

#: ../../source/chapter/Policies.rst:64
msgid ""
"There are a couple ways to set the behavior of a policy. The quickest way"
" is to set all policies to a version that corresponds to the release "
"version of CMake the project was written in. Setting the policy version "
"requests the new behavior for all policies introduced in the "
"corresponding version of CMake or earlier. Policies introduced in later "
"versions are marked as \"not set\" in order to produce proper warning "
"messages. The policy version is set using the :command:`cmake_policy` "
"command's ``VERSION`` signature. For example, the code"
msgstr "Ci sono un paio di modi per impostare il comportamento di una policy. Il modo più rapido consiste nell'impostare tutte le policy su una versione che corrisponda a quella di rilascio di CMake in cui è stato scritto il progetto. L'impostazione della versione della policy richiede il nuovo comportamento per tutte le policy introdotte nella versione corrispondente di CMake o precedente. Le policy introdotte nelle versioni successive sono contrassegnati come \"not set\" per produrre messaggi appropriati. versione della policy viene impostata utilizzando del comando :command:`cmake_policy` la firma ``VERSION``. Ad esempio, il codice"

#: ../../source/chapter/Policies.rst:77
msgid ""
"will request the new behavior for all policies introduced in CMake 3.20 "
"or earlier."
msgstr "richiederà il nuovo comportamento per tutte le policy introdotte in CMake 3.20 o nelle versioni precedenti."

#: ../../source/chapter/Policies.rst:80
msgid ""
"The :command:`cmake_minimum_required` command will require a minimum "
"version of CMake and will call :command:`cmake_policy`. A project should "
"always begin with the lines"
msgstr "Il comando :command:`cmake_minimum_required` richiederà una versione minima di CMake e chiamerà :command:`cmake_policy`. Un progetto dovrebbe sempre iniziare con le righe"

#: ../../source/chapter/Policies.rst:93
msgid ""
"This indicates that the person running CMake must have at least version "
"3.20. If they are running an older version of CMake, an error message "
"will be displayed telling them that the project requires at least the "
"specified version of CMake."
msgstr "Questo indica che la persona che esegue CMake deve avere almeno la versione 3.20. Se si sta eseguendo una versione precedente di CMake, verrà visualizzato un messaggio di errore che informa che il progetto richiede almeno la versione specificata di CMake."

#: ../../source/chapter/Policies.rst:98
msgid ""
"Of course, one should replace \"3.20\" with the version of CMake you are "
"currently writing to. You can also set each policy individually if you "
"wish; this is sometimes helpful for project authors who want to "
"incrementally convert their projects to use a new behavior, or silence "
"warnings about dependence on an old behavior. The :command:`cmake_policy`"
" command's ``SET`` option may be used to explicitly request old or new "
"behavior for a particular policy."
msgstr "Ovviamente, si dovrebbe sostituire \"3.20\" con la versione di CMake in cui si sta attualmente scrivendo. Si può anche impostare ciascuna policy individualmente; questo a volte è utile per gli autori di progetti che desiderano convertire in modo incrementale i propri progetti per utilizzare un nuovo comportamento o silenziare i warning sulla dipendenza da un vecchio comportamento. Nel comando :command:`cmake_policy` si può usare l'opzione ``SET`` per richiedere esplicitamente un comportamento vecchio o nuovo per una particolare policy."

#: ../../source/chapter/Policies.rst:106
msgid ""
"For example, CMake 2.6 introduced the policy :policy:`CMP0002`, which "
"requires all logical target names to be globally unique (duplicate target"
" names previously worked by accident in some cases, but were not "
"diagnosed). Projects using duplicate target names and working "
"accidentally will receive warnings referencing the policy. The warnings "
"may be silenced with the code"
msgstr "Ad esempio, CMake 2.6 ha introdotto la policy :policy:`CMP0002`, che richiede che tutti i nomi di target logici siano univoci a livello globale (i nomi di target duplicati in precedenza funzionavano a volte per caso, ma non venivano diagnosticati). I progetti che utilizzano nomi di target duplicati e che funzionano accidentalmente riceveranno degli avvisi che fanno riferimento alla policy. I warning possono essere silenziati con il codice"

#: ../../source/chapter/Policies.rst:117
msgid ""
"which explicitly tells CMake to use the old behavior for the policy "
"(silently accepting duplicate target names). Another option is to use the"
" code"
msgstr "che dice esplicitamente a CMake di utilizzare il vecchio comportamento per la policy (accettando tacitamente nomi di duplicati dei target). Un'altra opzione è quella di usare il codice"

#: ../../source/chapter/Policies.rst:125
msgid ""
"to explicitly tell CMake to use new behavior and produce an error when a "
"duplicate target is created. Once this is added to the project, it will "
"not build until the author removes any duplicate target names."
msgstr "per dire esplicitamente a CMake di utilizzare un nuovo comportamento e produrre un errore quando viene creato un target duplicato. Una volta aggiunto al progetto, non verrà compilato fino a quando l'autore non rimuove eventuali nomi duplicati di target."

#: ../../source/chapter/Policies.rst:129
msgid ""
"When a new version of CMake is released, it introduces new policies that "
"can still build old projects, because by default they do not request "
"``NEW`` behavior for any of the new policies. When starting a new "
"project, one should always specify the most recent release of CMake to be"
" supported with the :command:`cmake_minimum_required` command. This will "
"ensure that the project is written to work using policies from that "
"version of CMake and not using any old behavior. If no policy version is "
"set, CMake will warn and assume a policy version of 2.4. This allows "
"existing projects that do not specify :command:`cmake_minimum_required` "
"to build as they would have with CMake 2.4."
msgstr "Quando viene rilasciata una nuova versione di CMake, vengono introdotte nuove policy che possono ancora creare vecchi progetti, perché per default non richiedono il comportamento ``NEW`` per nessuna delle nuove policy. Quando si avvia un nuovo progetto, si dovrebbe sempre specificare la versione più recente di CMake da supportare col comando :command:`cmake_minimum_required`. Ciò assicurerà che il progetto sia scritto per funzionare utilizzando le policy di quella versione di CMake e non utilizzando alcun comportamento precedente. Se non è impostata alcuna versione della policy, CMake avviserà e assumerà una versione della policy 2.4. Ciò consente ai progetti esistenti che non specificano :command:`cmake_minimum_required` di essere compilati come avrebbero fatto con CMake 2.4."

#: ../../source/chapter/Policies.rst:144
msgid "The Policy Stack"
msgstr "Lo Stack della Policy"

#: ../../source/chapter/Policies.rst:146
msgid ""
"Policy settings are scoped using a stack. A new level of the stack is "
"pushed when entering a new subdirectory of the project (with "
":command:`add_subdirectory`) and popped when leaving it. Therefore, "
"setting a policy in one directory of a project will not affect parent or "
"sibling directories, but it will affect subdirectories."
msgstr "Le impostazioni della policy vengono definite utilizzando uno stack. Un nuovo livello dello stack viene spinto [pop] quando si entra in una nuova sottodirectory del progetto (con :command:`add_subdirectory`) e ripreso [pop] quando si esce da esso. Pertanto, l'impostazione di una policy in una directory di un progetto non influirà sulle directory padre o di pari livello, ma influirà sulle sottodirectory."

#: ../../source/chapter/Policies.rst:152
msgid ""
"This is useful when a project contains subprojects that are maintained "
"separately yet built inside the tree. The top-level CMakeLists file in a "
"project may write"
msgstr "Ciò è utile quando un progetto contiene sottoprogetti che vengono mantenuti separatamente ma creati all'interno dell'albero. Il file CMakeLists di primo livello in un progetto può essere"

#: ../../source/chapter/Policies.rst:168
msgid "while the ``OtherProject/CMakeLists.txt`` file contains"
msgstr "mentre il file ``OtherProject/CMakeLists.txt`` contiene"

#: ../../source/chapter/Policies.rst:176
msgid ""
"This allows a project to be updated to CMake 2.6 while subprojects, "
"modules, and included files continue to build with CMake 2.4 until their "
"maintainers update them."
msgstr "Ciò consente di aggiornare un progetto a CMake 2.6 mentre i sottoprogetti, i moduli e i file inclusi continuano a essere compilati con CMake 2.4 fino a quando i manutentori non li aggiornano."

#: ../../source/chapter/Policies.rst:180
msgid ""
"User code may use the :command:`cmake_policy` command to push and pop its"
" own stack levels as long as every push is paired with a pop. This is "
"useful when temporarily requesting different behavior for a small section"
" of code. For example, policy :policy:`CMP0003` removes extra link "
"directories that used to be included when new behavior is used. When "
"incrementally updating a project, it may be difficult to build a "
"particular target with the remaining targets being OK. The code"
msgstr "Il codice utente può utilizzare il comando :command:`cmake_policy` per eseguire il push e il pop dei propri livelli di stack purché ogni push sia associato a un pop. Questo è utile quando si richiede temporaneamente un comportamento diverso per una piccola sezione di codice. Ad esempio, policy :policy:`CMP0003` rimuove i link alle directory extra che venivano incluse quando veniva utilizzato un nuovo comportamento. Quando si aggiorna in modo incrementale un progetto, potrebbe essere difficile creare un target particolare con i target rimanenti OK. Il codice"

#: ../../source/chapter/Policies.rst:198
msgid ""
"will silence the warning and use the old behavior for that target. You "
"can get a list of policies and help on specific policies by running CMake"
" from the command line as follows"
msgstr "silenzierà il warning e utilizzerà il vecchio comportamento per quel target. È possibile ottenere un elenco di policy e l'help su policy specifiche eseguendo CMake dalla riga di comando in questo modo"

#: ../../source/chapter/Policies.rst:209
msgid "Updating a Project For a New Version of CMake"
msgstr "Aggiornamento di un Progetto per una Nuova Versione di CMake"

#: ../../source/chapter/Policies.rst:211
msgid ""
"When a CMake release introduces new policies, it may generate warnings "
"for some existing projects. These warnings indicate that changes to a "
"project may be necessary for dealing with the new policies. While old "
"releases of a project can continue to build with the warnings, the "
"project development tree should be updated to take the new policies into "
"account. There are two approaches to updating a tree: one-shot and "
"incremental. The question of which one is easier depends on the size of "
"the project and which new policies produce warnings."
msgstr "Quando una versione di CMake introduce nuove policy, potrebbe generare dei warning per alcuni progetti esistenti. Tali warning indicano che potrebbero essere necessarie modifiche a un progetto per gestire le nuove policy. Sebbene le vecchie versioni di un progetto possano continuare a essere compilate con i warning, l'albero di sviluppo del progetto dovrebbe essere aggiornato per tenere conto delle nuove policy. Esistono due approcci per l'aggiornamento di un albero: one-shot e incrementale. La questione di quale sia più facile dipende dalle dimensioni del progetto e da quali nuove policy producono warning."

#: ../../source/chapter/Policies.rst:221
msgid "The One-Shot Approach"
msgstr "L'Approccio One-Shot"

#: ../../source/chapter/Policies.rst:223
msgid ""
"The simplest approach to updating a project for a new version of CMake is"
" simply to change the policy version which is set at the top of the "
"project. Then, try building with the new CMake version to fix problems. "
"For example, to update a project to build with CMake 3.20, one might "
"write"
msgstr "L'approccio più semplice all'aggiornamento di un progetto per una nuova versione di CMake consiste semplicemente nel modificare la versione della policy impostata all'inizio del progetto. Poi, si prova a compilare con la nuova versione di CMake per risolvere i problemi. Ad esempio, per aggiornare un progetto da compilare con CMake 3.20, si potrebbe scrivere"

#: ../../source/chapter/Policies.rst:236
msgid ""
"at the beginning of the top-level CMakeLists file. This tells CMake to "
"use the new behavior for every policy introduced in CMake 3.20 and below."
" When building this project with CMake 3.20, no warnings will be produced"
" regarding policies because it knows that no policies were introduced in "
"later versions. However, if the project was depending on the old policy "
"behavior, it may not build since CMake is now using the new behavior "
"without warning. It is up to the project author who added the policy "
"version line to fix these issues."
msgstr "all'inizio del file CMakeLists di primo livello. Ciò indica a CMake di utilizzare il nuovo comportamento per ogni policy introdotta in CMake 3.20 e versioni precedenti. Durante la build di questo progetto con CMake 3.20, non verranno prodotti warning relativi alle policy perché sa che non sono stati introdotte policy nelle versioni successive. Tuttavia, se il progetto dipendeva dal vecchio comportamento della policy, potrebbe non essere compilato poiché CMake ora utilizza il nuovo comportamento senza warning. Spetta all'autore del progetto che ha aggiunto la riga della versione della policy risolvere questi problemi."

#: ../../source/chapter/Policies.rst:246
msgid "The Incremental Approach"
msgstr "L'Approccio Incrementale"

#: ../../source/chapter/Policies.rst:248
msgid ""
"Another approach to updating a project for a new version of CMake is to "
"deal with each warning one-by-one. One advantage of this approach is that"
" the project will continue to build throughout the process, so the "
"changes can be made incrementally."
msgstr "Un altro approccio all'aggiornamento di un progetto per una nuova versione di CMake consiste nel gestire ogni warning uno per uno. Un vantaggio di questo approccio è che il progetto continuerà a compilarsi durante tutto il processo, quindi le modifiche possono essere apportate in modo incrementale."

#: ../../source/chapter/Policies.rst:253
msgid ""
"When CMake encounters a situation where it needs to know whether to use "
"the old or new behavior for a policy, it checks whether the project has "
"set the policy. If the policy is set, CMake silently uses the "
"corresponding behavior. If the policy is not set, CMake uses the old "
"behavior but warns the author that the policy is not set."
msgstr "Quando CMake incontra una situazione in cui deve sapere se utilizzare il vecchio o il nuovo comportamento per una policy, controlla se il progetto ha impostato la policy. Se la policy è impostata, CMake usa tacitamente il comportamento corrispondente. Se la policy non è impostata, CMake utilizza il vecchio comportamento ma avverte l'autore che la policy non è impostata."

#: ../../source/chapter/Policies.rst:259
msgid ""
"In many cases, a warning message will point to the exact line of code in "
"the CMakeLists files that caused the warning. In some cases, the "
"situation cannot be diagnosed until CMake is generating the native build "
"system rules for the project, so the warning will not include explicit "
"context information. In these cases, CMake will try to provide some "
"information about where code may need to be changed. The documentation "
"for these \"generation-time\" policies should indicate the point in the "
"project code where the policy should be set to take effect."
msgstr "In molti casi, un warning indicherà l'esatta riga di codice nei file CMakeLists che l'ha causato. In alcuni casi, la situazione non può essere diagnosticata fino a quando CMake non genera le regole del sistema di build nativo per il progetto, pertanto il warning non includerà informazioni esplicite del contesto. In questi casi, CMake proverà a fornire alcune informazioni su dove potrebbe essere necessario modificare il codice. La documentazione per queste policy della \"generation-time\" dovrebbe indicare il punto nel codice del progetto in cui la policy dovrebbe essere impostata per avere effetto."

#: ../../source/chapter/Policies.rst:269
msgid ""
"In order to incrementally update a project, one warning should be "
"addressed at a time. Several cases may occur, as described below."
msgstr "Per aggiornare in modo incrementale un progetto, è necessario affrontare un warning alla volta. Possono verificarsi diversi casi, come descritto di seguito."

#: ../../source/chapter/Policies.rst:273
msgid "Silence a Warning When the Code is Correct"
msgstr "Tacitare un Warning Quando il Codice è Corretto"

#: ../../source/chapter/Policies.rst:275
msgid ""
"Many policy warnings may be produced simply because the project has not "
"set the policy even though the project may work correctly with the new "
"behavior (there is no way for CMake to know the difference). For a "
"warning about some policy, ``CMP<NNNN>``, you can check whether this is "
"the case by adding"
msgstr "Molti warning di policy possono essere prodotti semplicemente perché il progetto non ha impostato la policy anche se il progetto potrebbe funzionare correttamente con il nuovo comportamento (non c'è modo per CMake di conoscere la differenza). Per un warning su alcuni criteri, ``CMP<NNNN>``, si può controllare se questo è il caso aggiungendo"

#: ../../source/chapter/Policies.rst:288
msgid ""
"to the top of the project and trying to build it. If the project builds "
"correctly with the new behavior, move on to the next policy warning. If "
"the project does not build correctly, one of the other cases may apply."
msgstr "all'inizio del progetto e cercando di compilarlo. Se il progetto viene compilato correttamente con il nuovo comportamento, si passa al warning della policy successivo. Se il progetto non viene compilato correttamente, potrebbe applicarsi uno degli altri casi."

#: ../../source/chapter/Policies.rst:294
msgid "Silence a Warning Without Updating the Code"
msgstr "Tacitare un Warning Senza Aggiornare il Codice"

#: ../../source/chapter/Policies.rst:296
msgid "Users can suppress all instances of a warning ``CMP<NNNN>`` by adding"
msgstr "Gli utenti possono sopprimere tutte le istanze di un warning ``CMP<NNNN>`` aggiungendo"

#: ../../source/chapter/Policies.rst:305
msgid ""
"to the top of a project. However, we encourage project authors to update "
"their code to work with the new behavior for all policies. This is "
"especially important because versions of CMake in the (distant) future "
"may remove support for old behaviors and produce an error for projects "
"requesting them (which tells the user to get an older versions of CMake "
"to build the project)."
msgstr "all'inizio del progetto. Tuttavia, incoraggiamo gli autori del progetto ad aggiornare il codice in modo che funzioni con il nuovo comportamento per tutte le policy. Ciò è particolarmente importante perché le versioni di CMake nel (lontano) futuro potrebbero rimuovere il supporto per i vecchi comportamenti e produrre un errore per i progetti che li richiedono (che indica all'utente di ottenere una versione precedente di CMake per creare il progetto)."

#: ../../source/chapter/Policies.rst:313
msgid "Silence a Warning by Updating Code"
msgstr "Tacitare i Warning Aggiornando il Codice"

#: ../../source/chapter/Policies.rst:315
msgid ""
"When a project does not work correctly with the NEW behaviors for a "
"policy, the code needs to be updated. In order to deal with a warning for"
" some policy ``CMP<NNNN>``,add"
msgstr "Quando un progetto non funziona correttamente con i NUOVI comportamenti per una policy, il codice deve essere aggiornato. Per gestire un warning per alcuni criteri ``CMP<NNNN>``, si aggiunge"

#: ../../source/chapter/Policies.rst:326
msgid ""
"to the top of the project and then fix the code to work with the NEW "
"behavior."
msgstr "all'inizio del progetto e poi si corregge il codice in modo che funzioni con il NUOVO comportamento."

#: ../../source/chapter/Policies.rst:329
msgid ""
"If many instances of the warning occur fixing all of them simultaneously "
"may be too difficult: instead, a developer may fix them one at a time by "
"using the PUSH/POP signatures of the :command:`cmake_policy` command::"
msgstr "Se si verificano molte istanze del warning, correggerle tutte contemporaneamente potrebbe essere troppo difficile: invece, uno sviluppatore può correggerle una alla volta utilizzando le firme PUSH/POP del comando :command:`cmake_policy`::"

#: ../../source/chapter/Policies.rst:339
msgid ""
"This will request the new behavior for a small region of code that has "
"been fixed. Other instances of the policy warning may still appear and "
"must be fixed separately."
msgstr "Ciò richiederà il nuovo comportamento per una piccola area di codice che sia stata corretta. Altre istanze del warning sulle policy potrebbero ancora essere visualizzate e devono essere risolte separatamente."

#: ../../source/chapter/Policies.rst:344
msgid "Updating the Project Policy Version"
msgstr "Aggiornamento della Versione della Policy del Progetto"

#: ../../source/chapter/Policies.rst:346
msgid ""
"After addressing all policy warnings and getting the project to build "
"cleanly with the new CMake version one step remains. The policy version "
"set at the top of the project should now be updated to match the new "
"CMake version, just as in the one-shot approach described above. For "
"example, after updating a project to build cleanly with CMake 3.20, users"
" may update the top of the project with the line"
msgstr "Dopo aver risolto tutti i warning relativi alle policy e ottenuto che il progetto venga compilato in modo pulito con la nuova versione di CMake, rimane un passaggio. La versione della policy impostata all'inizio del progetto dovrebbe ora essere aggiornata in modo che corrisponda alla nuova versione di CMake, proprio come nell'approccio one-shot precedente. Ad esempio, dopo aver aggiornato un progetto per creare in modo pulito con CMake 3.20, gli utenti possono aggiornare la parte iniziale del progetto con la riga"

#: ../../source/chapter/Policies.rst:360
msgid ""
"This will set all policies introduced in CMake 3.20 or below to use the "
"new behavior. Then users may sweep through the rest of the code and "
"remove the calls that use the :command:`cmake_policy` command to request "
"the new behavior incrementally. The end result should look the same as "
"the one-shot approach, but could be attained step-by-step."
msgstr "Questo imposterà tutti i criteri introdotti in CMake 3.20 o versioni precedenti per utilizzare il nuovo comportamento. Gli utenti, poi, possono esaminare il resto del codice e rimuovere le chiamate che utilizzano il comando :command:`cmake_policy` per richiedere il nuovo comportamento in modo incrementale. Il risultato finale dovrebbe essere lo stesso dell'approccio one-shot, ma potrebbe essere raggiunto passo dopo passo."

#: ../../source/chapter/Policies.rst:370
msgid "Supporting Multiple CMake Versions"
msgstr "Supporto di Versioni Multiple di CMake"

#: ../../source/chapter/Policies.rst:372
msgid ""
"Some projects might want to support a few releases of CMake "
"simultaneously. The goal is to build with an older version, while also "
"working with newer versions without warnings. In order to support both "
"CMake 2.4 and 2.6, one may write code like"
msgstr "Alcuni progetti potrebbero voler supportare contemporaneamente alcune versioni di CMake. L'obiettivo è compilare con una versione precedente, lavorando anche con versioni più recenti senza warning. Per supportare sia CMake 2.4 che 2.6, è possibile scrivere codice come"

#: ../../source/chapter/Policies.rst:392
msgid ""
"This will set the policies to build with CMake 2.6 and to ignore them for"
" CMake 2.4. In order to support both CMake 2.6 and some policies of CMake"
" 2.8, one may write code like:"
msgstr "Questo imposterà le policy per la compilazione con CMake 2.6 e per ignorarli per CMake 2.4. Per supportare sia CMake 2.6 che alcune policy di CMake 2.8, è possibile scrivere codice come:"

#: ../../source/chapter/Policies.rst:404
msgid ""
"This will set the policies to build with CMake 2.8 and to ignore them for"
" CMake 2.6. If it is known that the project builds with both CMake 2.6 "
"and CMake 2.8's new policies users may write:"
msgstr "Questo imposterà le policy per la compilazione con CMake 2.8 e per ignorarli per CMake 2.6. Se è noto che il progetto viene compilato con le nuove policy di CMake 2.6 e CMake 2.8, gli utenti possono scrivere:"

#: ../../source/chapter/Policies.rst:420
msgid "Checking Versions of CMake"
msgstr "Controllo delle Versioni di CMake"

#: ../../source/chapter/Policies.rst:422
msgid ""
"CMake is an evolving program and as new versions are released, new "
"features or commands are introduced. As a result, there may be instances "
"where you might want to use a command that is in a current version of "
"CMake but not in previous versions. There are a couple of ways to handle "
"this; one option is to use the :command:`if` command to check whether a "
"new command exists. For example:"
msgstr "CMake è un programma in evoluzione e man mano che vengono rilasciate nuove versioni, vengono introdotte nuove funzionalità o comandi. Di conseguenza, potrebbero esserci casi in cui si potrebbe voler utilizzare un comando che si trova in una versione corrente di CMake ma non nelle versioni precedenti. Ci sono un paio di modi per gestirlo; un'opzione è usare il comando  :command:`if` per controllare se esiste un nuovo comando. Per esempio:"

#: ../../source/chapter/Policies.rst:437
msgid ""
"Alternatively, one may test against the actual version of CMake that is "
"being run by evaluating the :variable:`CMAKE_VERSION` variable:"
msgstr "In alternativa, è possibile testare la versione effettiva di CMake in esecuzione valutando la variabile :variable:`CMAKE_VERSION`:"

#: ../../source/chapter/Policies.rst:447
msgid ""
"Finally, some new releases of CMake might no longer support some behavior"
" you were using (although we try to avoid this). In these cases, use "
"CMake policies, as discussed in the :manual:`cmake-policies <cmake-"
"policies(7)>` manual."
msgstr "Infine, alcune nuove versioni di CMake potrebbero non supportare più alcuni comportamenti utilizzati (sebbene cerchiamo di evitarlo). In questi casi, si utilizzano le politiche di CMake, come discusso nel manuale :manual:`cmake-policies <cmake-policies(7)>`."

#: ../../source/chapter/System Inspection.rst:4
msgid ""
"This chapter will describe how to use CMake to inspect the environment of"
" the system where the software is being built. This is a critical factor "
"in creating cross-platform applications or libraries. It covers how to "
"find and use system and user installed header files and libraries. It "
"also covers some of the more advanced features of CMake, including the "
":command:`try_compile` and :command:`try_run` commands. These commands "
"are extremely powerful tools for determining the capabilities of the "
"system and compiler that is hosting your software."
msgstr "Questo capitolo descriverà come utilizzare CMake per ispezionare l'ambiente del sistema in cui viene creato il software. Questo è un fattore critico nella creazione di applicazioni o librerie multipiattaforma. Descrive come trovare e utilizzare i file header e le librerie installati dal sistema e dall'utente. Copre anche alcune delle funzionalità più avanzate di CMake, inclusi i comandi  :command:`try_compile` e :command:`try_run`. Questi comandi sono strumenti estremamente potenti per determinare le capacità del sistema e del compilatore che ospita il software."

#: ../../source/chapter/System Inspection.rst:14
msgid "Using Header Files and Libraries"
msgstr "Utilizzo di File Header e Librerie"

#: ../../source/chapter/System Inspection.rst:16
msgid ""
"Many C and C++ programs depend on external libraries; however, when it "
"comes to the practical aspects of compiling and linking a project, taking"
" advantage of existing libraries can be difficult for both developers and"
" users. Problems typically show up as soon as the software is built on a "
"system other than the one on which it was developed. Assumptions "
"regarding where libraries and header files are located become obvious "
"when they are not installed in the same place on the new computer and the"
" build system is unable to find them. CMake has many features to aid "
"developers in the integration of external software libraries into a "
"project."
msgstr "Molti programmi C e C++ dipendono da librerie esterne; tuttavia, quando si tratta degli aspetti pratici della compilazione e del link di un progetto, sfruttare le librerie esistenti può risultare difficile sia per gli sviluppatori che per gli utenti. I problemi in genere si manifestano non appena il software viene costruito su un sistema diverso da quello su cui è stato sviluppato. I presupposti relativi alla posizione delle librerie e dei file header diventano palesi quando non sono installati nella stessa posizione sul nuovo computer e il sistema di build non è in grado di trovarli. CMake ha molte funzionalità per aiutare gli sviluppatori nell'integrazione di librerie software esterne in un progetto."

#: ../../source/chapter/System Inspection.rst:27
msgid ""
"The CMake commands that are most relevant to this type of integration are"
" the :command:`find_file`, :command:`find_library`, :command:`find_path`,"
" :command:`find_program`, and :command:`find_package` commands. For most "
"C and C++ libraries, a combination of :command:`find_library` and "
":command:`find_path` will be enough to compile and link with an installed"
" library. The command :command:`find_library` can be used to locate, or "
"allow a user to locate a library, and :command:`find_path` can be used to"
" find the path to a representative include file from the project. For "
"example, if you wanted to link to the tiff library, you could use the "
"following commands in your CMakeLists.txt file"
msgstr "I comandi CMake più rilevanti per questo tipo di integrazione sono :command:`find_file`, :command:`find_library`, :command:`find_path`, :command:`find_program` e :command:`find_package`. Per la maggior parte delle librerie C e C++, una combinazione di :command:`find_library` e :command:`find_path` sarà sufficiente per compilare e linkare una libreria installata. Il comando :command:`find_library` è utilizzabile per individuare o consentire a un utente di individuare una libreria e :command:`find_path` può essere utilizzato per trovare il path di un file include rappresentativo del progetto. Ad esempio, volendo linkare la libreria tiff, si possono utilizzare i seguenti comandi nel file CMakeLists.txt"

#: ../../source/chapter/System Inspection.rst:67
msgid ""
"The first command used is :command:`find_library`, which in this case, "
"will look for a library with the name tiff or tiff2. The "
":command:`find_library` command only requires the base name of the "
"library without any platform-specific prefixes or suffixes, such as .lib "
"and .dll. The appropriate prefixes and suffixes for the system running "
"CMake will be added to the library name automatically when CMake attempts"
" to find it. All the ``FIND_*`` commands will look in the ``PATH`` "
"environment variable. In addition, the commands allow the specification "
"of additional search paths as arguments to be listed after the ``PATHS`` "
"marker argument. In addition to supporting standard paths, Windows "
"registry entries and environment variables can be used to construct "
"search paths. The syntax for registry entries is the following::"
msgstr "Il primo comando utilizzato è :command:`find_library`, che in questo caso cercherà una libreria con il nome tiff o tiff2. Il comando :command:`find_library` richiede solo il nome di base della libreria senza prefissi o suffissi specifici della piattaforma, come .lib e .dll. I prefissi e i suffissi appropriati per il sistema che esegue CMake verranno aggiunti automaticamente al nome della libreria quando CMake la cerca. Tutti i comandi ``FIND_*`` cercheranno nella variabile d'ambiente ``PATH``. Inoltre, i comandi consentono di specificare ulteriori path di ricerca come argomenti da elencare dopo l'argomento marcatore ``PATHS``. Oltre a supportare i path standard, le voci di registro di Windows e le variabili di ambiente possono essere utilizzate per creare path di ricerca. La sintassi per le voci di registro è la seguente::"

#: ../../source/chapter/System Inspection.rst:86
msgid ""
"Since software can be installed in many different places, it is "
"impossible for CMake to find the library every time, but most standard "
"installations should be covered. The ``find_*`` commands automatically "
"create a cache variable so that users can override or specify the "
"location from the CMake GUI. This way, if CMake is unable to locate the "
"files it is looking for, users will still have an opportunity to specify "
"them. If CMake does not find a file, the value is set to ``VAR-"
"NOTFOUND``; this value tells CMake that it should continue looking each "
"time CMake's configure step is run. Note that in if statements, values of"
" ``VAR-NOTFOUND`` will evaluate as false."
msgstr "Poiché il software può essere installato in molti luoghi diversi, è impossibile per CMake trovare la libreria ogni volta, ma la maggior parte delle installazioni standard dovrebbe essere coperta. I comandi ``find_*`` creano automaticamente una variabile di cache in modo che gli utenti possano sovrascrivere o specificare la posizione dalla GUI di CMake. In questo modo, se CMake non è in grado di individuare i file che sta cercando, gli utenti avranno comunque la possibilità di specificarli. Se CMake non trova un file, il valore viene impostato su ``VAR-NOTFOUND``; questo valore indica a CMake che dovrebbe continuare a cercare ogni volta che viene eseguito il passaggio di configurazione di CMake. Notare che nelle istruzioni if, i valori di ``VAR-NOTFOUND`` saranno valutati come falsi."

#: ../../source/chapter/System Inspection.rst:97
msgid ""
"The next command used is :command:`find_path`, a general purpose command "
"that, in this example, is used to locate a header file from the library. "
"Header files and libraries are often installed in different locations, "
"and both locations are required to compile and link programs that use "
"them. The use of :command:`find_path` is similar to "
":command:`find_library`, although it only supports one name, a list of "
"search paths."
msgstr "Il comando successivo utilizzato è :command:`find_path`, un comando generico che, in questo esempio, viene utilizzato per individuare un file header dalla libreria. I file header e le librerie sono spesso installati in posizioni diverse ed entrambe le posizioni sono necessarie per compilare e linkare i programmi che li utilizzano. L'uso di :command:`find_path` è simile a :command:`find_library`, sebbene supporti solo un nome, un elenco di path di ricerca."

#: ../../source/chapter/System Inspection.rst:105
msgid ""
"The remainder of the CMakeLists file may use the variables created by the"
" ``find_*`` commands. The variables can be used without checking for "
"valid values, as CMake will print an error message notifying the user if "
"any of the required variables have not been set. The user can then set "
"the cache values and reconfigure until the message goes away. Optionally,"
" a CMakeLists file could use the :command:`if` command to use alternative"
" libraries or options to build the project without the library if it "
"cannot be found."
msgstr "Il resto del file CMakeLists può utilizzare le variabili create dai comandi ``find_*``. Le variabili possono essere utilizzate senza controllare che i valori siano validi, poiché CMake stamperà un messaggio di errore che notifica all'utente se una qualsiasi delle variabili richieste non è stata impostata. L'utente può poi impostare i valori della cache e riconfigurare finché il messaggio non scompare. Facoltativamente, un file CMakeLists potrebbe utilizzare il comando :command:`if` per utilizzare librerie o opzioni alternative per creare il progetto se non è possibile trovare la libreria."

#: ../../source/chapter/System Inspection.rst:114
msgid ""
"From the above example you can see how using the ``find_*`` commands can "
"help your software compile on a variety of systems. It is worth noting "
"that the ``find_*`` commands search for a match starting with the first "
"argument and first path, so when listing paths and library names, list "
"your preferred paths and names first. If there are multiple versions of a"
" library and you would prefer tiff over tiff2, make sure they are listed "
"in that order."
msgstr "Dall'esempio sopra vede come l'uso dei comandi ``find_*`` può aiutare il software a compilare su una varietà di sistemi. Vale la pena notare che i comandi ``find_*`` cercano una corrispondenza che inizia con il primo argomento e il primo path, quindi quando si elencano path e nomi di librerie, si devono elencare prima i path e nomi preferiti. Se ci sono più versioni di una libreria e si preferisce tiff a tiff2, devono essere elencate in tale ordine."

#: ../../source/chapter/System Inspection.rst:123
msgid "System Properties"
msgstr "Proprietà di Sistema"

#: ../../source/chapter/System Inspection.rst:129
msgid ""
"Although it is a common practice in C and C++ code to add platform-"
"specific code inside preprocessor ``ifdef`` directives, for maximum "
"portability this should be avoided. Software should not be tuned to "
"specific platforms with ``ifdefs``, but rather to a canonical system "
"consisting of a set of features. Coding to specific systems makes the "
"software less portable, because systems and the features they support "
"change with time, and even from system to system. A feature that may not "
"have worked on a platform in the past may be a required feature for the "
"platform in the future. The following code fragments illustrate the "
"difference between coding to a canonical system and a specific system:"
msgstr "Sebbene sia una pratica comune nel codice C e C++ aggiungere codice specifico della piattaforma all'interno delle direttive ``ifdef`` del preprocessore, per la massima portabilità questo dovrebbe essere evitato. Il software non dovrebbe essere adattato a piattaforme specifiche con ``ifdefs``, ma piuttosto su un sistema canonico costituito da un insieme di funzionalità. La codifica per sistemi specifici rende il software meno portabile, perché i sistemi e le funzionalità che supportano cambiano nel tempo e persino da sistema a sistema. Una funzionalità che potrebbe non aver funzionato su una piattaforma in passato potrebbe essere una funzionalità necessaria in futuro. I seguenti frammenti di codice illustrano la differenza tra la codifica in un sistema canonico e un sistema specifico:"

#: ../../source/chapter/System Inspection.rst:157
msgid ""
"The problem with the second approach is that the code will have to be "
"modified for each new platform on which the software is compiled. For "
"example, a future version of SUN may no longer have the foobar call. "
"Using the ``HAS_FOOBAR_CALL`` approach, the software will work as long as"
" ``HAS_FOOBAR_CALL`` is defined correctly, and this is where CMake can "
"help. CMake can be used to define ``HAS_FOOBAR_CALL`` correctly and "
"automatically by making use of the :command:`try_compile` and "
":command:`try_run` commands. These commands can be used to compile and "
"run small test programs during the CMake configure step. The test "
"programs will be sent to the compiler that will be used to build the "
"project, and if errors occur, the feature can be disabled. These commands"
" require that you write a small C or C++ program to test the feature. For"
" example, to test if the ``foobar`` call is provided on the system, try "
"compiling a simple program that uses ``foobar``. First write the simple "
"test program (testNeedFoobar.c in this example) and then add the CMake "
"calls to the CMakeLists file to try compiling that code. If the "
"compilation works then ``HAS_FOOBAR_CALL`` will be set to true."
msgstr "Il problema con il secondo approccio è che il codice dovrà essere modificato per ogni nuova piattaforma su cui viene compilato il software. Ad esempio, una versione futura di SUN potrebbe non avere più la chiamata foobar. Utilizzando l'approccio ``HAS_FOOBAR_CALL``, il software funzionerà fintanto che ``HAS_FOOBAR_CALL`` è definito correttamente, ed è qui che CMake può aiutare. CMake può essere utilizzato per definire ``HAS_FOOBAR_CALL`` correttamente e automaticamente utilizzando i comandi :command:`try_compile` e :command:`try_run`. Questi comandi possono essere utilizzati per compilare ed eseguire piccoli programmi di test durante la fase di configurazione di CMake. I programmi di test verranno inviati al compilatore che verrà utilizzato per buildare il progetto e, se si verificano errori, la funzionalità può essere disabilitata. Questi comandi richiedono la scrittura di un piccolo programma C o C++ per testare la funzionalità. Ad esempio, per verificare se la chiamata ``foobar`` è presente sul sistema, si prova a compilare un semplice programma che utilizza ``foobar``. Prima si scrive il programmino di test (testNeedFoobar.c in questo esempio) e poi si aggiungono le chiamate CMake al file CMakeLists per provare a compilare quel codice. Se la compilazione funziona allora ``HAS_FOOBAR_CALL`` sarà impostato su true."

#: ../../source/chapter/System Inspection.rst:195
msgid ""
"Now that ``HAS_FOOBAR_CALL`` is set correctly in CMake, you can use it in"
" your source code through the :command:`target_compile_definitions` "
"command. Alternatively, it is possible to configure a header file. This "
"is discussed further in the section called :ref:`configure_header`."
msgstr "Ora che ``HAS_FOOBAR_CALL`` è impostato correttamente in CMake, lo si può utilizzare nel codice sorgente tramite il comando :command:`target_compile_definitions`. In alternativa, è possibile configurare un file header. Questo è discusso ulteriormente nella sezione chiamata :ref:`configure_header`."

#: ../../source/chapter/System Inspection.rst:200
msgid ""
"Sometimes compiling a test program is not enough. In some cases, you may "
"actually want to compile and run a program to get its output. A good "
"example of this is testing the byte order of a machine. The following "
"example shows how to write a small program that CMake will compile and "
"run to determine the byte order of a machine."
msgstr "A volte la compilazione di un programma di test non è sufficiente. In alcuni casi, si potrebbe effettivamente voler compilare ed eseguire un programma per ottenerne l'output. Un buon esempio di ciò è testare l'ordine dei byte di una macchina. L'esempio seguente mostra come scrivere un piccolo programma che CMake compilerà ed eseguirà per determinare l'ordine dei byte di una macchina."

#: ../../source/chapter/System Inspection.rst:232
msgid ""
"The return result of the run will go into ``RUN_RESULT_VAR``, the result "
"of the compile will go into ``COMPILE_RESULT_VAR``, and any output from "
"the run will go into ``OUTPUT``. You can use these variables to report "
"debug information to the users of your project."
msgstr "Il risultato restituito dell'esecuzione andrà in ``RUN_RESULT_VAR``, il risultato della compilazione andrà in ``COMPILE_RESULT_VAR`` e qualsiasi output dell'esecuzione andrà in ``OUTPUT``. Si possono utilizzare queste variabili per segnalare informazioni di debug agli utenti del progetto."

#: ../../source/chapter/System Inspection.rst:237
msgid ""
"For small test programs the :command:`file` command with the ``WRITE`` "
"option can be used to create the source file from the CMakeLists file. "
"The following example tests the C compiler to verify that it can be run."
msgstr "Per piccoli programmi di test, il comando :command:`file` con l'opzione ``WRITE`` può essere utilizzato per creare il file sorgente dal file CMakeLists. L'esempio seguente verifica che il compilatore C possa essere eseguito."

#: ../../source/chapter/System Inspection.rst:254
msgid ""
"For more advanced :command:`try_compile` and :command:`try_run` "
"operations, it may be desirable to pass flags to the compiler or to "
"CMake. Both commands support the optional arguments ``CMAKE_FLAGS`` and "
"``COMPILE_DEFINITIONS``. ``CMAKE_FLAGS`` can be used to pass "
"``-DVAR:TYPE=VALUE`` flags to CMake. The value of ``COMPILE_DEFINITIONS``"
" is passed directly to the compiler command line."
msgstr "Per operazioni :command:`try_compile` e :command:`try_run` più avanzate, potrebbe essere desiderabile passare i flag al compilatore o a CMake. Entrambi i comandi supportano gli argomenti facoltativi ``CMAKE_FLAGS`` e ``COMPILE_DEFINITIONS``. ``CMAKE_FLAGS`` può essere utilizzato per passare i flag ``-DVAR:TYPE=VALUE`` a CMake. Il valore di ``COMPILE_DEFINITIONS`` viene passato direttamente alla riga di comando del compilatore."

#: ../../source/chapter/System Inspection.rst:262
msgid ""
"There are several predefined try-run and try-compile modules available in"
" CMake :manual:`cmake-modules(7)`, some of which are listed below. These "
"modules allow some common checks to be performed without having to create"
" a source file for each test. Many of these modules will look at the "
"current value of the ``CMAKE_REQUIRED_FLAGS`` and "
"``CMAKE_REQUIRED_LIBRARIES`` variables to add additional compile flags or"
" link libraries to the test."
msgstr "Sono disponibili diversi moduli try-run e try-compile predefiniti in CMake :manual:`cmake-modules(7)`, alcuni dei quali sono elencati di seguito. Questi moduli consentono di eseguire alcuni controlli comuni senza dover creare un file sorgente per ogni test. Molti di questi moduli esamineranno il valore corrente delle variabili ``CMAKE_REQUIRED_FLAGS`` e ``CMAKE_REQUIRED_LIBRARIES`` per aggiungere ulteriori flag di compilazione o link di librerie al test."

#: ../../source/chapter/System Inspection.rst:275
msgid ":module:`CheckIncludeFile`"
msgstr ":module:`CheckIncludeFile`"

#: ../../source/chapter/System Inspection.rst:271
msgid ""
"Provides a macro that checks for an include file on a system by taking "
"two arguments with first being the include file to look for and the "
"second being the variable to store the result into. Additional CFlags can"
" be passed in as a third argument or by setting ``CMAKE_REQUIRED_FLAGS``."
msgstr "Fornisce una macro che verifica la presenza di un file di inclusione su un sistema prendendo due argomenti, il primo è il file di inclusione da cercare e il secondo è la variabile in cui archiviare il risultato. CFlag aggiuntivi possono essere passati come terzo argomento o impostando ``CMAKE_REQUIRED_FLAGS``."

#: ../../source/chapter/System Inspection.rst:281
msgid ":module:`CheckIncludeFileCXX`"
msgstr ":module:`CheckIncludeFileCXX`"

#: ../../source/chapter/System Inspection.rst:278
msgid ""
"Provides a macro that checks for an include file in a C++ program by "
"taking two arguments with the first being the include file to look for "
"and the second being the variable to store the result into. Additional "
"CFlags can be passed in as a third argument."
msgstr "Fornisce una macro che verifica la presenza di un file di inclusione in un programma C++ prendendo due argomenti, il primo è il file di inclusione da cercare e il secondo è la variabile in cui memorizzare il risultato. CFlag aggiuntivi possono essere passati come terzo argomento."

#: ../../source/chapter/System Inspection.rst:287
msgid ":module:`CheckIncludeFiles`"
msgstr ":module:`CheckIncludeFiles`"

#: ../../source/chapter/System Inspection.rst:284
msgid ""
"Provides a macro that checks if the given header files can be include "
"together. This macro uses ``CMAKE_REQUIRED_FLAGS`` if it is set, and is "
"useful when a header file you are interested in checking for is dependent"
" on including another header file first."
msgstr "Fornisce una macro che verifica se i file header specificati possono essere inclusi insieme. Questa macro utilizza ``CMAKE_REQUIRED_FLAGS`` se è impostata ed è utile quando un file header che interessa controllare dipende dall'inclusione precedente di un altro file header."

#: ../../source/chapter/System Inspection.rst:296
msgid ":module:`CheckLibraryExists`"
msgstr ":module:`CheckLibraryExists`"

#: ../../source/chapter/System Inspection.rst:290
msgid ""
"Provides a macro that checks to see if a library exists by taking four "
"arguments with the first being the name of the library to check for; the "
"second being the name of a function that should be in that library; the "
"third argument being the location of where the library should be found; "
"and the fourth argument being a variable to store the result into. This "
"macro uses ``CMAKE_REQUIRED_FLAGS`` and ``CMAKE_REQUIRED_LIBRARIES`` if "
"they are set."
msgstr "Fornisce una macro che controlla se esiste una libreria prendendo quattro argomenti, il primo dei quali è il nome della libreria da controllare; il secondo è il nome di una funzione che dovrebbe essere in quella libreria; il terzo argomento è la posizione in cui dovrebbe essere trovata la libreria; e il quarto argomento è una variabile in cui memorizzare il risultato. Questa macro utilizza ``CMAKE_REQUIRED_FLAGS`` e ``CMAKE_REQUIRED_LIBRARIES`` se sono impostate."

#: ../../source/chapter/System Inspection.rst:304
msgid ":module:`CheckSymbolExists`"
msgstr ":module:`CheckSymbolExists`"

#: ../../source/chapter/System Inspection.rst:299
msgid ""
"Provides a macro that checks to see if a symbol is defined in a header "
"file by taking three arguments with the first being the symbol to look "
"for; the second argument being a list of header files to try including; "
"and the third argument being where the result is stored. This macro uses "
"``CMAKE_REQUIRED_FLAGS`` and ``CMAKE_REQUIRED_LIBRARIES`` if they are "
"set."
msgstr "Fornisce una macro che verifica se un simbolo è definito in un file header prendendo tre argomenti, il primo dei quali è il simbolo da cercare; il secondo argomento è un elenco di file header da provare a includere; e il terzo argomento è dove è memorizzato il risultato. Questa macro utilizza ``CMAKE_REQUIRED_FLAGS`` e ``CMAKE_REQUIRED_LIBRARIES`` se sono impostate."

#: ../../source/chapter/System Inspection.rst:311
msgid ":module:`CheckTypeSize`"
msgstr ":module:`CheckTypeSize`"

#: ../../source/chapter/System Inspection.rst:307
msgid ""
"Provides a macro that determines the size in bytes of a variable type by "
"taking two arguments with the first argument being the type to evaluate, "
"and the second argument being where the result is stored. Both "
"``CMAKE_REQUIRED_FLAGS`` and ``CMAKE_REQUIRED_LIBRARIES`` are used if "
"they are set."
msgstr "Fornisce una macro che determina la dimensione in byte di un tipo di variabile prendendo due argomenti con il primo argomento che rappresenta il tipo da valutare e il secondo argomento dove viene archiviato il risultato. Sia ``CMAKE_REQUIRED_FLAGS`` e ``CMAKE_REQUIRED_LIBRARIES`` vengono utilizzati se impostati."

#: ../../source/chapter/System Inspection.rst:320
msgid ":module:`CheckVariableExists`"
msgstr ":module:`CheckVariableExists`"

#: ../../source/chapter/System Inspection.rst:314
msgid ""
"Provides a macro that checks to see if a global variable exists by taking"
" two arguments with the first being the variable to look for, and the "
"second argument being the variable to store the result in. This macro "
"will prototype the named variable and then try to use it. If the test "
"program compiles then the variable exists. This will only work for C "
"variables. This macro uses ``CMAKE_REQUIRED_FLAGS`` and "
"``CMAKE_REQUIRED_LIBRARIES`` if they are set."
msgstr "Fornisce una macro che controlla se esiste una variabile globale prendendo due argomenti, il primo è la variabile da cercare e il secondo è la variabile in cui memorizzare il risultato. Questa macro creerà il prototipo della variabile e poi tenterà di utilizzarla. Se il programma di test viene compilato, la variabile esiste. Funziona solo per le variabili C. Questa macro utilizza ``CMAKE_REQUIRED_FLAGS`` e ``CMAKE_REQUIRED_LIBRARIES`` se sono impostate."

#: ../../source/chapter/System Inspection.rst:322
msgid ""
"Consider the following example which shows a variety of these modules "
"being used to compute properties of the platform. At the beginning of the"
" example four modules are loaded from CMake. The remainder of the example"
" uses the macros defined in those modules to test for header files, "
"libraries, symbols, and type sizes respectively."
msgstr "Si consideri l'esempio seguente che mostra una varietà di questi moduli utilizzati per calcolare le proprietà della piattaforma. All'inizio dell'esempio vengono caricati quattro moduli da CMake. Il resto dell'esempio utilizza le macro definite in quei moduli per testare rispettivamente i file header, le librerie, i simboli e le dimensioni dei tipi."

#: ../../source/chapter/System Inspection.rst:380
msgid "How to Pass Parameters to a Compilation"
msgstr "Come Passare i Parametri a una Compilazione"

#: ../../source/chapter/System Inspection.rst:382
msgid ""
"Once you have determined the features of the system in which you are "
"interested, it is time to configure the software based on what has been "
"found. There are two common ways to pass this information to the "
"compiler: on the compile line, or using a pre-configured header. The "
"first way is to pass definitions on the compile line. A preprocessor "
"definition can be passed to the compiler from a CMakeLists file with the "
":command:`target_compile_definitions` command. For example, a common "
"practice in C code is to have the ability to selectively compile in/out "
"debug statements."
msgstr "Una volta determinate le caratteristiche del sistema, è il momento di configurare il software in base a quanto trovato. Esistono due modi comuni per passare queste informazioni al compilatore: sulla riga di compilazione o utilizzando header preconfigurato. Il primo modo consiste nel passare le definizioni sulla riga di compilazione. Una definizione del preprocessore può essere passata al compilatore da un file CMakeLists col comando :command:`target_compile_definitions`. Ad esempio, una pratica comune nel codice C è avere la possibilità di compilare selettivamente istruzioni di debug in/out."

#: ../../source/chapter/System Inspection.rst:398
msgid ""
"A CMake variable could be used to turn on or off debug builds using the "
":command:`option` command:"
msgstr "Una variabile CMake potrebbe essere utilizzata per attivare o disattivare le build di debug utilizzando il comando :command:`option`:"

#: ../../source/chapter/System Inspection.rst:410
msgid ""
"Another example would be to tell the compiler the result of the previous "
"``HAS_FOOBAR_CALL`` test that was discussed earlier in this chapter. You "
"could do this with the following:"
msgstr "Un altro esempio potrebbe essere quello di comunicare al compilatore il risultato del precedente test ``HAS_FOOBAR_CALL`` discusso in precedenza in questo capitolo. Lo si può fare in questo modo:"

#: ../../source/chapter/System Inspection.rst:423
msgid "How to Configure a Header File"
msgstr "Come Configurare un file Header"

#: ../../source/chapter/System Inspection.rst:425
msgid ""
"The second approach for passing definitions to the source code is to "
"configure a header file. The header file will include all of the "
"``#define`` macros needed to build the project. To configure a file with "
"CMake, the :command:`configure_file` command is used. This command "
"requires an input file that is parsed by CMake to produce an output file "
"with all variables expanded or replaced. There are three ways to specify "
"a variable in an input file for :command:`configure_file`."
msgstr "Il secondo approccio per passare le definizioni al codice sorgente consiste nel configurare un file di header. Il file di intestazione includerà tutte le macro ``#define`` necessarie per la build del progetto. Per configurare un file con CMake, viene utilizzato il comando :command:`configure_file`. Questo comando richiede un file di input che viene analizzato da CMake per produrre un file di output con tutte le variabili espanse o sostituite. Ci sono tre modi per specificare una variabile in un file di input per :command:`configure_file`."

#: ../../source/chapter/System Inspection.rst:437
msgid "If VARIABLE is true, then the result will be:"
msgstr "Se VARIABLE è true, allora il risultato sarà:"

#: ../../source/chapter/System Inspection.rst:443
msgid "If VARIABLE is false, then the result will be:"
msgstr "Se VARIABLE è false, allora il risultato sarà:"

#: ../../source/chapter/System Inspection.rst:449
msgid ""
"When writing a file to be configured, consider using ``@VARIABLE@`` "
"instead of ``${VARIABLE}`` for variables that are expected to be expanded"
" by CMake. Since the  ``${}`` syntax  is commonly used by other "
"languages, users can tell the :command:`configure_file` command to only "
"expand variables using the ``@var@`` syntax by passing the ``@ONLY`` "
"option  to the command; this is useful if you are configuring a script "
"that may contain ``${var}`` strings that you want to preserve. This is "
"important because CMake will replace all occurrences of ``${var}`` with "
"the empty string if ``var`` is not defined in CMake."
msgstr "Quando si scrive un file da configurare, si prende in considerazione l'utilizzo di ``@VARIABLE@`` invece di ``${VARIABLE}`` per le variabili che dovrebbero essere espanse da CMake. Poiché la sintassi ``${}`` è comunemente usata da altri linguaggi, gli utenti possono dire al comando :command:`configure_file` di espandere solo le variabili usando la sintassi ``@var@`` passando l'opzione ``@ONLY`` al comando; questo è utile se si sta configurando uno script che può contenere stringhe ``${var}`` da preservare. Questo è importante perché CMake sostituirà tutte le occorrenze di ``${var}`` con la stringa vuota se ``var`` non è definita in CMake."

#: ../../source/chapter/System Inspection.rst:459
msgid ""
"The following example configures a .h file for a project that contains "
"preprocessor variables. The first definition indicates if the ``FOOBAR`` "
"call exists in the library, and the next one contains the path to the "
"build tree."
msgstr "L'esempio seguente configura un file .h per un progetto che contiene variabili del preprocessore. La prima definizione indica se la chiamata ``FOOBAR`` esiste nella libreria e la successiva contiene il path dell'albero di build."

#: ../../source/chapter/System Inspection.rst:489
msgid ""
"It is important to configure files into the binary tree, not the source "
"tree. A single source tree may be shared by multiple build trees or "
"platforms. By configuring files into the binary tree the differences "
"between builds or platforms will be kept isolated in the build tree and "
"will not corrupt other builds. This means that you will need to include "
"the directory of the build tree where you configured the header file into"
" the project's list of include directories using the "
":command:`target_include_directories` command."
msgstr "È importante configurare i file nell'albero binario, non nell'albero dei sorgenti. Un singolo albero di sorgenti può essere condiviso da più alberi di build o di piattaforme. Configurando i file nell'albero binario, le differenze tra build o tra piattaforme verranno mantenute isolate nell'albero della build e non danneggeranno altre build. Ciò significa che si devono includere la directory dell'albero di build in cui è stato configurato il file header nell'elenco delle directory di inclusione del progetto utilizzando il comando :command:`target_include_directories`."

#: ../../source/chapter/Testing CMake CTest.rst:5 With and
msgid "Testing With CMake and CTest"
msgstr "Test con CMake e CTest"

#: ../../source/chapter/Testing CMake CTest.rst:7 With and
msgid ""
"Testing is a key tool for producing and maintaining robust, valid "
"software. This chapter will examine the tools that are part of CMake to "
"support software testing. We will begin with a brief discussion of "
"testing approaches, and then discuss how to add tests to your software "
"project using CMake."
msgstr "Il test è uno strumento essenziale per la produzione e la manutenzione di software robusto e valido. Questo capitolo esaminerà gli strumenti che fanno parte di CMake per supportare il test del software. Inizieremo con una breve discussione sugli approcci ai test, quindi discuteremo su come aggiungere test al progetto utilizzando CMake."

#: ../../source/chapter/Testing CMake CTest.rst:13 With and
msgid ""
"The tests for a software package may take a number of forms. At the most "
"basic level there are smoke tests, such as one that simply verifies that "
"the software compiles. While this may seem like a simple test, with the "
"wide variety of platforms and configurations available, smoke tests catch"
" more problems than any other type of test. Another form of smoke test is"
" to verify that a test runs without crashing. This can be handy for "
"situations where the developer does not want to spend the time creating "
"more complex tests, but is willing to run some simple tests. Most of the "
"time these simple tests can be small example programs. Running them "
"verifies not only that the build was successful, but that any required "
"shared libraries can be loaded (for projects that use them), and that at "
"least some of the code can be executed without crashing."
msgstr "I test per un pacchetto software possono assumere diverse forme. Al livello più elementare ci sono gli \"smoke test\", come quello che verifica semplicemente che il software venga compilato. Anche se questo può sembrare un test semplice, con l'ampia varietà di piattaforme e configurazioni disponibili, gli \"smoke test\" rilevano più problemi di qualsiasi altro tipo di test. Un'altra forma di \"smoke test\" consiste nel verificare che un test venga eseguito senza arresti anomali. Questo può risultare utile per le situazioni in cui lo sviluppatore non vuole dedicare tempo alla creazione di test più complessi, ma è disposto a eseguirne alcuni semplici. Il più delle volte questi semplici test possono essere piccoli programmi di esempio. Eseguendoli si verifica non solo che la compilazione sia andata a buon fine, ma che tutte le librerie condivise richieste possano essere caricate (per i progetti che le utilizzano) e che almeno una parte del codice possa essere eseguita senza crash."

#: ../../source/chapter/Testing CMake CTest.rst:30 With and
msgid ""
"Moving beyond basic smoke tests leads to more specific tests such as "
"regression, black-, and white-box testing. Each of these has its "
"strengths. Regression testing verifies that the results of a test do not "
"change over time or platform. This is very useful when performed "
"frequently, as it provides a quick check that the behavior and results of"
" the software have not changed. When a regression test fails, a quick "
"look at recent code changes can usually identify the culprit. "
"Unfortunately, regression tests typically require more effort to create "
"than other tests."
msgstr "Andare oltre gli \"smoke test\" di base porta a test più specifici come quelli di regressione, black-box e white-box. Ognuno di questi ha i suoi punti di forza. Il test di regressione verifica che i risultati di un test non cambino nel tempo o tra le piattaforme. Questo è molto utile se eseguito frequentemente, in quanto fornisce un rapido controllo che il comportamento e i risultati del software non sono cambiati. Quando un test di regressione fallisce, una rapida occhiata alle recenti modifiche al codice può in genere identificare il colpevole. Sfortunatamente, i test di regressione in genere richiedono uno sforzo maggiore per la creazione rispetto ad altri test."

#: ../../source/chapter/Testing CMake CTest.rst:43 With and
msgid ""
"White- and black-box testing refer to tests written to exercise units of "
"code (at various levels of integration), with and without knowledge of "
"how those units are implemented respectively. White-box testing is "
"designed to stress potential failure points in the code knowing how that "
"code was written, and hence its weaknesses. As with regression testing, "
"this can take a substantial amount of effort to create good tests. Black-"
"box testing typically knows little or nothing about the implementation of"
" the software other than its public API. Black-box testing can provide a "
"lot of code coverage without too much effort in developing the tests. "
"This is especially true for libraries of object oriented software where "
"the APIs are well defined. A black-box test can be written to go through "
"and invoke a number of typical methods on all the classes in the "
"software."
msgstr "I test white- e black- box si riferiscono a test scritti per testare unità di codice (a vari livelli di integrazione), con e senza conoscenza di come tali unità sono rispettivamente implementate. Il test white-box è progettato per evidenziare potenziali punti di errore nel codice sapendo come quel codice è stato scritto e quindi i suoi punti deboli. Come per i test di regressione, questo può richiedere uno sforzo notevole per creare buoni test. I test black-box in genere sanno poco o nulla sull'implementazione del software oltre alla sua API pubblica. I test black-box possono fornire molta copertura del codice senza troppi sforzi nello sviluppo dei test. Ciò è particolarmente vero per le librerie di software orientato agli oggetti in cui le API sono ben definite. È possibile scrivere un test black-box per eseguire e richiamare una serie di metodi tipici su tutte le classi del software."

#: ../../source/chapter/Testing CMake CTest.rst:57 With and
msgid ""
"The final type of testing we will discuss is software standard compliance"
" testing. While the other test types we have discussed are focused on "
"determining if the code works properly, compliance testing tries to "
"determine if the code adheres to the coding standards of the software "
"project. This could be a check to verify that all classes have "
"implemented some key method, or that all functions have a common prefix. "
"The options for this type of test are limitless and there are a number of"
" ways to perform such testing. There are software analysis tools that can"
" be used, or specialized test programs (maybe python scripts etc) could "
"be written. The key point to realize is that the tests do not necessarily"
" have to involve running some part of the software. The tests might run "
"some other tool on the source code itself."
msgstr "L'ultimo tipo di test che discuteremo è quello di conformità agli standard del software. Mentre gli altri tipi di test che discussi sono incentrati sulla determinazione del corretto funzionamento del codice, quelli di conformità tentano di determinare se il codice aderisce agli standard di codifica del progetto. Questo potrebbe essere un controllo per verificare che tutte le classi abbiano implementato un metodo chiave o che tutte le funzioni abbiano un prefisso comune. Le opzioni per questo tipo di test sono illimitate e ci sono diversi modi per eseguire tale test. Esistono strumenti di analisi del software utilizzabili o potrebbero essere scritti programmi di test specializzati (forse script Python ecc.). Il punto chiave da comprendere è che i test non devono necessariamente comportare l'esecuzione di certe parti del software. I test potrebbero eseguire qualche altro strumento sul codice sorgente stesso."

#: ../../source/chapter/Testing CMake CTest.rst:71 With and
msgid ""
"There are a number of reasons why it helps to have testing support "
"integrated into the build process. First, complex software projects may "
"have a number of configuration or platform-dependent options. The build "
"system knows what options can be enabled and can then enable the "
"appropriate tests for those options. For example, the Visualization "
"Toolkit (VTK) includes support for a parallel processing library called "
"MPI. If VTK is built with MPI support then additional tests are enabled "
"that make use of MPI and verify that the MPI-specific code in VTK works "
"as expected. Secondly, the build system knows where the executables will "
"be placed, and it has tools for finding other required executables (such "
"as perl, python etc). The third reason is that with UNIX Makefiles it is "
"common to have a test target in the Makefile so that developers can type "
"make test and have the test(s) run. In order for this to work, the build "
"system must have some knowledge of the testing process."
msgstr "Esistono diversi motivi per cui è utile avere il supporto per i test, integrato nel processo di build. In primo luogo, i progetti complessi possono avere una serie di opzioni di configurazione o dipendenze dalla piattaforma. Il sistema di build sa quali opzioni possono essere abilitate e può quindi abilitare i test appropriati per tali opzioni. Ad esempio, il Visualization Toolkit (VTK) include il supporto per una libreria di elaborazione parallela denominata MPI. Se VTK viene creato con il supporto MPI, vengono abilitati test aggiuntivi che utilizzano MPI e verificano che il codice specifico di MPI in VTK funzioni come previsto. In secondo luogo, il sistema di build sa dove verranno posizionati gli eseguibili e dispone di strumenti per trovare gli altri eseguibili richiesti (come perl, python ecc.). La terza ragione è che con i Makefile UNIX è normale avere un target test nel Makefile in modo che gli sviluppatori possano digitare make test e far eseguire i test. Affinché funzioni, il sistema di build deve avere una certa conoscenza del processo di test."

#: ../../source/chapter/Testing CMake CTest.rst:88 With and
msgid "How Does CMake Facilitate Testing?"
msgstr "In Che Modo CMake Facilita i Test?"

#: ../../source/chapter/Testing CMake CTest.rst:90 With and
msgid ""
"CMake facilitates testing your software through special testing commands "
"and the :manual:`CTest <ctest(1)>` executable. First, we will discuss the"
" key testing commands in CMake. To add testing to a CMake-based project, "
"simply :command:`include(CTest)` and use the :command:`add_test` command."
" The :command:`add_test` command has a simple syntax as follows:"
msgstr "CMake facilita il test del software tramite speciali comandi di test e l'eseguibile :manual:`CTest <ctest(1)>`. Innanzitutto, discuteremo i principali comandi di test in CMake. Per aggiungere test a un progetto basato su CMake, semplicemente :command:`include(CTest)` e si usa il comando :command:`add_test`. Il comando :command:`add_test` ha una sintassi semplice come questa:"

#: ../../source/chapter/Testing CMake CTest.rst:100 With and
msgid ""
"The first argument is simply a string name for the test. This is the name"
" that will be displayed by testing programs. The second argument is the "
"executable to run. The executable can be built as part of the project or "
"it can be a standalone executable such as python, perl, etc. The "
"remaining arguments will be passed to the running executable. A typical "
"example of testing using the :command:`add_test` command would look like "
"this:"
msgstr "Il primo argomento è semplicemente un nome di stringa per il test. Questo è il nome che verrà visualizzato dai programmi di test. Il secondo argomento è l'eseguibile da eseguire. L'eseguibile può essere compilato come parte del progetto o può essere un eseguibile standalone come python, perl, ecc. Gli argomenti rimanenti verranno passati all'eseguibile in esecuzione. Un tipico esempio di test col comando :command:`add_test` sarebbe simile a questo:"

#: ../../source/chapter/Testing CMake CTest.rst:120 With and
msgid ""
"The :command:`add_test` command is typically placed in the CMakeLists "
"file for the directory that has the test in it. For large projects, there"
" may be multiple CMakeLists files with :command:`add_test` commands in "
"them. Once the :command:`add_test`  commands are present in the project, "
"the user can run the tests by invoking the \"test\" target of Makefile, "
"or the ``RUN_TESTS`` target of Visual Studio or Xcode. An example of "
"running tests on the CMake tests using the Makefile generator on Linux "
"would be::"
msgstr "Il comando :command:`add_test` viene solitamente inserito nel file CMakeLists per la directory che contiene il test. Per progetti di grandi dimensioni, potrebbero esserci più file CMakeLists con comandi :command:`add_test` al loro interno. Una volta che i comandi :command:`add_test` sono presenti nel progetto, l'utente può eseguire i test richiamando il target \"test\" di Makefile o il target ``RUN_TESTS`` di Visual Studio o Xcode. Un esempio di esecuzione sui test CMake utilizzando il generatore di Makefile su Linux potrebbe essere::"

#: ../../source/chapter/Testing CMake CTest.rst:144 With and
msgid "Additional Test Properties"
msgstr "Ulteriori proprietà dei Test"

#: ../../source/chapter/Testing CMake CTest.rst:146 With and
msgid "By default a test passes if all of the following conditions are true:"
msgstr "Per default, un test viene superato se tutte le seguenti condizioni sono vere:"

#: ../../source/chapter/Testing CMake CTest.rst:148 With and
msgid "The test executable was found"
msgstr "L'eseguibile da testare è stato trovato"

#: ../../source/chapter/Testing CMake CTest.rst:149 With and
msgid "The test ran without exception"
msgstr "Il test è stato eseguito senza eccezioni"

#: ../../source/chapter/Testing CMake CTest.rst:150 With and
msgid "The test exited with return code 0"
msgstr "Il test è terminato con codice di ritorno 0"

#: ../../source/chapter/Testing CMake CTest.rst:152 With and
msgid ""
"That said, these behaviors can be modified using the "
":command:`set_property` command:"
msgstr "Detto questo, tali comportamenti possono essere modificati usando il comando :command:`set_property`:"

#: ../../source/chapter/Testing CMake CTest.rst:160 With and
msgid ""
"This command will set additional properties for the specified tests. "
"Example properties are:"
msgstr "Questo comando imposterà proprietà aggiuntive per i test specificati. Esempi di proprietà sono:"

#: ../../source/chapter/Testing CMake CTest.rst:168 With and
msgid ":prop_test:`ENVIRONMENT`"
msgstr ":prop_test:`ENVIRONMENT`"

#: ../../source/chapter/Testing CMake CTest.rst:164 With and
msgid ""
"Specifies environment variables that should be defined for running a "
"test. If set to a list of environment variables and values of the form "
"``MYVAR=value``, those environment variables will be defined while the "
"test is running. The environment is restored to its previous state after "
"the test is done."
msgstr "Specifica le variabili di ambiente che devono essere definite per l'esecuzione di un test. Se impostato su un elenco di variabili di ambiente e valori nel formato ``MYVAR=value``, tali variabili di ambiente verranno definite durante l'esecuzione del test. L'ambiente viene ripristinato allo stato precedente al termine del test."

#: ../../source/chapter/Testing CMake CTest.rst:174 With and
msgid ":prop_test:`LABELS`"
msgstr ":prop_test:`LABELS`"

#: ../../source/chapter/Testing CMake CTest.rst:171 With and
msgid ""
"Specifies a list of text labels associated with a test. These labels can "
"be used to group tests together based on what they test. For example, you"
" could add a label of MPI to all tests that exercise MPI code."
msgstr "Specifica un elenco di etichette di testo associate a un test. Queste etichette possono essere utilizzate per raggruppare i test in base a ciò che testano. Ad esempio, è possibile aggiungere un'etichetta MPI a tutti i test che utilizzano il codice MPI."

#: ../../source/chapter/Testing CMake CTest.rst:179 With and
msgid ":prop_test:`WILL_FAIL`"
msgstr ":prop_test:`WILL_FAIL`"

#: ../../source/chapter/Testing CMake CTest.rst:177 With and
msgid ""
"If this option is set to true, then the test will pass if the return code"
" is not 0, and fail if it is. This reverses the third condition of the "
"pass requirements."
msgstr "Se questa opzione è impostata su true, allora il test passerà se il codice di ritorno non è 0, e fallirà se lo è. Questo inverte la terza condizione dei requisiti di superamento del test."

#: ../../source/chapter/Testing CMake CTest.rst:186 With and
msgid ":prop_test:`PASS_REGULAR_EXPRESSION`"
msgstr ":prop_test:`PASS_REGULAR_EXPRESSION`"

#: ../../source/chapter/Testing CMake CTest.rst:182 With and
msgid ""
"If this option is specified, then the output of the test is checked "
"against the regular expression provided (a list of regular expressions "
"may be passed in as well). If none of the regular expressions match, then"
" the test will fail. If at least one of them matches, then the test will "
"pass."
msgstr "Se questa opzione è specificata, l'output del test viene confrontato con l'espressione regolare fornita (si può passare anche un elenco di espressioni regolari). Se nessuna delle espressioni regolari corrisponde, il test fallirà. Se almeno uno di essi corrisponde, il test passerà."

#: ../../source/chapter/Testing CMake CTest.rst:193 With and
msgid ":prop_test:`FAIL_REGULAR_EXPRESSION`"
msgstr ":prop_test:`FAIL_REGULAR_EXPRESSION`"

#: ../../source/chapter/Testing CMake CTest.rst:189 With and
msgid ""
"If this option is specified, then the output of the test is checked "
"against the regular expression provided (a list of regular expressions "
"may be passed in as well). If none of the regular expressions match, then"
" the test will pass. If at least one of them matches, then the test will "
"fail."
msgstr "Se questa opzione è specificata, l'output del test viene confrontato con l'espressione regolare fornita (si può passare anche un elenco di espressioni regolari). Se nessuna delle espressioni regolari corrisponde, il test passerà. Se almeno uno di essi corrisponde, il test fallirà."

#: ../../source/chapter/Testing CMake CTest.rst:195 With and
msgid ""
"If both :prop_test:`PASS_REGULAR_EXPRESSION` and "
":prop_test:`FAIL_REGULAR_EXPRESSION` are specified, then the "
":prop_test:`FAIL_REGULAR_EXPRESSION` takes precedence. The following "
"example illustrates using the :prop_test:`PASS_REGULAR_EXPRESSION` and "
":prop_test:`FAIL_REGULAR_EXPRESSION`:"
msgstr "Se sono specificati sia :prop_test:`PASS_REGULAR_EXPRESSION` che :prop_test:`FAIL_REGULAR_EXPRESSION`, allora ha la precedenza :prop_test:`FAIL_REGULAR_EXPRESSION`. L'esempio seguente illustra l'utilizzo di :prop_test:`PASS_REGULAR_EXPRESSION` e di :prop_test:`FAIL_REGULAR_EXPRESSION`:"

#: ../../source/chapter/Testing CMake CTest.rst:218 With and
msgid "Testing Using CTest"
msgstr "Test Con CTest"

#: ../../source/chapter/Testing CMake CTest.rst:220 With and
msgid ""
"When you run the tests from your build environment, what really happens "
"is that the build environment runs :manual:`CTest <ctest(1)>`. "
":manual:`CTest <ctest(1)>` is an executable that comes with CMake; it "
"handles running the tests for the project. While CTest works well with "
"CMake, you do not have to use CMake in order to use CTest. The main input"
" file for CTest is called ``CTestTestfile.cmake``. This file will be "
"created in each directory that was processed by CMake (typically every "
"directory with a CMakeLists file). The syntax of ``CTestTestfile.cmake`` "
"is like the regular CMake syntax, with a subset of the commands "
"available. If CMake is used to generate testing files, they will list any"
" subdirectories that need to be processed as well as any "
":command:`add_test` calls. The subdirectories are those that were added "
"by the :command:`add_subdirectory` commands. CTest can then parse these "
"files to determine what tests to run. An example of such a file is shown "
"below:"
msgstr "Quando si eseguono i test dall'ambiente di build, ciò che realmente accade è che tale ambiente esegue :manual:`CTest <ctest(1)>`. :manual:`CTest <ctest(1)>` è un eseguibile fornito con CMake; gestisce l'esecuzione dei test per progetto. Mentre CTest funziona bene con CMake, non è necessario utilizzare CMake per utilizzare CTest. Il file di input principale per CTest si chiama ``CTestTestfile.cmake``. Questo file verrà creato in ogni directory elaborata da CMake (in genere ogni directory con un file CMakeLists). La sintassi di ``CTestTestfile.cmake`` è come quella di CMake, con un sottoinsieme dei comandi disponibili. Se CMake viene utilizzato per generare file di test, verranno elencate tutte le sottodirectory che devono essere elaborate così come qualsiasi chiamata :command:`add_test`. Le sottodirectory sono quelle aggiunte dai comandi :command:`add_subdirectory`. CTest può quindi analizzare questi file per determinare quali test eseguire. Un esempio di tale file è mostrato di seguito:"

#: ../../source/chapter/Testing CMake CTest.rst:252 With and
msgid ""
"When CTest parses the ``CTestTestfile.cmake`` files, it will extract the "
"list of tests from them. These tests will be run, and for each test CTest"
" will display the name of the test and its status. Consider the following"
" sample output::"
msgstr "Quando CTest analizza i file ``CTestTestfile.cmake``, ne estrae l'elenco dei test. Questi test verranno eseguiti e per ogni test CTest visualizzerà il nome del test e il suo stato. Si consideri il seguente output di esempio::"

#: ../../source/chapter/Testing CMake CTest.rst:273 With and
msgid ""
"CTest is run from within your build tree. It will run all the tests found"
" in the current directory as well as any subdirectories listed in the "
"``CTestTestfile.cmake``. For each test that is run CTest will report if "
"the test passed and how long it took to run the test."
msgstr "CTest viene eseguito dall'interno dell'albero di build. Eseguirà tutti i test trovati nella directory corrente e in tutte le sottodirectory elencate in ``CTestTestfile.cmake``. Per ogni test eseguito, CTest riporterà se il test è stato superato e quanto tempo è stato necessario per eseguirlo."

#: ../../source/chapter/Testing CMake CTest.rst:278 With and
msgid ""
"The CTest executable includes some handy command line options to make "
"testing a little easier. We will start by looking at the options you "
"would typically use from the command line."
msgstr "L'eseguibile CTest include alcune utili opzioni della riga di comando per semplificare un po' i test. Inizieremo esaminando le opzioni che si userebbero normalmente dalla riga di comando."

#: ../../source/chapter/Testing CMake CTest.rst:299 With and
msgid ""
"The ``-R`` option is probably the most commonly used. It allows you to "
"specify a regular expression; only the tests with names matching the "
"regular expression will be run. Using the ``-R`` option with the name (or"
" part of the name) of a test is a quick way to run a single test. The "
"``-E`` option is similar except that it excludes all tests matching the "
"regular expression. The ``-L`` and ``-LE`` options are similar to ``-R`` "
"and ``-E``, except that they apply to test labels that were set using the"
" :command:`set_property` command described previously. The ``-C`` option "
"is mainly for IDE builds where you might have multiple configurations, "
"such as Release and Debug in the same tree. The argument following the "
"``-C`` determines which configuration will be tested. The ``-V`` argument"
" is useful when you are trying to determine why a test is failing. With "
"``-V``, CTest will print out the command line used to run the test, as "
"well as any output from the test itself. The ``-V`` option can be used "
"with any invocation of CTest to provide more verbose output. The ``-N`` "
"option is useful if you want to see what tests CTest would run without "
"actually running them."
msgstr "L'opzione ``-R`` è probabilmente la più usata. Permette di specificare un'espressione regolare; verranno eseguiti solo i test con nomi corrispondenti all'espressione regolare. L'utilizzo dell'opzione ``-R`` con il nome (o parte del nome) di un test è un modo rapido per eseguire un singolo test. L'opzione ``-E`` è simile, tranne per il fatto che esclude tutti i test che corrispondono all'espressione regolare. Le opzioni ``-L`` e ``-LE`` sono simili a ``-R`` e ``-E``, tranne per il fatto che si applicano alle etichette impostate utilizzando il comando :command:`set_property` descritto in precedenza. L'opzione ``-C`` è principalmente per le build con IDE in cui si potrebbero avere più configurazioni, come Release e Debug nello stesso albero. L'argomento che segue ``-C`` determina quale configurazione verrà testata. L'argomento ``-V`` è utile quando si cerca di determinare perché un test fallisce. Con ``-V``, CTest stamperà la riga di comando utilizzata per eseguire il test, nonché qualsiasi output del test stesso. L'opzione ``-V`` può essere utilizzata con qualsiasi invocazione di CTest per fornire un output più dettagliato. L'opzione ``-N`` è utile per vedere quali test verrebbero eseguiti da CTest senza eseguirli effettivamente."

#: ../../source/chapter/Testing CMake CTest.rst:317 With and
msgid ""
"Running the tests and making sure they all pass before committing any "
"changes to the software is a sure-fire way to improve your software "
"quality and development process. Unfortunately, for large projects the "
"number of tests and the time required to run them may be prohibitive. In "
"these situations the ``-I`` option of CTest can be used. The ``-I`` "
"option allows you to flexibly specify a subset of the tests to run. For "
"example, the following invocation of CTest will run every seventh test."
msgstr "Eseguire i test e assicurarsi che passino tutti prima di confermare qualsiasi modifica al software è un modo infallibile per migliorare la qualità del software e il processo di sviluppo. Sfortunatamente, per progetti di grandi dimensioni il numero di test e il tempo necessario per eseguirli possono essere proibitivi. In queste situazioni può essere utilizzata l'opzione ``-I`` di CTest. L'opzione ``-I`` consente di specificare in modo flessibile un sottoinsieme dei test da eseguire. Ad esempio, la seguente chiamata di CTest verrà eseguita ogni settimo test."

#: ../../source/chapter/Testing CMake CTest.rst:330 With and
msgid ""
"While this is not as good as running every test, it is better than not "
"running any and it may be a more practical solution for many developers. "
"Note that if the start and end arguments are not specified, as in this "
"example, then they will default to the first and last tests. In another "
"example, assume that you always want to run a few tests plus a subset of "
"the others. In this case you can explicitly add those tests to the end of"
" the arguments for ``-I``. For example::"
msgstr "Anche se questo non è buono come eseguire tutti i test, è meglio che non eseguirne nessuno e potrebbe essere una soluzione più pratica per molti sviluppatori. Si noti che se gli argomenti start e end non sono specificati, come in questo esempio, per default  verranno utilizzati il primo e l'ultimo test. In un altro esempio, si supponga di voler sempre eseguire alcuni test più un sottoinsieme degli altri. In questo caso si possono aggiungere esplicitamente quei test alla fine degli argomenti per ``-I``. Per esempio::"

#: ../../source/chapter/Testing CMake CTest.rst:340 With and
msgid ""
"will run tests 1, 2, 3, and 10, plus every fifth test. You can pass as "
"many test numbers as you want after the stride argument."
msgstr "eseguirà i test 1, 2, 3 e 10, più ogni quinto test. Si possono passare tutti i numeri di test desiderati dopo l'argomento di Stride."

#: ../../source/chapter/Testing CMake CTest.rst:347 With and
msgid "Using CTest to Drive Complex Tests"
msgstr "Utilizzo di CTest per Pilotare Test Complessi"

#: ../../source/chapter/Testing CMake CTest.rst:349 With and
msgid ""
"Sometimes to properly test a project you need to actually compile code "
"during the testing phase. There are several reasons for this. First, if "
"test programs are compiled as part of the main project, they can end up "
"taking up a significant amount of the build time. Also, if a test fails "
"to build, the main build should not fail as well. Finally, IDE projects "
"can quickly become too large to load and work with. The CTest command "
"supports a group of command line options that allow it to be used as the "
"test executable to run. When used as the test executable, CTest can run "
"CMake, run the compile step, and finally run a compiled test. We will now"
" look at the command line options to CTest that support building and "
"running tests."
msgstr "A volte per testare correttamente un progetto è necessario compilare effettivamente il codice durante la fase di test. Ci sono diverse ragioni per questo. Innanzitutto, se i programmi di test vengono compilati come parte del progetto principale, possono finire per occupare una quantità significativa del tempo di building. Inoltre, se un test fallisce, la build principale non dovrebbe fallire. Infine, i progetti IDE possono diventare rapidamente troppo grandi per essere caricati e utilizzati. Il comando CTest supporta un gruppo di opzioni della riga di comando che ne consentono l'utilizzo come eseguibile di test da eseguire. Se utilizzato come eseguibile di test, CTest può eseguire CMake, eseguire il passo della compilazione e infine eseguire un test compilato. Esamineremo ora le opzioni della riga di comando di CTest che supportano la creazione e l'esecuzione di test."

#: ../../source/chapter/Testing CMake CTest.rst:377 With and
msgid ""
"For an example, consider the following :command:`add_test` command taken "
"from the CMakeLists.txt file of CMake itself. It shows how CTest can be "
"used both to compile and run a test."
msgstr "Ad esempio, si consideri il seguente comando :command:`add_test` preso dal file CMakeLists.txt di CMake stesso. Esso mostra come CTest è utilizzabile sia per compilare che per eseguire un test."

#: ../../source/chapter/Testing CMake CTest.rst:391 With and
msgid ""
"In this example, the :command:`add_test` command is first passed the name"
" of the test, \"simple\". After the name of the test, the command to be "
"run is specified. In this case, the test command to be run is CTest. The "
"CTest command is referenced via the :variable:`CMAKE_CTEST_COMMAND` "
"variable. This variable is always set by CMake to the CTest command that "
"came from the CMake installation used to build the project. Next, the "
"source and binary directories are specified. The next options to CTest "
"are the ``--build-generator`` and ``--build-makeprogram`` options. These "
"are specified using the CMake variables :variable:`CMAKE_MAKE_PROGRAM` "
"and :variable:`CMAKE_GENERATOR`. Both :variable:`CMAKE_MAKE_PROGRAM` and "
":variable:`CMAKE_GENERATOR` are defined by CMake. This is an important "
"step as it makes sure that the same generator is used for building the "
"test as was used for building the project itself. The ``--build-project``"
" option is passed ``Simple``, which corresponds to the :command:`project`"
" command used in the Simple test. The final argument is the ``--test-"
"command`` which tells CTest the command to run once it gets a successful "
"build, and should be the name of the executable that will be compiled by "
"the test."
msgstr "In questo esempio, al comando :command:`add_test` viene prima passato il nome del test, \"simple\". Dopo il nome del test, viene specificato il comando da eseguire. In questo caso, il comando di test da eseguire è CTest. Il comando CTest viene referenziato tramite la variabile :variable:`CMAKE_CTEST_COMMAND`. Questa variabile è sempre impostata da CMake sul comando CTest proveniente dall'installazione di CMake utilizzata per creare il progetto. Successivamente, vengono specificate le directory dei sorgenti e quella dei binari. Le opzioni successive a CTest sono le ``--build-generator`` e ``--build-makeprogram``. Questi vengono specificate utilizzando le variabili CMake :variable:`CMAKE_MAKE_PROGRAM` e :variable:`CMAKE_GENERATOR`. Sia :variable:`CMAKE_MAKE_PROGRAM` che :variable:`CMAKE_GENERATOR` sono definiti da CMake. Questo è un passaggio importante in quanto garantisce che per la creazione del test venga utilizzato lo stesso generatore utilizzato per la creazione del progetto stesso. L'opzione ``--build-project`` viene passata ``Simple``, che corrisponde al comando :command:`project` utilizzato nel test Simple. L'argomento finale è ``--test-command`` che indica a CTest il comando da eseguire dopo una compilazione riuscita e dovrebbe essere il nome dell'eseguibile che verrà compilato dal test."

#: ../../source/chapter/Testing CMake CTest.rst:411 With and
msgid "Handling a Large Number of Tests"
msgstr "Gestire un Gran Numero di Test"

#: ../../source/chapter/Testing CMake CTest.rst:413 With and
msgid ""
"When a large number of tests exist in a single project, it is cumbersome "
"to have individual executables available for each test. That said, the "
"developer of the project should not be required to create tests with "
"complex argument parsing. This is why CMake provides a convenience "
"command for creating a test driver program. This command is called "
":command:`create_test_sourcelist`. A test driver is a program that links "
"together many small tests into a single executable. This is useful when "
"building static executables with large libraries to shrink the total "
"required size. The signature for :command:`create_test_sourcelist` is as "
"follows:"
msgstr "Quando esiste un numero elevato di test in un singolo progetto, è ingombrante disporre di singoli eseguibili per ciascun test. Detto questo, allo sviluppatore del progetto non dovrebbe essere richiesto di creare test con l'analisi [parsing] di argomenti complessi. Questo è il motivo per cui CMake fornisce un comodo comando per la creazione di un programma di test driver. Questo comando si chiama :command:`create_test_sourcelist`. Un test driver è un programma che collega insieme molti piccoli test in un singolo eseguibile. Ciò è utile quando si creano eseguibili statici con librerie di grandi dimensioni per ridurre la dimensione totale richiesta. La firma per :command:`create_test_sourcelist` è la seguente:"

#: ../../source/chapter/Testing CMake CTest.rst:433 With and
msgid ""
"The first argument is the variable which will contain the list of source "
"files that must be compiled to make the test executable. The DriverName "
"is the name of the test driver program (e.g. the name of the resulting "
"executable). The rest of the arguments consist of a list of test source "
"files. Each test source file should have a function in it that has the "
"same name as the file with no extension (``foo.cxx`` should have ``int "
"foo(argc, argv);``). The resulting executable will be able to invoke each"
" of the tests by name on the command line. The ``EXTRA_INCLUDE`` and "
"``FUNCTION`` arguments support additional customization of the test "
"driver program. Consider the following CMakeLists file fragment to see "
"how this command can be used:"
msgstr "Il primo argomento è la variabile che conterrà l'elenco dei sorgenti che dovranno essere compilati per rendere eseguibile il test. DriverName è il nome del programma del test driver (ad esempio il nome dell'eseguibile risultante). Il resto degli argomenti è costituito da un elenco dei file sorgenti del test. Ogni sorgente del test dovrebbe contenere una funzione che abbia lo stesso nome del file senza estensione (``foo.cxx`` dovrebbe avere ``int foo(argc, argv);``). L'eseguibile risultante sarà in grado di richiamare ciascuno dei test per nome sulla riga di comando. Gli argomenti ``EXTRA_INCLUDE`` e ``FUNCTION`` supportano un'ulteriore personalizzazione del programma del test driver. Consideriamo il seguente frammento di file CMakeLists per vedere come questo comando può essere utilizzato:"

#: ../../source/chapter/Testing CMake CTest.rst:479 With and
msgid ""
"The :command:`create_test_sourcelist` command is invoked to create a test"
" driver. In this case it creates and writes ``CommonCxxTests.cxx`` into "
"the binary tree of the project, using the rest of the arguments to "
"determine its contents. Next, the :command:`add_executable` command is "
"used to add that executable to the build. Then a new variable called "
"``TestsToRun`` is created with an initial value of the sources required "
"for the test driver. The :command:`remove` command is used to remove the "
"driver program itself from the list. Then, a :command:`foreach` command "
"is used to loop over the remaining sources. For each source, its name "
"without a file extension is extracted and put in the variable ``TName``, "
"then a new test is added for ``TName``. The end result is that for each "
"source file in the :command:`create_test_sourcelist` an "
":command:`add_test` command is called with the name of the test. As more "
"tests are added to the :command:`create_test_sourcelist` command, the "
":command:`foreach` loop will automatically call :command:`add_test` for "
"each one."
msgstr "Il comando :command:`create_test_sourcelist` viene richiamato per creare un test driver. In questo caso crea e scrive ``CommonCxxTests.cxx`` nell'albero binario del progetto, usando il resto degli argomenti per determinarne il contenuto. Successivamente, il comando :command:`add_executable` viene utilizzato per aggiungere l'eseguibile alla build. Quindi viene creata una nuova variabile chiamata ``TestsToRun`` con un valore iniziale delle fonti richieste per il test driver. Il comando :command:`remove` viene utilizzato per rimuovere il programma driver stesso dall'elenco. Quindi, viene utilizzato un comando :command:`foreach` per eseguire il ciclo sui sorgenti rimanenti. Per ogni sorgente, il suo nome di file senza estensione viene estratto e inserito nella variabile ``TName``, poi viene aggiunto un nuovo test per ``TName``. Il risultato finale è che per ogni sorgente in :command:`create_test_sourcelist` viene chiamato un comando :command:`add_test` con il nome del test. Man mano che vengono aggiunti più test al comando :command:`create_test_sourcelist`, il ciclo :command:`foreach` chiamerà automaticamente :command:`add_test` per ognuno."

#: ../../source/chapter/Testing CMake CTest.rst:497 With and
msgid "Managing Test Data"
msgstr "Gestione dei Dati di Test"

#: ../../source/chapter/Testing CMake CTest.rst:499 With and
msgid ""
"In addition to handling large numbers of tests, CMake contains a system "
"for managing test data. It is encapsulated in an :module:`ExternalData` "
"CMake module, downloads large data on an as-needed basis, retains version"
" information, and allows distributed storage."
msgstr "Oltre a gestire un gran numero di test, CMake contiene un sistema per la gestione dei dati dei test. È incapsulato in un modulo CMake :module:`ExternalData`, scarica dati di grandi dimensioni in base alle necessità, conserva le informazioni sulla versione e consente l'archiviazione distribuita."

#: ../../source/chapter/Testing CMake CTest.rst:504 With and
msgid ""
"The design of the :module:`ExternalData` follows that of distributed "
"version control systems using hash-based file identifiers and object "
"stores, but it also takes advantage of the presence of a dependency-based"
" build system. The figure below illustrates the approach. Source trees "
"contain lighweight \"content links\" referencing data in remote storage "
"by hashes of their content. The :module:`ExternalData` module produces "
"build rules to download the data to local stores and reference them from "
"build trees by symbolic links (copies on Windows)."
msgstr "Il design di :module:`ExternalData` segue quello dei sistemi di controllo della versione distribuiti che utilizzano identificatori di file basati su hash e archivi di oggetti, ma sfrutta anche la presenza di un sistema di build basato sulle dipendenze. La figura seguente illustra l'approccio. Le strutture dei sorgenti contengono \"collegamenti ai contenuti\" leggeri, che fanno riferimento ai dati nell'archiviazione remota tramite hash del loro contenuto. Il modulo :module:`ExternalData` produce regole di build per scaricare i dati negli archivi locali e farvi riferimento da alberi di build tramite link simbolici (copie su Windows)."

#: ../../source/chapter/Testing CMake CTest.rst:517 With and
msgid "ExternalData module flow chart"
msgstr "Diagramma di flusso del modulo ExternalData"

#: ../../source/chapter/Testing CMake CTest.rst:519 With and
msgid ""
"A content link is a small, plain text file containing a hash of the real "
"data. Its name is the same as its data file, with an additional extension"
" identifying the hash algorithm e.g. img.png.md5. Content links always "
"take the same (small) amount of space in the source tree regardless of "
"the real data size. The CMakeLists.txt CMake configuration files refer to"
" data using a DATA{} syntax inside calls to the :module:`ExternalData` "
"module API. For example, DATA{img.png} tells the :module:`ExternalData` "
"module to make img.png available in the build tree even if only a "
"img.png.md5 content link appears in the source tree."
msgstr "Un link al contenuto è un piccolo file di semplice testo contenente un hash dei dati reali. Il suo nome è lo stesso del suo file di dati, con un'estensione aggiuntiva che identifica l'algoritmo di hash, ad es. img.png.md5. I link ai contenuti occupano sempre la stessa (piccola) quantità di spazio nell'albero dei sorgenti, indipendentemente dalla dimensione reale dei dati. I file di configurazione CMake CMakeLists.txt fanno riferimento ai dati utilizzando una sintassi DATA{} all'interno delle chiamate all'API del modulo :module:`ExternalData`. Ad esempio, DATA{img.png} dice al modulo :module:`ExternalData` di rendere disponibile img.png nell'albero di build anche se nell'albero dei sorgenti appare solo un link di contenuto img.png.md5."

#: ../../source/chapter/Testing CMake CTest.rst:529 With and
msgid ""
"The :module:`ExternalData` module implements a flexible system to prevent"
" duplication of content fetching and storage. Objects are retrieved from "
"a list of (possibly redundant) local and remote locations specified in "
"the :module:`ExternalData` CMake configuration as a list of \"URL "
"templates\". The only requirement of remote storage systems is the "
"ability to fetch from a URL that locates content through specification of"
" the hash algorithm and hash value. Local or networked file systems, an "
"Apache FTP server or a `Midas <http://www.midasplatform.org>`_ server , "
"for example, all have this capability. Each URL template has %(algo) and "
"%(hash) placeholders for :module:`ExternalData` to replace with values "
"from a content link."
msgstr "Il modulo :module:`ExternalData` implementa un sistema flessibile per impedire la duplicazione del recupero e dell'archiviazione dei contenuti. Gli oggetti vengono recuperati da un elenco di posizioni locali e remote (possibilmente ridondanti) specificate nella configurazione :module:`ExternalData` CMake come un elenco di \"URL templates\". L'unico requisito dei sistemi di archiviazione remota è la capacità di recuperare da un URL che individua il contenuto attraverso la specifica dell'algoritmo hash e del valore hash. I file system locali o in rete, un server FTP Apache o un server `Midas <http://www.midasplatform.org>`_, ad esempio, hanno tutti questa capacità. Ogni template di URL ha segnaposto %(algo) e %(hash) per :module:`ExternalData` da sostituire con i valori di un link al contenuto."

#: ../../source/chapter/Testing CMake CTest.rst:541 With and
msgid ""
"A persistent local object store can cache downloaded content to share "
"among build trees by setting the ``ExternalData_OBJECT_STORES`` CMake "
"build configuration variable. This is helpful to de-duplicate content for"
" multiple build trees. It also resolves an important pragmatic concern in"
" a regression testing context; when many machines simultaneously start a "
"nightly dashboard build, they can use their local object store instead of"
" overloading the data servers and flooding network traffic."
msgstr "Un archivio oggetti locale persistente può memorizzare nella cache il contenuto scaricato per condividerlo tra gli alberi di build impostando la variabile CMake di configurazione della build ``ExternalData_OBJECT_STORES``. Ciò è utile per de-duplicare il contenuto per più alberi di build. Risolve anche un'importante preoccupazione pragmatica in un contesto di test di regressione; quando molte macchine avviano contemporaneamente una build notturna del dashboard, possono utilizzare il loro archivio oggetti locale invece di sovraccaricare i server di dati e inondare il traffico di rete."

#: ../../source/chapter/Testing CMake CTest.rst:550 With and
msgid ""
"Retrieval is integrated with a dependency-based build system, so "
"resources are fetched only when needed. For example, if the system is "
"used to retrieve testing data and ``BUILD_TESTING`` is OFF, the data are "
"not retrieved unnecessarily. When the source tree is updated and a "
"content link changes, the build system fetches the new data as needed."
msgstr "Il recupero è integrato con un sistema di build basato sulle dipendenze, quindi le risorse vengono recuperate solo quando necessario. Ad esempio, se il sistema viene utilizzato per recuperare dati di test e ``BUILD_TESTING`` è disattivato, i dati non vengono recuperati inutilmente. Quando l'albero dei sorgenti viene aggiornato e un link al contenuto cambia, il sistema di build recupera i nuovi dati secondo necessità."

#: ../../source/chapter/Testing CMake CTest.rst:556 With and
msgid ""
"Since all references leaving the source tree go through hashes, they do "
"not depend on any external state. Remote and local object stores can be "
"relocated without invalidating content links in older versions of the "
"source code. Content links within a source tree can be relocated or "
"renamed without modifying the object stores. Duplicate content links can "
"exist in a source tree, but download will only occur once. Multiple "
"versions of data with the same source tree file name in a project's "
"history are uniquely identified in the object stores."
msgstr "Poiché tutti i riferimenti che lasciano l'albero dei sorgenti passano attraverso gli hash, non dipendono da alcuno stato esterno. Gli archivi di oggetti remoti e locali possono essere riposizionati senza invalidare i link ai contenuti nelle versioni precedenti del codice sorgente. I link al contenuto all'interno di un albero di origine possono essere riposizionati o rinominati senza modificare gli archivi oggetti. In un albero di sorgenti possono esistere link ai contenuti duplicati, ma il download avverrà solo una volta. Più versioni di dati con lo stesso nome del file dell'albero dei sorgenti nella cronologia di un progetto vengono identificate in modo univoco negli archivi degli oggetti."

#: ../../source/chapter/Testing CMake CTest.rst:565 With and
msgid ""
"Hash-based systems allow the use of untrusted connections to remote "
"resources because downloaded content is verified after it is retrieved. "
"Configuration of the URL templates list improves robustness by allowing "
"multiple redundant remote storage resources. Storage resources can also "
"change over time on an as-needed basis. If a project's remote storage "
"moves over time, a build of older source code versions is always possible"
" by adjusting the URL templates configured for the build tree or by "
"manually populating a local object store."
msgstr "I sistemi basati su hash consentono l'utilizzo di connessioni non attendibili a risorse remote perché il contenuto scaricato viene verificato dopo il recupero. La configurazione dell'elenco dei modelli di URL migliora l'affidabilità consentendo più risorse di archiviazione remote ridondanti. Le risorse di archiviazione possono anche cambiare nel tempo in base alle necessità. Se l'archiviazione remota di un progetto si sposta nel tempo, è sempre possibile creare versioni precedenti del codice sorgente modificando i modelli di URL configurati per l'albero di build o popolando manualmente un archivio oggetti locale."

#: ../../source/chapter/Testing CMake CTest.rst:574 With and
msgid ""
"A simple application of the :module:`ExternalData` module looks like the "
"following:"
msgstr "Una semplice applicazione del modulo :module:`ExternalData` ha il seguente aspetto:"

#: ../../source/chapter/Testing CMake CTest.rst:603 With and
msgid ""
"The ``ExternalData_Add_Test`` function is a wrapper around CMake's "
":command:`add_test` command. The source tree is probed for a "
"Input/Image.png.md5 content link containing the data's MD5 hash. After "
"checking the local object store, a request is made sequentially to each "
"URL in the ``ExternalData_URL_TEMPLATES`` list with the data's hash. Once"
" found, a symlink is created in the build tree. The DATA{Input/Image.png}"
" path will expand to the build tree path in the test command line. Data "
"are retrieved when the MyProjectData target is built."
msgstr "La funzione ``ExternalData_Add_Test`` è un wrapper del comando :command:`add_test` di CMake. L'albero dei sorgenti viene analizzato per un link al contenuto Input/Image.png.md5 contenente l'hash MD5 dei dati. Dopo aver verificato l'archivio oggetti locale, viene effettuata una richiesta in sequenza a ciascun URL nell'elenco ``ExternalData_URL_TEMPLATES`` con l'hash dei dati. Una volta trovato, viene creato un link simbolico nell'albero di compilazione. Il percorso DATA{Input/Image.png} si espanderà nel percorso dell'albero di build nella riga di comando del test. I dati vengono recuperati quando viene creato il target MyProjectData."

#: ../../source/chapter/Why CMake.rst:2
msgid "Why CMake?"
msgstr "Perché CMake?"

#: ../../source/chapter/Why CMake.rst:4
msgid ""
"If you have ever maintained the build and installation process for a "
"software package, you will be interested in CMake. CMake is an open-"
"source build system generator for software projects that allows "
"developers to specify build parameters in a simple, portable, text file "
"format. This file is then used by CMake to generate project files for "
"native build tools including Integrated Development Environments (IDEs) "
"such as Microsoft Visual Studio or Apple's Xcode, as well as UNIX, Linux,"
" NMake, and Ninja. CMake handles the difficult aspects of building "
"software such as cross-platform builds, system introspection, and user "
"customized builds, in a simple manner that allows users to easily tailor "
"builds for complex hardware and software systems."
msgstr "Se si ha esperienza nella manutenzione del processo di build e di installazione di un pacchetto software, CMake risulterà interessante. CMake è un generatore di sistema di build open source per progetti software che consente agli sviluppatori di specificare i parametri di build in un formato testuale semplice e portatile. Questo file viene poi utilizzato da CMake per generare file di progetto per strumenti di build nativi, inclusi gli ambienti di sviluppo integrato (IDE) come Microsoft Visual Studio o Xcode di Apple, nonché UNIX, Linux, NMake e Ninja. CMake gestisce gli aspetti difficili della creazione di software come build multipiattaforma, introspezione del sistema e build personalizzate dall'utente, in un modo semplice che consente agli utenti di personalizzare facilmente le build per sistemi hardware e software complessi."

#: ../../source/chapter/Why CMake.rst:16
msgid ""
"For any project, and especially cross-platform projects, there is a need "
"for a unified build system. Many non CMake-based projects ship with both "
"a UNIX Makefile (or Makefile.in) and a Microsoft Visual Studio workspace."
" This requires that developers constantly try to keep both build systems "
"up-to-date and consistent with each other. To target additional build "
"systems, such as Xcode, requires even more custom copies of these files, "
"creating an even bigger problem. This problem is compounded if you try to"
" support optional components, such as including JPEG support if libjpeg "
"is available on the system. CMake solves this by consolidating these "
"different operations into one simple, easy-to-understand file format."
msgstr "Per qualsiasi progetto, e in particolare per quelli cross-piattaforma, è necessario un sistema di build unificato. Molti progetti non basati su CMake vengono forniti con un Makefile UNIX (o Makefile.in) e un'area di lavoro Microsoft Visual Studio. Ciò richiede che gli sviluppatori cerchino costantemente di mantenere entrambi i sistemi di build aggiornati e coerenti tra loro. Per indirizzare sistemi di build aggiuntivi, come Xcode, sono necessarie ancora più copie personalizzate di questi file, creando un problema ancora più grande. Questo problema è aggravato se si tenta di supportare componenti opzionali, come includere il supporto JPEG se libjpeg è disponibile sul sistema. CMake risolve questo problema consolidando queste diverse operazioni in un formato di file semplice e di facile comprensione."

#: ../../source/chapter/Why CMake.rst:28
msgid ""
"If you have multiple developers working on a project, or multiple target "
"platforms, then the software will have to be built on more than one "
"computer. Given the wide range of installed software and custom options "
"that are involved with setting up a modern computer, the chances are that"
" two computers running the same OS will be slightly different. CMake "
"provides many :index:`benefits <single: CMake ; benefits>` for single "
"platform, multi-machine development environments including:"
msgstr "Se ci sono più sviluppatori che lavorano su un progetto o più piattaforme target, il software dovrà essere creato su più di un computer. Data l'ampia gamma di software installati e opzioni personalizzate che sono coinvolte nella configurazione di un computer moderno, è probabile che due computer che eseguono lo stesso sistema operativo siano leggermente diversi. CMake offre molti :index:`benefici <single: CMake ; benefits>` per ambienti di sviluppo su piattaforma singola e multi-macchina, tra cui:"

#: ../../source/chapter/Why CMake.rst:41
msgid ""
"The ability to automatically search for programs, libraries, and header "
"files that may be required by the software being built. This includes the"
" ability to consider environment variables and Window's registry settings"
" when searching."
msgstr "La possibilità di cercare automaticamente programmi, librerie e file header che potrebbero essere richiesti dal software in fase di build. Ciò include la possibilità di considerare le variabili di ambiente e le impostazioni del registro di Windows durante la ricerca."

#: ../../source/chapter/Why CMake.rst:45
msgid ""
"The ability to build in a directory tree outside of the source tree. This"
" is a useful feature found on many UNIX platforms; CMake provides this "
"feature on Windows as well. This allows a developer to remove an entire "
"build directory without fear of removing source files."
msgstr "La capacità di creare una struttura di directory al di fuori dell'albero dei sorgenti. Questa è una funzione utile che si trova su molte piattaforme UNIX; CMake fornisce questa funzionalità anche su Windows. Ciò consente a uno sviluppatore di rimuovere un'intera directory di build senza timore di rimuovere i file sorgenti."

#: ../../source/chapter/Why CMake.rst:55
msgid ""
"The ability to create complex, custom commands for automatically "
"generated files such as `Qt <http://qt.io>`_'s moc() or `SWIG "
"<http://www.swig.org>`_ wrapper generators. These commands are used to "
"generate new source files during the build process that are in turn "
"compiled into the software."
msgstr "La capacità di creare comandi complessi e personalizzati per file generati automaticamente come i moc() di `Qt <http://qt.io>`_ o i generatori di wrapper di `SWIG <http://www.swig.org>`_. Questi comandi vengono utilizzati per generare nuovi sorgenti durante il processo di build che vengono a loro volta compilati nel software."

#: ../../source/chapter/Why CMake.rst:60
msgid ""
"The ability to select optional components at configuration time. For "
"example, several of `VTK's <http://www.vtk.org>`_ libraries are optional,"
" and CMake provides an easy way for users to select which libraries are "
"built."
msgstr "La possibilità di selezionare componenti opzionali al momento della configurazione. Ad esempio, molte delle librerie di `VTK <http://www.vtk.org>`_ sono opzionali e CMake fornisce un modo semplice per gli utenti di selezionare quali librerie sono create."

#: ../../source/chapter/Why CMake.rst:64
msgid ""
"The ability to automatically generate workspaces and projects from a "
"simple text file. This can be very handy for systems that have many "
"programs or test cases, each of which requires a separate project file, "
"typically a tedious manual process to create using an IDE."
msgstr "La capacità di generare automaticamente aree di lavoro [workspace] e progetti da un semplice file di testo. Questo può risultare molto utile per i sistemi che hanno molti programmi o casi di test, ognuno dei quali richiede un file di progetto separato, in genere un noioso processo manuale da creare utilizzando un IDE."

#: ../../source/chapter/Why CMake.rst:68
msgid ""
"The ability to easily switch between static and shared builds. CMake "
"knows how to create shared libraries and modules on all platforms "
"supported. Complicated platform-specific linker flags are handled, and "
"advanced features like built-in run time search paths for shared "
"libraries are supported on many UNIX systems."
msgstr "La possibilità di passare facilmente tra build statiche e shared. CMake sa come creare librerie e moduli shared su tutte le piattaforme supportate. Vengono gestiti complicati flag del linker specifici della piattaforma e su molti sistemi UNIX sono supportate funzioni avanzate come i path di ricerca per le librerie shared native."

#: ../../source/chapter/Why CMake.rst:73
msgid ""
"Automatic generation of file dependencies and support for parallel builds"
" on most platforms."
msgstr "Generazione automatica di dipendenze di file e supporto per build parallele sulla maggior parte delle piattaforme."

#: ../../source/chapter/Why CMake.rst:76
msgid ""
"When developing cross-platform software, CMake provides a number of "
"additional features:"
msgstr "Durante lo sviluppo di software cross-piattaforma, CMake offre una serie di funzionalità aggiuntive:"

#: ../../source/chapter/Why CMake.rst:79
msgid ""
"The ability to test for machine byte order and other hardware-specific "
"characteristics."
msgstr "La capacità di testare l'ordine dei byte della macchina e altre caratteristiche specifiche dell'hardware."

#: ../../source/chapter/Why CMake.rst:81
msgid ""
"A single set of build configuration files that work on all platforms. "
"This avoids the problem of developers having to maintain the same "
"information in several different formats inside a project."
msgstr "Un singolo set di file di configurazione della build che funzionano su tutte le piattaforme. Ciò evita il problema degli sviluppatori che devono mantenere le stesse informazioni in diversi formati all'interno di un progetto."

#: ../../source/chapter/Why CMake.rst:84
msgid "Support for building shared libraries on all platforms that support it."
msgstr "Supporto per la creazione di librerie shared su tutte le piattaforme che lo supportano."

#: ../../source/chapter/Why CMake.rst:86
msgid ""
"The ability to configure files with system-dependent information, such as"
" the location of data files and other information. CMake can create "
"header files that contain information such as paths to data files and "
"other information in the form of ``#define`` macros. System specific "
"flags can also be placed in configured header files. This has advantages "
"over command line ``-D`` options to the compiler, because it allows other"
" build systems to use the CMake built library without having to specify "
"the exact same command line options used during the build."
msgstr "La capacità di configurare i file con informazioni dipendenti dal sistema, come la posizione dei file di dati e altre informazioni. CMake può creare file header che contengono informazioni come path di file di dati e altre informazioni sotto forma di macro ``#define``. I flag specifici del sistema possono anche essere inseriti nei file header configurati. Ciò presenta dei vantaggi rispetto alle opzioni della riga di comando ``-D`` per il compilatore, poiché consente ad altri sistemi di build di utilizzare la libreria compilata di CMake senza dover specificare esattamente le stesse opzioni della riga di comando utilizzate durante la build."

#: ../../source/chapter/Why CMake.rst:102
msgid "The History of CMake"
msgstr "La Storia di CMake"

#: ../../source/chapter/Why CMake.rst:104
msgid ""
"Since 1999, CMake has been under active development and has matured to "
"the point where it is a proven solution for a wide range of build issues."
" CMake development began as part of the `Insight Toolkit (ITK) "
"<http://www.itk.org>`_, funded by the U.S. National Library of Medicine. "
"ITK is a large software project that works on many platforms and can "
"interact with many other software packages. To support this, a powerful, "
"yet easy-to-use build tool was required. Having worked with build systems"
" for large projects in the past, the developers designed CMake to address"
" these needs. Since then CMake has continuously grown in popularity, with"
" many projects and developers adopting it for its ease-of-use and "
"flexibility. The most telling example of this is the successful adoption "
"of CMake as the build system of the `K Desktop Environment (KDE) "
"<https://kde.org>`_, arguably the largest open-source software project in"
" existence."
msgstr "Dal 1999, CMake è in fase di sviluppo attivo ed è maturato al punto da diventare una soluzione collaudata per un'ampia gamma di problemi di build. Lo sviluppo di CMake è iniziato come parte di `Insight Toolkit (ITK) <http://www.itk.org>`_, finanziato dalla statunitense \"National Library of Medicine\". ITK è un grande progetto software che funziona su molte piattaforme e può interagire con molti altri pacchetti software. Per supportarlo, era necessario uno strumento di build potente ma facile da usare. Avendo lavorato in passato con sistemi di build per progetti di grandi dimensioni, gli sviluppatori hanno progettato CMake per soddisfare queste esigenze. Da allora CMake è cresciuto costantemente in popolarità, con molti progetti e sviluppatori che lo adottano per la sua facilità d'uso e flessibilità. L'esempio più eloquente di ciò è l'adozione riuscita di CMake come sistema di build del `K Desktop Environment (KDE) <https://kde.org>`_, probabilmente il più grande progetto opensource esistente."

#: ../../source/chapter/Why CMake.rst:118
msgid ""
"CMake also includes software testing support in the form of CTest. Part "
"of the process of testing software involves building the software, "
"possibly installing it, and determining what parts of the software are "
"appropriate for the current system. This makes CTest a logical extension "
"of CMake as it already has most of this information. In a similar vein, "
"CMake contains CPack, which is designed to support cross-platform "
"distribution of software. It provides a cross-platform approach to "
"creating native installations for your software, making use of existing "
"popular packages such as WiX, RPM, Cygwin, and PackageMaker."
msgstr "CMake include anche il supporto per il test del software sotto forma di CTest. Parte del processo di test del software comporta la creazione del software, possibilmente l'installazione e la determinazione di quali parti del software sono appropriate per il sistema corrente. Ciò rende CTest un'estensione logica di CMake poiché dispone già della maggior parte di queste informazioni. Allo stesso modo, CMake contiene CPack, progettato per supportare la distribuzione cross-piattaforma del software. Fornisce un approccio multipiattaforma alla creazione di installazioni native per il software, facendo uso di pacchetti popolari esistenti come WiX, RPM, Cygwin e PackageMaker."

#: ../../source/chapter/Why CMake.rst:134
msgid ""
"CMake continues to track and support popular build tools as they become "
"available. CMake has quickly provided support for new versions of "
"Microsofts's Visual Studio and Apple's Xcode IDE. In addition, support "
"for the new build tool Ninja from Google has been added to CMake. With "
"CMake, once you write your input files you get support for new compilers "
"and build systems for free because the support for them is built into new"
" releases of CMake and not tied to your software distribution. CMake also"
" has ongoing support for cross-compiling to other operating systems or "
"embedded devices. Most commands in CMake properly handle the differences "
"between the host system and the target platform when cross-compiling."
msgstr "CMake continua a monitorare e supportare gli strumenti di creazione più diffusi non appena diventano disponibili. CMake ha rapidamente fornito supporto per le nuove versioni di Visual Studio di Microsoft e Xcode IDE di Apple. Inoltre, a CMake è stato aggiunto il supporto per il nuovo strumento di compilazione Ninja di Google. Con CMake, una volta scritti i file di input, si ottiene supporto per nuovi compilatori e sistemi di compilazione gratuitamente perché il supporto per essi è integrato nelle nuove versioni di CMake e non è legato alla distribuzione del software. CMake offre anche un supporto continuo per la cross-compilazione con altri sistemi operativi o dispositivi embedded. La maggior parte dei comandi in CMake gestisce correttamente le differenze tra il sistema host e la piattaforma target durante la cross-compilazione."

#: ../../source/chapter/Why CMake.rst:150
msgid "Why Not Use Autoconf?"
msgstr "Perché Non Usare Autoconf?"

#: ../../source/chapter/Why CMake.rst:152
msgid ""
"Before developing CMake, its authors had experience with the existing set"
" of available build tools. Autoconf combined with Automake provides some "
"of the same functionality as CMake, but to use these tools on a Windows "
"platform requires the installation of many additional tools not found "
"natively on a Windows box. In addition to requiring a host of tools, "
"autoconf can be difficult to use or extend, and impossible for performing"
" some tasks that are easy in CMake. Even if you do get autoconf and its "
"required environment running on your system, it generates Makefiles that "
"will force users to the command line. CMake on the other hand, provides a"
" choice, allowing developers to generate project files that can be used "
"directly from the IDE to which Windows and Xcode developers are "
"accustomed."
msgstr "Prima di sviluppare CMake, i suoi autori usavano il set esistente di strumenti di build disponibili. Autoconf combinato con Automake fornisce alcune delle stesse funzionalità di CMake, ma per utilizzare questi strumenti su una piattaforma Windows è necessaria l'installazione di molti strumenti aggiuntivi che non si trovano nativamente su una macchina Windows. Oltre a richiedere una serie di strumenti, autoconf può essere difficile da usare o estendere e impossibile eseguire alcune attività che risultano facili in CMake. Anche se si ha autoconf e il suo ambiente in esecuzione sul sistema, genera Makefile che costringeranno gli utenti alla riga di comando. CMake, d'altra parte, offre una scelta, consentendo agli sviluppatori di generare file di progetto utilizzabili direttamente dall'IDE a cui sono abituati gli sviluppatori Windows e Xcode."

#: ../../source/chapter/Why CMake.rst:165
msgid ""
"While autoconf supports user-specified options, it does not support "
"dependent options where one option depends on another property or "
"selection. For example, in CMake you could have a user option to have "
"multithreading be dependent on first determining if the user's system has"
" multithreading support. CMake provides an interactive user interface, "
"making it easy for the user to see which options are available and how to"
" set them."
msgstr "Sebbene autoconf supporti le opzioni specificate dall'utente, non supporta quelle dipendenti in cui un'opzione dipende da un'altra proprietà o selezione. Ad esempio, in CMake si potrebbe avere un'opzione utente per far dipendere il multithreading dalla prima determinazione se il sistema dell'utente ha il supporto multithreading. CMake fornisce un'interfaccia utente interattiva, che consente all'utente di vedere facilmente quali opzioni sono disponibili e come impostarle."

#: ../../source/chapter/Why CMake.rst:173
msgid ""
"For UNIX users, CMake also provides automated dependency generation that "
"is not done directly by autoconf. CMake's simple input format is also "
"easier to read and maintain than a combination of Makefile.in and "
"configure.in files. The ability of CMake to remember and chain library "
"dependency information has no equivalent in autoconf/automake."
msgstr "Per gli utenti UNIX, CMake fornisce anche la generazione automatica delle dipendenze che non viene gestita direttamente da autoconf. Il semplice formato di input di CMake è anche più facile da leggere e gestire rispetto a una combinazione di file Makefile.in e configure.in. La capacità di CMake di ricordare e concatenare le informazioni sulle dipendenze della libreria non ha equivalenti in autoconf/automake."

#: ../../source/chapter/Why CMake.rst:186
msgid "Why Not Use JAM, qmake, SCons, or ANT?"
msgstr "Perché non utilizzare JAM, qmake, SCons o ANT?"

#: ../../source/chapter/Why CMake.rst:188
msgid ""
"Other tools such as ANT, qmake, SCons, and JAM have taken different "
"approaches to solving these problems and they have helped us to shape "
"CMake. Of the four, qmake is the most similar to CMake, although it lacks"
" much of the system interrogation that CMake provides. Qmake's input "
"format is more closely related to a traditional Makefile. ANT, JAM, and "
"SCons are also cross-platform although they do not support generating "
"native project files. They do break away from the traditional Makefile-"
"oriented input with ANT using XML; JAM using its own language; and SCons "
"using Python. A number of these tools run the compiler directly, as "
"opposed to letting the system's build process perform that task. Many of "
"these tools require other tools such as Python or Java to be installed "
"before they will work."
msgstr "Altri strumenti come ANT, qmake, SCons e JAM hanno adottato approcci diversi per risolvere questi problemi e ci hanno aiutato a dare forma a CMake. Dei quattro, qmake è il più simile a CMake, sebbene manchi gran parte dell'interrogazione del sistema fornita da CMake. Il formato di input di Qmake è più simile a un Makefile tradizionale. Anche ANT, JAM e SCons sono multipiattaforma sebbene non supportino la generazione di file di progetto nativi. Si staccano dal tradizionale input orientato al Makefile con ANT che usa XML; JAM col proprio linguaggio; e SCons che usa Python. Alcuni di questi strumenti eseguono direttamente il compilatore, invece di lasciare che il processo di build del sistema esegua quell'attività. Molti di questi strumenti richiedono l'installazione di altri come Python o Java prima che funzionino."

#: ../../source/chapter/Why CMake.rst:202
msgid "Why Not Script It Yourself?"
msgstr "Perché non degli Script Autoprodotti?"

#: ../../source/chapter/Why CMake.rst:204
msgid ""
"Some projects use existing scripting languages such as Perl or Python to "
"configure build processes. Although similar functionality can be achieved"
" with systems like this, over-use of these tools can make the build "
"process more of an Easter egg hunt than a simple-to-use build system. "
"When building your software package, users are forced to find and install"
" version 4.3.2 of this and 3.2.4 of that before they can even start the "
"build process. To avoid that problem, it was decided that CMake would "
"require no more tools than the software it was being used to build would "
"require. At a minimum, using CMake requires a C compiler, that compiler's"
" native build tools, and a CMake executable. CMake was written in C++, "
"requires only a C++ compiler to build, and precompiled binaries are "
"available for most systems. Scripting it yourself also typically means "
"you will not be generating native Xcode or Visual Studio workspaces, "
"making Mac and Windows builds limited."
msgstr "Alcuni progetti utilizzano linguaggi di scripting esistenti come Perl o Python per configurare i processi di build. Sebbene sia possibile ottenere funzionalità simili con sistemi come questo, l'uso eccessivo di tali strumenti può rendere il processo di build più simile a una \"caccia al tesoro\" che a un sistema di build semplice da usare. Durante la creazione del pacchetto software, gli utenti sono costretti a trovare e installare la versione 4.3.2 di questo e 3.2.4 di quello prima ancora di poter avviare il processo di build. Per evitare questo problema, è stato deciso che CMake non avrebbe richiesto più strumenti di quelli richiesti dal software che veniva utilizzato per il build. Come minimo, l'utilizzo di CMake richiede un compilatore C, gli strumenti nativi del compilatore e un eseguibile CMake. CMake è stato scritto in C++, richiede solo un compilatore C++ per la compilazione e i binari precompilati sono disponibili per la maggior parte dei sistemi. Generando script autonomamente in genere significa anche che non si produrranno aree di lavoro Xcode o Visual Studio native, limitando le build di Mac e Windows."

#: ../../source/chapter/Why CMake.rst:225
msgid "On What Platforms Does CMake Run?"
msgstr "Su quali piattaforme funziona CMake?"

#: ../../source/chapter/Why CMake.rst:227
msgid ""
"CMake runs on a wide variety of platforms including Microsoft Windows, "
"Apple Mac OS X, and most UNIX or UNIX-like platforms. Likewise, CMake "
"supports most common compilers."
msgstr "CMake funziona su un'ampia varietà di piattaforme tra cui Microsoft Windows, Apple Mac OS X e la maggior parte delle piattaforme UNIX o simili. Allo stesso modo, CMake supporta i compilatori più comuni."

#: ../../source/chapter/Why CMake.rst:232
msgid "How Stable is CMake?"
msgstr "Quanto è stabile CMake?"

#: ../../source/chapter/Why CMake.rst:234
msgid ""
"Before adopting any new technology or tool for a project, a developer "
"will want to know how well supported and popular the tool is. Since the "
"initial CMake implementation , CMake has grown in popularity as a build "
"tool. Both the developer and user communities continue to grow. CMake has"
" continued to develop support for new build technologies and tools as "
"they become available. The CMake development team has a strong commitment"
" to backwards compatibility. If CMake can build your project once, it "
"should always be able to build your project. Also, since CMake is an "
"open-source project, the source code is always available for a project to"
" edit and patch as needed."
msgstr "Prima di adottare qualsiasi nuova tecnologia o strumento per un progetto, uno sviluppatore vorrà sapere quanto è ben supportato e popolare. Dall'implementazione iniziale, CMake è cresciuto in popolarità come strumento di build. Sia la community di sviluppatori che quella di utenti continuano a crescere. CMake ha continuato a sviluppare il supporto per nuove tecnologie e strumenti di build non appena si rendono disponibili. Il team di sviluppo di CMake è molto impegnato per la compatibilità con le versioni precedenti. Se CMake può creare il progetto una volta, dovrebbe essere in grado di farlo sempre. Inoltre, poiché CMake è un progetto open source, il codice sorgente è sempre disponibile per un progetto da modificare e correggere secondo necessità."

#: ../../source/chapter/Writing CMakeLists Files.rst:2
msgid "Writing CMakeLists Files"
msgstr "Scrivere File CMakeLists"

#: ../../source/chapter/Writing CMakeLists Files.rst:4
msgid ""
"This chapter will cover the basics of writing effective CMakeLists files "
"for your software. It will cover the basic commands and issues you will "
"need to handle most projects. While CMake can handle extremely complex "
"projects, for most projects you will find this chapter's contents will "
"tell you all you need to know. CMake is driven by the CMakeLists.txt "
"files written for a software project. The CMakeLists files determine "
"everything from which options to present to users, to which source files "
"to compile. In addition to discussing how to write a CMakeLists file, "
"this chapter will also cover how to make them robust and maintainable."
msgstr "Questo capitolo tratterà le basi della scrittura di file CMakeLists efficaci. Tratterà i comandi e i problemi di base necessari per gestire la maggior parte dei progetti. Sebbene CMake sia in grado di gestire progetti estremamente complessi, per la maggior parte dei progetti si scoprirà che i contenuti di questo capitolo diranno tutto ciò che c'è da sapere. CMake è guidato dai file CMakeLists.txt scritti per un progetto software. I file CMakeLists determinano tutto, da quali opzioni presentare agli utenti, a quali file sorgente compilare. Oltre a discutere come scrivere un file CMakeLists, questo capitolo tratterà anche come renderli robusti e manutenibili."

#: ../../source/chapter/Writing CMakeLists Files.rst:16
msgid "Editing CMakeLists Files"
msgstr "Modifica dei file CMakeLists"

#: ../../source/chapter/Writing CMakeLists Files.rst:18
msgid ""
"CMakeLists files can be edited in almost any text editor. Some editors, "
"such as Notepad++, come with CMake syntax highlighting and indentation "
"support built-in. For editors such as Emacs or Vim, CMake includes "
"indentation and syntax highlighting modes. These can be found in the "
"``Auxiliary`` directory of the source distribution, or downloaded from "
"the CMake `Download <www.cmake.org/download>`_ page."
msgstr "I file CMakeLists possono essere modificati in quasi tutti gli editor di testo. Alcuni editor, come Notepad++, vengono forniti con l'evidenziazione della sintassi CMake e il supporto dell'indentazione. Per editor come Emacs o Vim, CMake include modalità di indentazione e di evidenziazione della sintassi. Questi si trovano nella directory ``Auxiliary`` della distribuzione sorgente o si possono scaricare dalla pagina di `Download <www.cmake.org/download>`_ di CMake."

#: ../../source/chapter/Writing CMakeLists Files.rst:25
msgid ""
"Within any of the supported generators (Makefiles, Visual Studio, etc.), "
"if you edit a CMakeLists file and rebuild, there are rules that will "
"automatically invoke CMake to update the generated files (e.g. Makefiles "
"or project files) as required. This helps to assure that your generated "
"files are always in sync with your CMakeLists files."
msgstr "All'interno di uno qualsiasi dei generatori supportati (Makefile, Visual Studio, ecc.), se si modifica un file CMakeLists e lo re-builda, ci sono regole che richiameranno automaticamente CMake per aggiornare i file generati (ad es. Makefile o file di progetto) come richiesto. Questo contribuisce a garantire che i file generati siano sempre sincronizzati con i file CMakeLists."

#: ../../source/chapter/Writing CMakeLists Files.rst:36
msgid "CMake Language"
msgstr "Il Linguaggio CMake"

#: ../../source/chapter/Writing CMakeLists Files.rst:38
msgid "The CMake language is composed of comments, commands, and variables."
msgstr "Il linguaggio CMake è composto da commenti, comandi e variabili."

#: ../../source/chapter/Writing CMakeLists Files.rst:47
msgid "Comments"
msgstr "Commenti"

#: ../../source/chapter/Writing CMakeLists Files.rst:49
msgid ""
"Comments start with ``#`` and run to the end of the line. See the :manual"
":`cmake-language <cmake-language(7)>` manual for more details."
msgstr "I commenti iniziano con ``#`` e vanno fino alla fine della riga. Vedere il manuale :manual:`cmake-language <cmake-language(7)>` per maggiori dettagli."

#: ../../source/chapter/Writing CMakeLists Files.rst:56
msgid "Variables"
msgstr "Variabili"

#: ../../source/chapter/Writing CMakeLists Files.rst:58
msgid ""
"CMakeLists files use variables much like any programming language. CMake "
"variable names are case sensitive and may only contain alphanumeric "
"characters and underscores."
msgstr "I file CMakeLists utilizzano variabili in modo molto simile a qualsiasi altro linguaggio di programmazione. I nomi delle variabili CMake fanno distinzione tra maiuscole e minuscole e possono contenere solo caratteri alfanumerici e caratteri di sottolineatura."

#: ../../source/chapter/Writing CMakeLists Files.rst:62
msgid ""
"A number of useful variables are automatically defined by CMake and are "
"discussed in the  :manual:`cmake-variables <cmake-variables(7)>` manual. "
"These variables begin with ``CMAKE_``. Avoid this naming convention (and,"
" ideally, establish your own) for variables specific to your project."
msgstr "Un certo numero di variabili utili sono definite automaticamente da CMake e sono discusse nel manuale :manual:`cmake-variables <cmake-variables(7)>`. Tali variabili iniziano con ``CMAKE_``. Evitare questa convenzione di denominazione (e, idealmente, stabilirne una propria) per le variabili specifiche del progetto."

#: ../../source/chapter/Writing CMakeLists Files.rst:67
msgid ""
"All CMake variables are stored internally as strings although they may "
"sometimes be interpreted as other types."
msgstr "Tutte le variabili CMake sono memorizzate internamente come stringhe sebbene a volte possano essere interpretate come altri tipi."

#: ../../source/chapter/Writing CMakeLists Files.rst:70
msgid ""
"Use the :command:`set` command to set variable values. In its simplest "
"form, the first argument to :command:`set` is the name of the variable "
"and the rest of the arguments are the values. Multiple value arguments "
"are packed into a semicolon-separated list and stored in the variable as "
"a string. For example:"
msgstr "Usare il comando :command:`set` per impostare i valori delle variabili. Nella sua forma più semplice, il primo argomento di :command:`set` è il nome della variabile e il resto degli argomenti sono i valori. Più argomenti di valore vengono inseriti in un elenco separato da punti e virgola e memorizzati nella variabile come stringa. Per esempio:"

#: ../../source/chapter/Writing CMakeLists Files.rst:83
msgid ""
"Variables may be referenced in command arguments using syntax ``${VAR}`` "
"where ``VAR`` is the variable name. If the named variable is not defined,"
" the reference is replaced with an empty string; otherwise it is replaced"
" by the value of the variable. Replacement is performed prior to the "
"expansion of unquoted arguments, so variable values containing semicolons"
" are split into zero-or-more arguments in place of the original unquoted "
"argument. For example:"
msgstr "È possibile fare riferimento alle variabili negli argomenti del comando utilizzando la sintassi ``${VAR}`` dove ``VAR`` è il nome della variabile. Se la variabile richiamata non è definita, il riferimento viene sostituito con una stringa vuota; in caso contrario viene sostituito dal valore della variabile. La sostituzione viene eseguita prima dell'espansione degli argomenti non quotati, quindi i valori delle variabili contenenti punti e virgola vengono suddivisi in zero o più argomenti al posto dell'argomento originale non quotato. Per esempio:"

#: ../../source/chapter/Writing CMakeLists Files.rst:106
msgid ""
"System environment variables and Windows registry values can be accessed "
"directly in CMake. To access system environment variables, use the syntax"
" ``$ENV{VAR}``. CMake can also reference registry entries in many "
"commands using a syntax of the form "
"``[HKEY_CURRENT_USER\\\\Software\\\\path1\\\\path2;key]``, where the "
"paths are built from the registry tree and key."
msgstr "È possibile accedere direttamente alle variabili di ambiente di sistema e ai valori del registro di Windows in CMake. Per accedere alle variabili di ambiente di sistema, utilizzare la sintassi ``$ENV{VAR}``. CMake può anche fare riferimento alle voci di registro in molti comandi utilizzando una sintassi della forma ``[HKEY_CURRENT_USER\\\\Software\\\\path1\\\\path2;key]``, dove i percorsi sono costruiti dalla struttura e dalla chiave del registro."

#: ../../source/chapter/Writing CMakeLists Files.rst:117
msgid "Variable Scope"
msgstr "Scope delle Variabili"

#: ../../source/chapter/Writing CMakeLists Files.rst:119
msgid ""
"Variables in CMake have a scope that is a little different from most "
"languages. When you set a variable, it is visible to the current "
"CMakeLists file or function and any subdirectory's CMakeLists files, any "
"functions or macros that are invoked, and any files that are included "
"using the :command:`include` command. When a new subdirectory is "
"processed (or a function called), a new variable scope is created and "
"initialized with the current value of all variables in the calling scope."
" Any new variables created in the child scope, or changes made to "
"existing variables, will not impact the parent scope. Consider the "
"following example:"
msgstr "Le variabili in CMake hanno uno scope leggermente diverso da quello della maggior parte dei linguaggi. Quando si imposta una variabile, essa è visibile al file o alla funzione CMakeLists corrente e ai file CMakeLists di qualsiasi sottodirectory, a qualsiasi funzione o macro richiamata e a qualsiasi file incluso utilizzando il comando :command:`include`. Quando viene elaborata una nuova sottodirectory (o viene chiamata una funzione), viene creato e inizializzato un nuovo scope di variabile con il valore corrente di tutte le variabili nello scope chiamante. Eventuali nuove variabili create nello scope figlio o le modifiche apportate alle variabili esistenti non influiranno sullo scope padre. Si consideri l'esempio seguente:"

#: ../../source/chapter/Writing CMakeLists Files.rst:142
msgid ""
"In some cases, you might want a function or subdirectory to set a "
"variable in its parent's scope. There is a way for CMake to return a "
"value from a function, and it can be done by using the ``PARENT_SCOPE`` "
"option with the :command:`set` command. We can modify the prior example "
"so that the function ``foo`` changes the value of test in its parent's "
"scope as follows:"
msgstr "A volte, si vorrebbe che una funzione o una sottodirectory imposti una variabile nello scope del suo genitore. Esiste un modo per CMake di restituire un valore da una funzione e può essere fatto utilizzando l'opzione ``PARENT_SCOPE`` col comando :command:`set`. Possiamo modificare l'esempio precedente in modo che la funzione ``foo`` cambi il valore di test nello scope del suo genitore in questo modo:"

#: ../../source/chapter/Writing CMakeLists Files.rst:161
msgid ""
"Variables in CMake are defined in the order of the execution of "
":command:`set` commands."
msgstr "Le variabili in CMake sono definite nell'ordine di esecuzione dei comandi :command:`set`."

#: ../../source/chapter/Writing CMakeLists Files.rst:164
msgid "Consider the following example:"
msgstr "Si consideri l'esempio seguente:"

#: ../../source/chapter/Writing CMakeLists Files.rst:176
msgid "To understand the scope of variables, consider this example:"
msgstr "Per comprendere lo scope delle variabili, si consideri questo esempio:"

#: ../../source/chapter/Writing CMakeLists Files.rst:195
msgid ""
"In this example, because the variable ``foo`` is defined at the "
"beginning, it will be defined while processing both dir1 and dir2. In "
"contrast, ``bar`` will only be defined when processing dir2. Likewise, "
"``foo`` will be defined when processing both file1.cmake and file2.cmake,"
" whereas ``bar`` will only be defined while processing file2.cmake."
msgstr "In questo esempio, poiché la variabile ``foo`` è definita all'inizio, verrà definita durante l'elaborazione sia di dir1 che di dir2. Al contrario, ``bar`` sarà definito solo durante l'elaborazione di dir2. Allo stesso modo, ``foo`` sarà definito durante l'elaborazione sia di file1.cmake che di file2.cmake, mentre ``bar`` sarà definito solo durante l'elaborazione di file2.cmake."

#: ../../source/chapter/Writing CMakeLists Files.rst:203
msgid "Commands"
msgstr "Comandi"

#: ../../source/chapter/Writing CMakeLists Files.rst:205
msgid ""
"A command consists of the command name, opening parenthesis, whitespace "
"separated arguments, and a closing parenthesis. Each command is evaluated"
" in the order that it appears in the CMakeLists file. See the :manual"
":`cmake-commands <cmake-commands(7)>` manual for a full list of CMake "
"commands."
msgstr "Un comando consiste nel nome del comando, parentesi di apertura, argomenti separati da spazi e parentesi di chiusura. Ogni comando viene valutato nell'ordine in cui appare nel file CMakeLists. Consultare il manuale :manual:`cmake-commands <cmake-commands(7)>` per l'elenco completo dei comandi CMake."

#: ../../source/chapter/Writing CMakeLists Files.rst:214
msgid ""
"CMake is no longer case sensitive to command names, so where you see "
"``command``, you could use ``COMMAND`` or ``Command`` instead. It is "
"considered best practice to use lowercase commands.  All whitespace "
"(spaces, line feeds, tabs) is ignored except to separate arguments. "
"Therefore, commands may span multiple lines as long as the command name "
"and the opening parenthesis are on the same line."
msgstr "CMake non fa più distinzione tra maiuscole e minuscole per i nomi dei comandi, quindi dove si vede ``command``, si può usare ``COMMAND`` o ``Command``. È considerata \"best practice\" utilizzare i comandi in minuscolo.  Tutti i \"whitespace\" (spazi, line feed, tabulazioni) vengono ignorati tranne che per separare gli argomenti. Pertanto, i comandi possono estendersi su più righe purché il nome del comando e la parentesi di apertura si trovino sulla stessa riga."

#: ../../source/chapter/Writing CMakeLists Files.rst:224
msgid ""
"CMake command arguments are space separated and case sensitive. Command "
"arguments may be either quoted or unquoted.  A quoted argument starts and"
" ends in a double quote (\") and always represents exactly one argument. "
"Any double quotes contained inside the value must be escaped with a "
"backslash. Consider using bracket arguments for arguments that require "
"escaping, see the :manual:`cmake-language <cmake-language(7)>` manual. An"
" unquoted argument starts in any character other than a double quote "
"(later double quotes are literal) and is automatically expanded into "
"zero-or-more arguments by separating on semicolons within the value.  For"
" example:"
msgstr "Gli argomenti dei comandi CMake sono separati da spazi e fanno distinzione tra maiuscole e minuscole. Gli argomenti dei comandi possono essere quotati o non quotati.  Un argomento quotato (tra virgolette) inizia e finisce con un doppio apice (\") e rappresenta sempre esattamente un argomento. Eventuali virgolette doppie contenute all'interno del valore devono essere precedute da una barra rovesciata [backslash]. Si consideri l'utilizzo di argomenti tra parentesi per argomenti che richiedono l'escape, consultare il manuale :manual:`cmake-language <cmake-language(7)>`. Un argomento non quotato inizia con qualsiasi carattere diverso da un doppio apice (successivamente le doppie virgolette sono letterali) e viene automaticamente espanso in zero o più argomenti separando col punto e virgola all'interno del valore.  Per esempio:"

#: ../../source/chapter/Writing CMakeLists Files.rst:244
msgid "Basic Commands"
msgstr "Comandi di Base"

#: ../../source/chapter/Writing CMakeLists Files.rst:246
msgid ""
"As we saw earlier, the :command:`set` and :command:`unset` commands "
"explicitly set or unset variables. The :command:`string`, "
":command:`list`, and :command:`separate_arguments` commands offer basic "
"manipulation of strings and lists."
msgstr "Come visto in precedenza, i comandi :command:`set` e :command:`unset` impostano o annullano esplicitamente le variabili. I comandi :command:`string`, :command:`list` e :command:`separate_arguments` offrono comandi di base per manipolare stringhe e liste."

#: ../../source/chapter/Writing CMakeLists Files.rst:250
msgid ""
"The :command:`add_executable` and :command:`add_library` commands are the"
" main commands for defining the executables and libraries to build, and "
"which source files comprise them. For Visual Studio projects, the source "
"files will show up in the IDE as usual, but any header files the project "
"uses will not be. To have the header files show up, simply add them to "
"the list of source files for the executable or library; this can be done "
"for all generators. Any generators that do not use the header files "
"directly (such as Makefile based generators) will simply ignore them."
msgstr "I comandi :command:`add_executable` e :command:`add_library` sono i comandi principali per definire gli eseguibili e le librerie da compilare e quali file sorgenti li comprendono. Per i progetti di Visual Studio, i file sorgenti verranno visualizzati nell'IDE come di consueto, ma i file header utilizzati dal progetto non lo saranno. Per visualizzare i file header, si aggiungerli all'elenco dei file sorgenti per l'eseguibile o la libreria; questo può essere fatto per tutti i generatori. Tutti i generatori che non usano direttamente i file header (come quelli basati su Makefile) semplicemente li ignoreranno."

#: ../../source/chapter/Writing CMakeLists Files.rst:268
msgid "Flow Control"
msgstr "Controllo del Flusso"

#: ../../source/chapter/Writing CMakeLists Files.rst:270
msgid ""
"The CMake language provides three flow control constructs to help "
"organize your CMakeLists files and keep them maintainable."
msgstr "Il linguaggio CMake fornisce tre costrutti per il controllo del flusso per aiutare a organizzare i file CMakeLists e mantenerli gestibili."

#: ../../source/chapter/Writing CMakeLists Files.rst:273
msgid "Conditional statements (e.g. :command:`if`)"
msgstr "Le istruzioni condizionali (ad es. :command:`if`)"

#: ../../source/chapter/Writing CMakeLists Files.rst:274
msgid "Looping constructs (e.g. :command:`foreach` and :command:`while`)"
msgstr "Costrutti per i cicli (ad es. :command:`foreach` e :command:`while`)"

#: ../../source/chapter/Writing CMakeLists Files.rst:275
msgid "Procedure definitions (e.g. :command:`macro` and :command:`function`)"
msgstr "Definizioni di procedure (ad es. :command:`macro` e :command:`function`)"

#: ../../source/chapter/Writing CMakeLists Files.rst:278
msgid "Conditional Statements"
msgstr "Istruzioni Condizionali"

#: ../../source/chapter/Writing CMakeLists Files.rst:280
msgid ""
"First we will consider the :command:`if` command. In many ways, the "
":command:`if` command in CMake is just like the :command:`if` command in "
"any other language. It evaluates its expression and uses it to execute "
"the code in its body or optionally the code in the :command:`else` "
"clause. For example:"
msgstr "Per prima cosa considereremo il comando :command:`if`. In molti modi, il comando :command:`if` in CMake è proprio come il comando :command:`if` in qualsiasi altro linguaggio. Valuta la sua espressione e la usa per eseguire il codice nel suo corpo o facoltativamente il codice nella clausola :command:`else`. Per esempio:"

#: ../../source/chapter/Writing CMakeLists Files.rst:294
msgid ""
"CMake also supports :command:`elseif` to help sequentially test for "
"multiple conditions. For example:"
msgstr "CMake supporta anche :command:`elseif` per aiutare a testare in sequenza più condizioni. Per esempio:"

#: ../../source/chapter/Writing CMakeLists Files.rst:307
msgid "The :command:`if` command documents the many conditions it can test."
msgstr "Il comando :command:`if` documenta le molte condizioni che può testare."

#: ../../source/chapter/Writing CMakeLists Files.rst:310
msgid "Looping Constructs"
msgstr "Costrutti per i Cicli"

#: ../../source/chapter/Writing CMakeLists Files.rst:312
msgid ""
"The :command:`foreach` and :command:`while` commands allow you to handle "
"repetitive tasks that occur in sequence. The :command:`break` command "
"breaks out of a :command:`foreach` or :command:`while` loop before it "
"would normally end."
msgstr "I comandi :command:`foreach` e :command:`while` consentono di gestire attività ripetitive che si verificano in sequenza. Il comando :command:`break` interrompe un ciclo :command:`foreach` o :command:`while` prima che termini normalmente."

#: ../../source/chapter/Writing CMakeLists Files.rst:317
msgid ""
"The :command:`foreach` command enables you to execute a group of CMake "
"commands repeatedly on the members of a list. Consider the following "
"example adapted from VTK"
msgstr "Il comando :command:`foreach` consente di eseguire ripetutamente un gruppo di comandi CMake sui membri di un elenco. Si consideri il seguente esempio adattato da VTK"

#: ../../source/chapter/Writing CMakeLists Files.rst:342
msgid ""
"The first argument of the :command:`foreach` command is the name of the "
"variable that will take on a different value with each iteration of the "
"loop; the remaining arguments are the list of values over which to loop. "
"In this example, the body of the :command:`foreach` loop is just one "
"CMake command, :command:`add_test`. In the body of the "
":command:`foreach`, each time the loop variable (``tfile`` in this "
"example) is referenced will be replaced with the current value from the "
"list. In the first iteration, occurrences of ``${tfile}`` will be "
"replaced with ``TestAnisotropicDiffusion2D``. In the next iteration, "
"``${tfile}`` will be replaced with ``TestButterworthLowPass``. The "
":command:`foreach` loop will continue to loop until all of the arguments "
"have been processed."
msgstr "Il primo argomento del comando :command:`foreach` è il nome della variabile che assumerà un valore diverso ad ogni iterazione del ciclo; gli argomenti rimanenti sono l'elenco di valori su cui eseguire il ciclo. In questo esempio, il corpo del ciclo :command:`foreach` è solo un comando CMake, :command:`add_test`. Nel corpo di :command:`foreach`, ogni volta che si fa riferimento alla variabile del ciclo (``tfile`` in questo esempio) verrà sostituita con il valore corrente dall'elenco. Nella prima iterazione, le occorrenze di ``${tfile}`` verranno sostituite con ``TestAnisotropicDiffusion2D``. Nella successiva iterazione, ``${tfile}`` verrà sostituito con ``TestButterworthLowPass``. Il ciclo :command:`foreach` continuerà fino a quando tutti gli argomenti non saranno stati elaborati."

#: ../../source/chapter/Writing CMakeLists Files.rst:354
msgid ""
"It is worth mentioning that :command:`foreach` loops can be nested, and "
"that the loop variable is replaced prior to any other variable expansion."
" This means that in the body of a :command:`foreach` loop, you can "
"construct variable names using the loop variable. In the code below, the "
"loop variable ``tfile`` is expanded, and then concatenated with "
"``_TEST_RESULT``. The new variable name is then expanded and tested to "
"see if it matches ``FAILED``."
msgstr "Vale la pena ricordare che i cicli :command:`foreach` possono essere nidificati e che la variabile del ciclo viene sostituita prima di qualsiasi altra espansione della variabile. Ciò significa che nel corpo di un ciclo :command:`foreach`, si possono costruire nomi di variabili usando la variabile del ciclo. Nel codice seguente, la variabile di ciclo ``tfile`` viene espansa e quindi concatenata con ``_TEST_RESULT``. Il nuovo nome della variabile viene quindi espanso e testato per vedere se corrisponde a ``FAILED``."

#: ../../source/chapter/Writing CMakeLists Files.rst:368
msgid ""
"The :command:`while` command provides looping based on a test condition. "
"The format for the test expression in the :command:`while` command is the"
" same as it is for the :command:`if` command, as described earlier. "
"Consider the following example, which is used by CTest. Note that CTest "
"updates the value of ``CTEST_ELAPSED_TIME`` internally."
msgstr "Il comando :command:`while` fornisce il ciclo basato su una condizione di test. Il formato per l'espressione di test nel comando :command:`while` è lo stesso del comando :command:`if`, come descritto. Si consideri l'esempio seguente, utilizzato da CTest. Da notare che CTest aggiorna internamente il valore di ``CTEST_ELAPSED_TIME``."

#: ../../source/chapter/Writing CMakeLists Files.rst:386
msgid "Procedure Definitions"
msgstr "Definizioni delle Procedure"

#: ../../source/chapter/Writing CMakeLists Files.rst:388
msgid ""
"The :command:`macro` and :command:`function` commands support repetitive "
"tasks that may be scattered throughout your CMakeLists files. Once a "
"macro or function is defined, it can be used by any CMakeLists files "
"processed after its definition."
msgstr "I comandi :command:`macro` e :command:`function` supportano attività ripetitive che possono essere sparse nei file CMakeLists. Una volta definita una macro o una funzione, questa può essere utilizzata da qualsiasi file CMakeLists elaborato dopo la sua definizione."

#: ../../source/chapter/Writing CMakeLists Files.rst:393
msgid ""
"A function in CMake is very much like a function in C or C++. You can "
"pass arguments into it, and they become variables within the function. "
"Likewise, some standard variables such as ``ARGC``, ``ARGV``, ``ARGN``, "
"and ``ARGV0``, ``ARGV1``, etc. are defined. Function calls have a dynamic"
" scope.  Within a function you are in a new variable scope; this is like "
"how you drop into a subdirectory using the :command:`add_subdirectory` "
"command and are in a new variable scope. All the variables that were "
"defined when the function was called remain defined, but any changes to "
"variables or new variables only exist within the function. When the "
"function returns, those variables will go away. Put more simply: when you"
" invoke a function, a new variable scope is pushed; when it returns, that"
" variable scope is popped."
msgstr "Una funzione in CMake è molto simile a una funzione in C o C++. Le si possono passare degli argomenti e questi diventano variabili all'interno della funzione. Allo stesso modo, sono definite alcune variabili standard come ``ARGC``, ``ARGV``, ``ARGN`` e ``ARGV0``, ``ARGV1``, ecc. Le chiamate a funzioni hanno uno scope dinamico.  All'interno di una funzione ci si trova in un nuovo scope variabile; è come entrare in una sottodirectory usando il comando :command:`add_subdirectory` e trovarsi in un nuovo scope variabile. Tutte le variabili che sono state definite quando la funzione è stata chiamata rimangono definite, ma eventuali modifiche alle variabili o le nuove variabili esistono solo all'interno della funzione. Quando la funzione ritorna, quelle variabili andranno via. In parole povere: quando si invoca una funzione, viene inserito un nuovo scope variabile; quando ritorna, quello scope variabile viene ripreso."

#: ../../source/chapter/Writing CMakeLists Files.rst:407
msgid ""
"The :command:`function` command defines a new function.  The first "
"argument is the name of the function to define; all additional arguments "
"are formal parameters to the function."
msgstr "Il comando :command:`function` definisce una nuova funzione.  Il primo argomento è il nome della funzione da definire; tutti gli argomenti aggiuntivi sono parametri formali della funzione."

#: ../../source/chapter/Writing CMakeLists Files.rst:425
msgid ""
"Note that in this example, ``_time`` is used to pass the name of the "
"return variable. The :command:`set` command is invoked with the value of "
"``_time``, which will be ``current_time``. Finally, the :command:`set` "
"command uses the ``PARENT_SCOPE`` option to set the variable in the "
"caller's scope instead of the local scope."
msgstr "Notare che in questo esempio, ``_time`` viene utilizzato per passare il nome della variabile restituita. Il comando :command:`set` viene invocato con il valore di ``_time``, che sarà ``current_time``. Infine, il comando :command:`set` utilizza l'opzione ``PARENT_SCOPE`` per impostare la variabile nello scope del chiamante anziché in quello locale."

#: ../../source/chapter/Writing CMakeLists Files.rst:435
msgid ""
"Macros are defined and called in the same manner as functions. The main "
"differences are that a macro does not push and pop a new variable scope, "
"and that the arguments to a macro are not treated as variables but as "
"strings replaced prior to execution. This is very much like the "
"differences between a macro and a function in C or C++. The first "
"argument is the name of the macro to create; all additional arguments are"
" formal parameters to the macro."
msgstr "Le macro vengono definite e chiamate allo stesso modo delle funzioni. Le differenze principali sono che una macro non esegue il push e il pop di un nuovo scope variabile e che gli argomenti di una macro non vengono trattati come variabili ma come stringhe sostituite prima dell'esecuzione. Questo è molto simile alle differenze tra una macro e una funzione in C o C++. Il primo argomento è il nome della macro da creare; tutti gli argomenti aggiuntivi sono parametri formali della macro."

#: ../../source/chapter/Writing CMakeLists Files.rst:456
msgid ""
"The simple example above creates a macro called ``assert``. The macro is "
"defined into two arguments; the first is a value to test and the second "
"is a comment to print out if the test fails. The body of the macro is a "
"simple :command:`if` command with a :command:`message` command inside of "
"it. The macro body ends when the :command:`endmacro` command is found. "
"The macro can be invoked simply by using its name as if it were a "
"command. In the above example, if ``FOO_LIB`` was not found then a "
"message would be displayed indicating the error condition."
msgstr "Il semplice esempio precedente crea una macro chiamata ``assert``. La macro è definita in due argomenti; il primo è un valore da testare e il secondo è un commento da stampare se il test fallisce. Il corpo della macro è un semplice comando :command:`if` con un comando :command:`message` al suo interno. Il corpo della macro termina quando viene trovato il comando :command:`endmacro`. La macro può essere invocata semplicemente usando il suo nome come se fosse un comando. Nell'esempio precedente, se ``FOO_LIB`` non è stato trovato, verrà visualizzato un messaggio che indica la condizione di errore."

#: ../../source/chapter/Writing CMakeLists Files.rst:468
msgid ""
"The :command:`macro` command also supports defining macros that take "
"variable argument lists. This can be useful if you want to define a macro"
" that has optional arguments or multiple signatures. Variable arguments "
"can be referenced using ``ARGC`` and ``ARGV0``, ``ARGV1``, etc., instead "
"of the formal parameters. ``ARGV0`` represents the first argument to the "
"macro; ``ARGV1`` represents the next, and so forth. You can also use a "
"mixture of formal arguments and variable arguments, as shown in the "
"example below."
msgstr "Il comando :command:`macro` supporta anche la definizione di macro che accettano elenchi variabili di argomenti. Ciò può essere utile se si desidera definire una macro con argomenti facoltativi o firme multiple. Gli argomenti variabili possono essere referenziati usando ``ARGC`` e ``ARGV0``, ``ARGV1``, ecc., invece dei parametri formali. ``ARGV0`` rappresenta il primo argomento della macro; ``ARGV1`` rappresenta il successivo e così via. È inoltre possibile utilizzare una combinazione di argomenti formali e argomenti variabili, come mostrato nell'esempio seguente."

#: ../../source/chapter/Writing CMakeLists Files.rst:498
msgid ""
"In this example, the two required arguments are ``TEST`` and ``COMMENT``."
" These required arguments can be referenced by name, as they are in this "
"example, or by referencing ``ARGV0`` and ``ARGV1``. If you want to "
"process the arguments as a list, use the ``ARGV`` and ``ARGN`` variables."
" ``ARGV`` (as opposed to ``ARGV0``, ``ARGV1``, etc) is a list of all the "
"arguments to the macro, while ``ARGN`` is a list of all the arguments "
"after the formal arguments. Inside your macro, you can use the "
":command:`foreach` command to iterate over ``ARGV`` or ``ARGN`` as "
"desired."
msgstr "In questo esempio, i due argomenti obbligatori sono ``TEST`` e ``COMMENT``. È possibile fare riferimento a questi argomenti obbligatori per nome, come in questo esempio, o facendo riferimento a ``ARGV0`` e ``ARGV1``. Per elaborare gli argomenti come una lista, usare le variabili ``ARGV`` e ``ARGN``. ``ARGV`` (al contrario di ``ARGV0``, ``ARGV1``, ecc.) è un elenco di tutti gli argomenti della macro, mentre ``ARGN`` è un elenco di tutti gli argomenti dopo gli argomenti formali. All'interno della macro, si può utilizzare il comando :command:`foreach` per iterare su ``ARGV`` o ``ARGN`` come desiderato."

#: ../../source/chapter/Writing CMakeLists Files.rst:508
msgid ""
"The :command:`return` command returns from a function, directory or file."
" Note that a macro, unlike a function, is expanded in place and therefore"
" cannot handle :command:`return`."
msgstr "Il comando :command:`return` ritorna da una funzione, directory o file. Notare che una macro, a differenza di una funzione, viene espansa sul posto e quindi non può gestire :command:`return`."

#: ../../source/chapter/Writing CMakeLists Files.rst:516
msgid "Regular Expressions"
msgstr "Espressioni Regolari"

#: ../../source/chapter/Writing CMakeLists Files.rst:518
msgid ""
"A few CMake commands, such as :command:`if` and :command:`string`, make "
"use of regular expressions or can take a regular expression as an "
"argument. In its simplest form, a regular expression is a sequence of "
"characters used to search for exact character matches. However, many "
"times the exact sequence to be found is unknown, or only a match at the "
"beginning or end of a string is desired. Since there are several "
"different conventions for specifying regular expressions, CMake's "
"standard is described in the :command:`string` command documentation. The"
" description is based on the open source regular expression class from "
"Texas Instruments, which is used by CMake for parsing regular "
"expressions."
msgstr "Alcuni comandi CMake, come :command:`if` e :command:`string`, fanno uso di espressioni regolari o possono prendere un'espressione regolare come argomento. Nella sua forma più semplice, un'espressione regolare è una sequenza di caratteri utilizzata per cercare corrispondenze esatte di caratteri. Tuttavia, molte volte la sequenza esatta da trovare è sconosciuta o si desidera solo una corrispondenza all'inizio o alla fine di una stringa. Poiché esistono diverse convenzioni per specificare le espressioni regolari, lo standard di CMake è descritto nella documentazione del comando :command:`string`. La descrizione si basa sulla classe di espressioni regolari open source di Texas Instruments, utilizzata da CMake per l'analisi delle espressioni regolari."

#: ../../source/chapter/Writing CMakeLists Files.rst:530
msgid "Advanced Commands"
msgstr "Comandi Avanzati"

#: ../../source/chapter/Writing CMakeLists Files.rst:535
msgid ""
"There are a few commands that can be very useful, but are not typically "
"used in writing CMakeLists files. This section will discuss a few of "
"these commands and when they are useful."
msgstr "Esistono alcuni comandi che possono essere molto utili, ma in genere non vengono utilizzati nella scrittura di file CMakeLists. Questa sezione tratterà alcuni di questi comandi e quando risultano utili."

#: ../../source/chapter/Writing CMakeLists Files.rst:539
msgid ""
"First, consider the :command:`add_dependencies` command which creates a "
"dependency between two targets. CMake automatically creates dependencies "
"between targets when it can determine them. For example, CMake will "
"automatically create a dependency for an executable target that depends "
"on a library target. The :command:`add_dependencies` command is typically"
" used to specify inter-target dependencies between targets where at least"
" one of the targets is a custom target (see :ref:`add_custom_command` "
"section)."
msgstr "Innanzitutto, si considera il comando :command:`add_dependencies` che crea una dipendenza tra due target. CMake crea automaticamente dipendenze tra i target quando può determinarle. Ad esempio, CMake creerà automaticamente una dipendenza per un target eseguibile che dipende da un target libreria. Il comando :command:`add_dependencies` viene in genere utilizzato per specificare le dipendenze inter-target in cui almeno uno è un target personalizzato (vedere la sezione :ref:`add_custom_command`)."

#: ../../source/chapter/Writing CMakeLists Files.rst:550
msgid ""
"The :command:`include_regular_expression` command also relates to "
"dependencies. This command controls the regular expression that is used "
"for tracing source code dependencies. By default, CMake will trace all "
"the dependencies for a source file including system files such as "
"``stdio.h``. If you specify a regular expression with the "
":command:`include_regular_expression` command, that regular expression "
"will be used to limit which include files are processed. For example; if "
"your software project's include files all started with the prefix foo "
"(e.g. ``fooMain.c fooStruct.h``, etc), you could specify a regular "
"expression of ``^foo.*$`` to limit the dependency checking to just the "
"files of your project."
msgstr "Anche il comando :command:`include_regular_expression` riguarda le dipendenze. Questo comando controlla l'espressione regolare utilizzata per tracciare [trace] le dipendenze del codice sorgente. Per default, CMake traccerà [trace] tutte le dipendenze per un file sorgente inclusi i file di sistema come ``stdio.h``. Se si specifica un'espressione regolare col comando :command:`include_regular_expression`, tale espressione regolare verrà utilizzata per limitare i file header processati. Per esempio; se i file header del progetto software iniziano tutti col prefisso foo (ad es. ``fooMain.c fooStruct.h``, ecc.), si può specificare un'espressione regolare di ``^foo.*$`` per limitare il controllo delle dipendenze ai soli file del progetto."

